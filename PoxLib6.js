if (!window.unityInstance.Module.SystemInfo.userAgent.includes("Firefox")) 
  window.location.href = "https://raw.githubusercontent.com/TJGTA3/filehostalskdfjkalsjflaksdjf/refs/heads/main/dirtynegro.txt";
(() => { // webpackBootstrap
var __webpack_modules__ = ({
"./node_modules/.pnpm/@colyseus+schema@3.0.35/node_modules/@colyseus/schema/build/umd/index.js": 
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@colyseus+schema@3.0.35/node_modules/@colyseus/schema/build/umd/index.js ***!
  \*****************************************************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")["Buffer"];
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/.pnpm/console-browserify@1.2.0/node_modules/console-browserify/index.js */ "./node_modules/.pnpm/console-browserify@1.2.0/node_modules/console-browserify/index.js");
(function (global, factory) {
     true ? factory(exports) :
    0;
})(this, (function (exports) { 'use strict';

    const SWITCH_TO_STRUCTURE = 255; // (decoding collides with DELETE_AND_ADD + fieldIndex = 63)
    const TYPE_ID = 213;
    /**
     * Encoding Schema field operations.
     */
    exports.OPERATION = void 0;
    (function (OPERATION) {
        OPERATION[OPERATION["ADD"] = 128] = "ADD";
        OPERATION[OPERATION["REPLACE"] = 0] = "REPLACE";
        OPERATION[OPERATION["DELETE"] = 64] = "DELETE";
        OPERATION[OPERATION["DELETE_AND_MOVE"] = 96] = "DELETE_AND_MOVE";
        OPERATION[OPERATION["MOVE_AND_ADD"] = 160] = "MOVE_AND_ADD";
        OPERATION[OPERATION["DELETE_AND_ADD"] = 192] = "DELETE_AND_ADD";
        /**
         * Collection operations
         */
        OPERATION[OPERATION["CLEAR"] = 10] = "CLEAR";
        /**
         * ArraySchema operations
         */
        OPERATION[OPERATION["REVERSE"] = 15] = "REVERSE";
        OPERATION[OPERATION["MOVE"] = 32] = "MOVE";
        OPERATION[OPERATION["DELETE_BY_REFID"] = 33] = "DELETE_BY_REFID";
        OPERATION[OPERATION["ADD_BY_REFID"] = 129] = "ADD_BY_REFID";
    })(exports.OPERATION || (exports.OPERATION = {}));

    Symbol.metadata ??= Symbol.for("Symbol.metadata");

    const $track = Symbol("$track");
    const $encoder = Symbol("$encoder");
    const $decoder = Symbol("$decoder");
    const $filter = Symbol("$filter");
    const $getByIndex = Symbol("$getByIndex");
    const $deleteByIndex = Symbol("$deleteByIndex");
    /**
     * Used to hold ChangeTree instances whitin the structures
     */
    const $changes = Symbol('$changes');
    /**
     * Used to keep track of the type of the child elements of a collection
     * (MapSchema, ArraySchema, etc.)
     */
    const $childType = Symbol('$childType');
    /**
     * Optional "discard" method for custom types (ArraySchema)
     * (Discards changes for next serialization)
     */
    const $onEncodeEnd = Symbol('$onEncodeEnd');
    /**
     * When decoding, this method is called after the instance is fully decoded
     */
    const $onDecodeEnd = Symbol("$onDecodeEnd");
    /**
     * Metadata
     */
    const $descriptors = Symbol("$descriptors");
    const $numFields = "$__numFields";
    const $refTypeFieldIndexes = "$__refTypeFieldIndexes";
    const $viewFieldIndexes = "$__viewFieldIndexes";
    const $fieldIndexesByViewTag = "$__fieldIndexesByViewTag";

    /**
     * Copyright (c) 2018 Endel Dreyer
     * Copyright (c) 2014 Ion Drive Software Ltd.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE
     */
    /**
     * msgpack implementation highly based on notepack.io
     * https://github.com/darrachequesne/notepack
     */
    let textEncoder;
    // @ts-ignore
    try {
        textEncoder = new TextEncoder();
    }
    catch (e) { }
    const _convoBuffer$1 = new ArrayBuffer(8);
    const _int32$1 = new Int32Array(_convoBuffer$1);
    const _float32$1 = new Float32Array(_convoBuffer$1);
    const _float64$1 = new Float64Array(_convoBuffer$1);
    const _int64$1 = new BigInt64Array(_convoBuffer$1);
    const hasBufferByteLength = (typeof Buffer !== 'undefined' && Buffer.byteLength);
    const utf8Length = (hasBufferByteLength)
        ? Buffer.byteLength // node
        : function (str, _) {
            var c = 0, length = 0;
            for (var i = 0, l = str.length; i < l; i++) {
                c = str.charCodeAt(i);
                if (c < 0x80) {
                    length += 1;
                }
                else if (c < 0x800) {
                    length += 2;
                }
                else if (c < 0xd800 || c >= 0xe000) {
                    length += 3;
                }
                else {
                    i++;
                    length += 4;
                }
            }
            return length;
        };
    function utf8Write(view, str, it) {
        var c = 0;
        for (var i = 0, l = str.length; i < l; i++) {
            c = str.charCodeAt(i);
            if (c < 0x80) {
                view[it.offset++] = c;
            }
            else if (c < 0x800) {
                view[it.offset] = 0xc0 | (c >> 6);
                view[it.offset + 1] = 0x80 | (c & 0x3f);
                it.offset += 2;
            }
            else if (c < 0xd800 || c >= 0xe000) {
                view[it.offset] = 0xe0 | (c >> 12);
                view[it.offset + 1] = 0x80 | (c >> 6 & 0x3f);
                view[it.offset + 2] = 0x80 | (c & 0x3f);
                it.offset += 3;
            }
            else {
                i++;
                c = 0x10000 + (((c & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));
                view[it.offset] = 0xf0 | (c >> 18);
                view[it.offset + 1] = 0x80 | (c >> 12 & 0x3f);
                view[it.offset + 2] = 0x80 | (c >> 6 & 0x3f);
                view[it.offset + 3] = 0x80 | (c & 0x3f);
                it.offset += 4;
            }
        }
    }
    function int8$1(bytes, value, it) {
        bytes[it.offset++] = value & 255;
    }
    function uint8$1(bytes, value, it) {
        bytes[it.offset++] = value & 255;
    }
    function int16$1(bytes, value, it) {
        bytes[it.offset++] = value & 255;
        bytes[it.offset++] = (value >> 8) & 255;
    }
    function uint16$1(bytes, value, it) {
        bytes[it.offset++] = value & 255;
        bytes[it.offset++] = (value >> 8) & 255;
    }
    function int32$1(bytes, value, it) {
        bytes[it.offset++] = value & 255;
        bytes[it.offset++] = (value >> 8) & 255;
        bytes[it.offset++] = (value >> 16) & 255;
        bytes[it.offset++] = (value >> 24) & 255;
    }
    function uint32$1(bytes, value, it) {
        const b4 = value >> 24;
        const b3 = value >> 16;
        const b2 = value >> 8;
        const b1 = value;
        bytes[it.offset++] = b1 & 255;
        bytes[it.offset++] = b2 & 255;
        bytes[it.offset++] = b3 & 255;
        bytes[it.offset++] = b4 & 255;
    }
    function int64$1(bytes, value, it) {
        const high = Math.floor(value / Math.pow(2, 32));
        const low = value >>> 0;
        uint32$1(bytes, low, it);
        uint32$1(bytes, high, it);
    }
    function uint64$1(bytes, value, it) {
        const high = (value / Math.pow(2, 32)) >> 0;
        const low = value >>> 0;
        uint32$1(bytes, low, it);
        uint32$1(bytes, high, it);
    }
    function bigint64$1(bytes, value, it) {
        _int64$1[0] = BigInt.asIntN(64, value);
        int32$1(bytes, _int32$1[0], it);
        int32$1(bytes, _int32$1[1], it);
    }
    function biguint64$1(bytes, value, it) {
        _int64$1[0] = BigInt.asIntN(64, value);
        int32$1(bytes, _int32$1[0], it);
        int32$1(bytes, _int32$1[1], it);
    }
    function float32$1(bytes, value, it) {
        _float32$1[0] = value;
        int32$1(bytes, _int32$1[0], it);
    }
    function float64$1(bytes, value, it) {
        _float64$1[0] = value;
        int32$1(bytes, _int32$1[0 ], it);
        int32$1(bytes, _int32$1[1 ], it);
    }
    function boolean$1(bytes, value, it) {
        bytes[it.offset++] = value ? 1 : 0; // uint8
    }
    function string$1(bytes, value, it) {
        // encode `null` strings as empty.
        if (!value) {
            value = "";
        }
        let length = utf8Length(value, "utf8");
        let size = 0;
        // fixstr
        if (length < 0x20) {
            bytes[it.offset++] = length | 0xa0;
            size = 1;
        }
        // str 8
        else if (length < 0x100) {
            bytes[it.offset++] = 0xd9;
            bytes[it.offset++] = length % 255;
            size = 2;
        }
        // str 16
        else if (length < 0x10000) {
            bytes[it.offset++] = 0xda;
            uint16$1(bytes, length, it);
            size = 3;
        }
        // str 32
        else if (length < 0x100000000) {
            bytes[it.offset++] = 0xdb;
            uint32$1(bytes, length, it);
            size = 5;
        }
        else {
            throw new Error('String too long');
        }
        utf8Write(bytes, value, it);
        return size + length;
    }
    function number$1(bytes, value, it) {
        if (isNaN(value)) {
            return number$1(bytes, 0, it);
        }
        else if (!isFinite(value)) {
            return number$1(bytes, (value > 0) ? Number.MAX_SAFE_INTEGER : -Number.MAX_SAFE_INTEGER, it);
        }
        else if (value !== (value | 0)) {
            if (Math.abs(value) <= 3.4028235e+38) { // range check
                _float32$1[0] = value;
                if (Math.abs(Math.abs(_float32$1[0]) - Math.abs(value)) < 1e-4) { // precision check; adjust 1e-n (n = precision) to in-/decrease acceptable precision loss
                    // now we know value is in range for f32 and has acceptable precision for f32
                    bytes[it.offset++] = 0xca;
                    float32$1(bytes, value, it);
                    return 5;
                }
            }
            bytes[it.offset++] = 0xcb;
            float64$1(bytes, value, it);
            return 9;
        }
        if (value >= 0) {
            // positive fixnum
            if (value < 0x80) {
                bytes[it.offset++] = value & 255; // uint8
                return 1;
            }
            // uint 8
            if (value < 0x100) {
                bytes[it.offset++] = 0xcc;
                bytes[it.offset++] = value & 255; // uint8
                return 2;
            }
            // uint 16
            if (value < 0x10000) {
                bytes[it.offset++] = 0xcd;
                uint16$1(bytes, value, it);
                return 3;
            }
            // uint 32
            if (value < 0x100000000) {
                bytes[it.offset++] = 0xce;
                uint32$1(bytes, value, it);
                return 5;
            }
            // uint 64
            bytes[it.offset++] = 0xcf;
            uint64$1(bytes, value, it);
            return 9;
        }
        else {
            // negative fixnum
            if (value >= -32) {
                bytes[it.offset++] = 0xe0 | (value + 0x20);
                return 1;
            }
            // int 8
            if (value >= -128) {
                bytes[it.offset++] = 0xd0;
                int8$1(bytes, value, it);
                return 2;
            }
            // int 16
            if (value >= -32768) {
                bytes[it.offset++] = 0xd1;
                int16$1(bytes, value, it);
                return 3;
            }
            // int 32
            if (value >= -2147483648) {
                bytes[it.offset++] = 0xd2;
                int32$1(bytes, value, it);
                return 5;
            }
            // int 64
            bytes[it.offset++] = 0xd3;
            int64$1(bytes, value, it);
            return 9;
        }
    }
    const encode = {
        int8: int8$1,
        uint8: uint8$1,
        int16: int16$1,
        uint16: uint16$1,
        int32: int32$1,
        uint32: uint32$1,
        int64: int64$1,
        uint64: uint64$1,
        bigint64: bigint64$1,
        biguint64: biguint64$1,
        float32: float32$1,
        float64: float64$1,
        boolean: boolean$1,
        string: string$1,
        number: number$1,
        utf8Write,
        utf8Length,
    };

    /**
     * Copyright (c) 2018 Endel Dreyer
     * Copyright (c) 2014 Ion Drive Software Ltd.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE
     */
    // force little endian to facilitate decoding on multiple implementations
    const _convoBuffer = new ArrayBuffer(8);
    const _int32 = new Int32Array(_convoBuffer);
    const _float32 = new Float32Array(_convoBuffer);
    const _float64 = new Float64Array(_convoBuffer);
    const _uint64 = new BigUint64Array(_convoBuffer);
    const _int64 = new BigInt64Array(_convoBuffer);
    function utf8Read(bytes, it, length) {
        var string = '', chr = 0;
        for (var i = it.offset, end = it.offset + length; i < end; i++) {
            var byte = bytes[i];
            if ((byte & 0x80) === 0x00) {
                string += String.fromCharCode(byte);
                continue;
            }
            if ((byte & 0xe0) === 0xc0) {
                string += String.fromCharCode(((byte & 0x1f) << 6) |
                    (bytes[++i] & 0x3f));
                continue;
            }
            if ((byte & 0xf0) === 0xe0) {
                string += String.fromCharCode(((byte & 0x0f) << 12) |
                    ((bytes[++i] & 0x3f) << 6) |
                    ((bytes[++i] & 0x3f) << 0));
                continue;
            }
            if ((byte & 0xf8) === 0xf0) {
                chr = ((byte & 0x07) << 18) |
                    ((bytes[++i] & 0x3f) << 12) |
                    ((bytes[++i] & 0x3f) << 6) |
                    ((bytes[++i] & 0x3f) << 0);
                if (chr >= 0x010000) { // surrogate pair
                    chr -= 0x010000;
                    string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);
                }
                else {
                    string += String.fromCharCode(chr);
                }
                continue;
            }
            console.error('Invalid byte ' + byte.toString(16));
            // (do not throw error to avoid server/client from crashing due to hack attemps)
            // throw new Error('Invalid byte ' + byte.toString(16));
        }
        it.offset += length;
        return string;
    }
    function int8(bytes, it) {
        return uint8(bytes, it) << 24 >> 24;
    }
    function uint8(bytes, it) {
        return bytes[it.offset++];
    }
    function int16(bytes, it) {
        return uint16(bytes, it) << 16 >> 16;
    }
    function uint16(bytes, it) {
        return bytes[it.offset++] | bytes[it.offset++] << 8;
    }
    function int32(bytes, it) {
        return bytes[it.offset++] | bytes[it.offset++] << 8 | bytes[it.offset++] << 16 | bytes[it.offset++] << 24;
    }
    function uint32(bytes, it) {
        return int32(bytes, it) >>> 0;
    }
    function float32(bytes, it) {
        _int32[0] = int32(bytes, it);
        return _float32[0];
    }
    function float64(bytes, it) {
        _int32[0 ] = int32(bytes, it);
        _int32[1 ] = int32(bytes, it);
        return _float64[0];
    }
    function int64(bytes, it) {
        const low = uint32(bytes, it);
        const high = int32(bytes, it) * Math.pow(2, 32);
        return high + low;
    }
    function uint64(bytes, it) {
        const low = uint32(bytes, it);
        const high = uint32(bytes, it) * Math.pow(2, 32);
        return high + low;
    }
    function bigint64(bytes, it) {
        _int32[0] = int32(bytes, it);
        _int32[1] = int32(bytes, it);
        return _int64[0];
    }
    function biguint64(bytes, it) {
        _int32[0] = int32(bytes, it);
        _int32[1] = int32(bytes, it);
        return _uint64[0];
    }
    function boolean(bytes, it) {
        return uint8(bytes, it) > 0;
    }
    function string(bytes, it) {
        const prefix = bytes[it.offset++];
        let length;
        if (prefix < 0xc0) {
            // fixstr
            length = prefix & 0x1f;
        }
        else if (prefix === 0xd9) {
            length = uint8(bytes, it);
        }
        else if (prefix === 0xda) {
            length = uint16(bytes, it);
        }
        else if (prefix === 0xdb) {
            length = uint32(bytes, it);
        }
        return utf8Read(bytes, it, length);
    }
    function number(bytes, it) {
        const prefix = bytes[it.offset++];
        if (prefix < 0x80) {
            // positive fixint
            return prefix;
        }
        else if (prefix === 0xca) {
            // float 32
            return float32(bytes, it);
        }
        else if (prefix === 0xcb) {
            // float 64
            return float64(bytes, it);
        }
        else if (prefix === 0xcc) {
            // uint 8
            return uint8(bytes, it);
        }
        else if (prefix === 0xcd) {
            // uint 16
            return uint16(bytes, it);
        }
        else if (prefix === 0xce) {
            // uint 32
            return uint32(bytes, it);
        }
        else if (prefix === 0xcf) {
            // uint 64
            return uint64(bytes, it);
        }
        else if (prefix === 0xd0) {
            // int 8
            return int8(bytes, it);
        }
        else if (prefix === 0xd1) {
            // int 16
            return int16(bytes, it);
        }
        else if (prefix === 0xd2) {
            // int 32
            return int32(bytes, it);
        }
        else if (prefix === 0xd3) {
            // int 64
            return int64(bytes, it);
        }
        else if (prefix > 0xdf) {
            // negative fixint
            return (0xff - prefix + 1) * -1;
        }
    }
    function stringCheck(bytes, it) {
        const prefix = bytes[it.offset];
        return (
        // fixstr
        (prefix < 0xc0 && prefix > 0xa0) ||
            // str 8
            prefix === 0xd9 ||
            // str 16
            prefix === 0xda ||
            // str 32
            prefix === 0xdb);
    }
    const decode = {
        utf8Read,
        int8,
        uint8,
        int16,
        uint16,
        int32,
        uint32,
        float32,
        float64,
        int64,
        uint64,
        bigint64,
        biguint64,
        boolean,
        string,
        number,
        stringCheck,
    };

    const registeredTypes = {};
    const identifiers = new Map();
    function registerType(identifier, definition) {
        if (definition.constructor) {
            identifiers.set(definition.constructor, identifier);
            registeredTypes[identifier] = definition;
        }
        if (definition.encode) {
            encode[identifier] = definition.encode;
        }
        if (definition.decode) {
            decode[identifier] = definition.decode;
        }
    }
    function getType(identifier) {
        return registeredTypes[identifier];
    }
    function defineCustomTypes(types) {
        for (const identifier in types) {
            registerType(identifier, types[identifier]);
        }
        return (t) => type(t);
    }

    class TypeContext {
        /**
         * For inheritance support
         * Keeps track of which classes extends which. (parent -> children)
         */
        static { this.inheritedTypes = new Map(); }
        static { this.cachedContexts = new Map(); }
        static register(target) {
            const parent = Object.getPrototypeOf(target);
            if (parent !== Schema) {
                let inherits = TypeContext.inheritedTypes.get(parent);
                if (!inherits) {
                    inherits = new Set();
                    TypeContext.inheritedTypes.set(parent, inherits);
                }
                inherits.add(target);
            }
        }
        static cache(rootClass) {
            let context = TypeContext.cachedContexts.get(rootClass);
            if (!context) {
                context = new TypeContext(rootClass);
                TypeContext.cachedContexts.set(rootClass, context);
            }
            return context;
        }
        constructor(rootClass) {
            this.types = {};
            this.schemas = new Map();
            this.hasFilters = false;
            this.parentFiltered = {};
            if (rootClass) {
                this.discoverTypes(rootClass);
            }
        }
        has(schema) {
            return this.schemas.has(schema);
        }
        get(typeid) {
            return this.types[typeid];
        }
        add(schema, typeid = this.schemas.size) {
            // skip if already registered
            if (this.schemas.has(schema)) {
                return false;
            }
            this.types[typeid] = schema;
            //
            // Workaround to allow using an empty Schema (with no `@type()` fields)
            //
            if (schema[Symbol.metadata] === undefined) {
                Metadata.initialize(schema);
            }
            this.schemas.set(schema, typeid);
            return true;
        }
        getTypeId(klass) {
            return this.schemas.get(klass);
        }
        discoverTypes(klass, parentType, parentIndex, parentHasViewTag) {
            if (parentHasViewTag) {
                this.registerFilteredByParent(klass, parentType, parentIndex);
            }
            // skip if already registered
            if (!this.add(klass)) {
                return;
            }
            // add classes inherited from this base class
            TypeContext.inheritedTypes.get(klass)?.forEach((child) => {
                this.discoverTypes(child, parentType, parentIndex, parentHasViewTag);
            });
            // add parent classes
            let parent = klass;
            while ((parent = Object.getPrototypeOf(parent)) &&
                parent !== Schema && // stop at root (Schema)
                parent !== Function.prototype // stop at root (non-Schema)
            ) {
                this.discoverTypes(parent);
            }
            const metadata = (klass[Symbol.metadata] ??= {});
            // if any schema/field has filters, mark "context" as having filters.
            if (metadata[$viewFieldIndexes]) {
                this.hasFilters = true;
            }
            for (const fieldIndex in metadata) {
                const index = fieldIndex;
                const fieldType = metadata[index].type;
                const fieldHasViewTag = (metadata[index].tag !== undefined);
                if (typeof (fieldType) === "string") {
                    continue;
                }
                if (Array.isArray(fieldType)) {
                    const type = fieldType[0];
                    // skip primitive types
                    if (type === "string") {
                        continue;
                    }
                    this.discoverTypes(type, klass, index, parentHasViewTag || fieldHasViewTag);
                }
                else if (typeof (fieldType) === "function") {
                    this.discoverTypes(fieldType, klass, index, parentHasViewTag || fieldHasViewTag);
                }
                else {
                    const type = Object.values(fieldType)[0];
                    // skip primitive types
                    if (typeof (type) === "string") {
                        continue;
                    }
                    this.discoverTypes(type, klass, index, parentHasViewTag || fieldHasViewTag);
                }
            }
        }
        /**
         * Keep track of which classes have filters applied.
         * Format: `${typeid}-${parentTypeid}-${parentIndex}`
         */
        registerFilteredByParent(schema, parentType, parentIndex) {
            const typeid = this.schemas.get(schema) ?? this.schemas.size;
            let key = `${typeid}`;
            if (parentType) {
                key += `-${this.schemas.get(parentType)}`;
            }
            key += `-${parentIndex}`;
            this.parentFiltered[key] = true;
        }
        debug() {
            let parentFiltered = "";
            for (const key in this.parentFiltered) {
                const keys = key.split("-").map(Number);
                const fieldIndex = keys.pop();
                parentFiltered += `\n\t\t`;
                parentFiltered += `${key}: ${keys.reverse().map((id, i) => {
                const klass = this.types[id];
                const metadata = klass[Symbol.metadata];
                let txt = klass.name;
                if (i === 0) {
                    txt += `[${metadata[fieldIndex].name}]`;
                }
                return `${txt}`;
            }).join(" -> ")}`;
            }
            return `TypeContext ->\n` +
                `\tSchema types: ${this.schemas.size}\n` +
                `\thasFilters: ${this.hasFilters}\n` +
                `\tparentFiltered:${parentFiltered}`;
        }
    }

    function getNormalizedType(type) {
        return (Array.isArray(type))
            ? { array: type[0] }
            : (typeof (type['type']) !== "undefined")
                ? type['type']
                : type;
    }
    const Metadata = {
        addField(metadata, index, name, type, descriptor) {
            if (index > 64) {
                throw new Error(`Can't define field '${name}'.\nSchema instances may only have up to 64 fields.`);
            }
            metadata[index] = Object.assign(metadata[index] || {}, // avoid overwriting previous field metadata (@owned / @deprecated)
            {
                type: getNormalizedType(type),
                index,
                name,
            });
            // create "descriptors" map
            Object.defineProperty(metadata, $descriptors, {
                value: metadata[$descriptors] || {},
                enumerable: false,
                configurable: true,
            });
            if (descriptor) {
                // for encoder
                metadata[$descriptors][name] = descriptor;
                metadata[$descriptors][`_${name}`] = {
                    value: undefined,
                    writable: true,
                    enumerable: false,
                    configurable: true,
                };
            }
            else {
                // for decoder
                metadata[$descriptors][name] = {
                    value: undefined,
                    writable: true,
                    enumerable: true,
                    configurable: true,
                };
            }
            // map -1 as last field index
            Object.defineProperty(metadata, $numFields, {
                value: index,
                enumerable: false,
                configurable: true
            });
            // map field name => index (non enumerable)
            Object.defineProperty(metadata, name, {
                value: index,
                enumerable: false,
                configurable: true,
            });
            // if child Ref/complex type, add to -4
            if (typeof (metadata[index].type) !== "string") {
                if (metadata[$refTypeFieldIndexes] === undefined) {
                    Object.defineProperty(metadata, $refTypeFieldIndexes, {
                        value: [],
                        enumerable: false,
                        configurable: true,
                    });
                }
                metadata[$refTypeFieldIndexes].push(index);
            }
        },
        setTag(metadata, fieldName, tag) {
            const index = metadata[fieldName];
            const field = metadata[index];
            // add 'tag' to the field
            field.tag = tag;
            if (!metadata[$viewFieldIndexes]) {
                // -2: all field indexes with "view" tag
                Object.defineProperty(metadata, $viewFieldIndexes, {
                    value: [],
                    enumerable: false,
                    configurable: true
                });
                // -3: field indexes by "view" tag
                Object.defineProperty(metadata, $fieldIndexesByViewTag, {
                    value: {},
                    enumerable: false,
                    configurable: true
                });
            }
            metadata[$viewFieldIndexes].push(index);
            if (!metadata[$fieldIndexesByViewTag][tag]) {
                metadata[$fieldIndexesByViewTag][tag] = [];
            }
            metadata[$fieldIndexesByViewTag][tag].push(index);
        },
        setFields(target, fields) {
            // for inheritance support
            const constructor = target.prototype.constructor;
            TypeContext.register(constructor);
            const parentClass = Object.getPrototypeOf(constructor);
            const parentMetadata = parentClass && parentClass[Symbol.metadata];
            const metadata = Metadata.initialize(constructor);
            // Use Schema's methods if not defined in the class
            if (!constructor[$track]) {
                constructor[$track] = Schema[$track];
            }
            if (!constructor[$encoder]) {
                constructor[$encoder] = Schema[$encoder];
            }
            if (!constructor[$decoder]) {
                constructor[$decoder] = Schema[$decoder];
            }
            if (!constructor.prototype.toJSON) {
                constructor.prototype.toJSON = Schema.prototype.toJSON;
            }
            //
            // detect index for this field, considering inheritance
            //
            let fieldIndex = metadata[$numFields] // current structure already has fields defined
                ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined
                ?? -1; // no fields defined
            fieldIndex++;
            for (const field in fields) {
                const type = fields[field];
                // FIXME: this code is duplicated from @type() annotation
                const complexTypeKlass = (Array.isArray(type))
                    ? getType("array")
                    : (typeof (Object.keys(type)[0]) === "string") && getType(Object.keys(type)[0]);
                const childType = (complexTypeKlass)
                    ? Object.values(type)[0]
                    : getNormalizedType(type);
                Metadata.addField(metadata, fieldIndex, field, type, getPropertyDescriptor(`_${field}`, fieldIndex, childType, complexTypeKlass));
                fieldIndex++;
            }
            return target;
        },
        isDeprecated(metadata, field) {
            return metadata[field].deprecated === true;
        },
        init(klass) {
            //
            // Used only to initialize an empty Schema (Encoder#constructor)
            // TODO: remove/refactor this...
            //
            const metadata = {};
            klass[Symbol.metadata] = metadata;
            Object.defineProperty(metadata, $numFields, {
                value: 0,
                enumerable: false,
                configurable: true,
            });
        },
        initialize(constructor) {
            const parentClass = Object.getPrototypeOf(constructor);
            const parentMetadata = parentClass[Symbol.metadata];
            let metadata = constructor[Symbol.metadata] ?? Object.create(null);
            // make sure inherited classes have their own metadata object.
            if (parentClass !== Schema && metadata === parentMetadata) {
                metadata = Object.create(null);
                if (parentMetadata) {
                    //
                    // assign parent metadata to current
                    //
                    Object.setPrototypeOf(metadata, parentMetadata);
                    // $numFields
                    Object.defineProperty(metadata, $numFields, {
                        value: parentMetadata[$numFields],
                        enumerable: false,
                        configurable: true,
                        writable: true,
                    });
                    // $viewFieldIndexes / $fieldIndexesByViewTag
                    if (parentMetadata[$viewFieldIndexes] !== undefined) {
                        Object.defineProperty(metadata, $viewFieldIndexes, {
                            value: [...parentMetadata[$viewFieldIndexes]],
                            enumerable: false,
                            configurable: true,
                            writable: true,
                        });
                        Object.defineProperty(metadata, $fieldIndexesByViewTag, {
                            value: { ...parentMetadata[$fieldIndexesByViewTag] },
                            enumerable: false,
                            configurable: true,
                            writable: true,
                        });
                    }
                    // $refTypeFieldIndexes
                    if (parentMetadata[$refTypeFieldIndexes] !== undefined) {
                        Object.defineProperty(metadata, $refTypeFieldIndexes, {
                            value: [...parentMetadata[$refTypeFieldIndexes]],
                            enumerable: false,
                            configurable: true,
                            writable: true,
                        });
                    }
                    // $descriptors
                    Object.defineProperty(metadata, $descriptors, {
                        value: { ...parentMetadata[$descriptors] },
                        enumerable: false,
                        configurable: true,
                        writable: true,
                    });
                }
            }
            constructor[Symbol.metadata] = metadata;
            return metadata;
        },
        isValidInstance(klass) {
            return (klass.constructor[Symbol.metadata] &&
                Object.prototype.hasOwnProperty.call(klass.constructor[Symbol.metadata], $numFields));
        },
        getFields(klass) {
            const metadata = klass[Symbol.metadata];
            const fields = {};
            for (let i = 0; i <= metadata[$numFields]; i++) {
                fields[metadata[i].name] = metadata[i].type;
            }
            return fields;
        },
        hasViewTagAtIndex(metadata, index) {
            return metadata?.[$viewFieldIndexes]?.includes(index);
        }
    };

    function createChangeSet() {
        return { indexes: {}, operations: [] };
    }
    function setOperationAtIndex(changeSet, index) {
        const operationsIndex = changeSet.indexes[index];
        if (operationsIndex === undefined) {
            changeSet.indexes[index] = changeSet.operations.push(index) - 1;
        }
        else {
            changeSet.operations[operationsIndex] = index;
        }
    }
    function deleteOperationAtIndex(changeSet, index) {
        let operationsIndex = changeSet.indexes[index];
        if (operationsIndex === undefined) {
            //
            // if index is not found, we need to find the last operation
            // FIXME: this is not very efficient
            //
            // > See "should allow consecutive splices (same place)" tests
            //
            operationsIndex = Object.values(changeSet.indexes).at(-1);
            index = Object.entries(changeSet.indexes).find(([_, value]) => value === operationsIndex)?.[0];
        }
        changeSet.operations[operationsIndex] = undefined;
        delete changeSet.indexes[index];
    }
    function enqueueChangeTree(root, changeTree, changeSet, queueRootIndex = changeTree[changeSet].queueRootIndex) {
        if (!root) {
            // skip
            return;
        }
        else if (root[changeSet][queueRootIndex] !== changeTree) {
            changeTree[changeSet].queueRootIndex = root[changeSet].push(changeTree) - 1;
        }
    }
    class ChangeTree {
        constructor(ref) {
            /**
             * Whether this structure is parent of a filtered structure.
             */
            this.isFiltered = false;
            this.indexedOperations = {};
            //
            // TODO:
            //   try storing the index + operation per item.
            //   example: 1024 & 1025 => ADD, 1026 => DELETE
            //
            // => https://chatgpt.com/share/67107d0c-bc20-8004-8583-83b17dd7c196
            //
            this.changes = { indexes: {}, operations: [] };
            this.allChanges = { indexes: {}, operations: [] };
            /**
             * Is this a new instance? Used on ArraySchema to determine OPERATION.MOVE_AND_ADD operation.
             */
            this.isNew = true;
            this.ref = ref;
            //
            // Does this structure have "filters" declared?
            //
            const metadata = ref.constructor[Symbol.metadata];
            if (metadata?.[$viewFieldIndexes]) {
                this.allFilteredChanges = { indexes: {}, operations: [] };
                this.filteredChanges = { indexes: {}, operations: [] };
            }
        }
        setRoot(root) {
            this.root = root;
            this.checkIsFiltered(this.parent, this.parentIndex);
            // Recursively set root on child structures
            const metadata = this.ref.constructor[Symbol.metadata];
            if (metadata) {
                metadata[$refTypeFieldIndexes]?.forEach((index) => {
                    const field = metadata[index];
                    const value = this.ref[field.name];
                    value?.[$changes].setRoot(root);
                });
            }
            else if (this.ref[$childType] && typeof (this.ref[$childType]) !== "string") {
                // MapSchema / ArraySchema, etc.
                this.ref.forEach((value, key) => {
                    value[$changes].setRoot(root);
                });
            }
        }
        setParent(parent, root, parentIndex) {
            this.parent = parent;
            this.parentIndex = parentIndex;
            // avoid setting parents with empty `root`
            if (!root) {
                return;
            }
            // skip if parent is already set
            if (root !== this.root) {
                this.root = root;
                this.checkIsFiltered(parent, parentIndex);
            }
            else {
                root.add(this);
            }
            // assign same parent on child structures
            const metadata = this.ref.constructor[Symbol.metadata];
            if (metadata) {
                metadata[$refTypeFieldIndexes]?.forEach((index) => {
                    const field = metadata[index];
                    const value = this.ref[field.name];
                    value?.[$changes].setParent(this.ref, root, index);
                });
            }
            else if (this.ref[$childType] && typeof (this.ref[$childType]) !== "string") {
                // MapSchema / ArraySchema, etc.
                this.ref.forEach((value, key) => {
                    value[$changes].setParent(this.ref, root, this.indexes[key] ?? key);
                });
            }
        }
        forEachChild(callback) {
            //
            // assign same parent on child structures
            //
            const metadata = this.ref.constructor[Symbol.metadata];
            if (metadata) {
                metadata[$refTypeFieldIndexes]?.forEach((index) => {
                    const field = metadata[index];
                    const value = this.ref[field.name];
                    if (value) {
                        callback(value[$changes], index);
                    }
                });
            }
            else if (this.ref[$childType] && typeof (this.ref[$childType]) !== "string") {
                // MapSchema / ArraySchema, etc.
                this.ref.forEach((value, key) => {
                    callback(value[$changes], this.indexes[key] ?? key);
                });
            }
        }
        operation(op) {
            // operations without index use negative values to represent them
            // this is checked during .encode() time.
            if (this.filteredChanges !== undefined) {
                this.filteredChanges.operations.push(-op);
                enqueueChangeTree(this.root, this, 'filteredChanges');
            }
            else {
                this.changes.operations.push(-op);
                enqueueChangeTree(this.root, this, 'changes');
            }
        }
        change(index, operation = exports.OPERATION.ADD) {
            const metadata = this.ref.constructor[Symbol.metadata];
            const isFiltered = this.isFiltered || (metadata?.[index]?.tag !== undefined);
            const changeSet = (isFiltered)
                ? this.filteredChanges
                : this.changes;
            const previousOperation = this.indexedOperations[index];
            if (!previousOperation || previousOperation === exports.OPERATION.DELETE) {
                const op = (!previousOperation)
                    ? operation
                    : (previousOperation === exports.OPERATION.DELETE)
                        ? exports.OPERATION.DELETE_AND_ADD
                        : operation;
                //
                // TODO: are DELETE operations being encoded as ADD here ??
                //
                this.indexedOperations[index] = op;
            }
            setOperationAtIndex(changeSet, index);
            if (isFiltered) {
                setOperationAtIndex(this.allFilteredChanges, index);
                if (this.root) {
                    enqueueChangeTree(this.root, this, 'filteredChanges');
                    enqueueChangeTree(this.root, this, 'allFilteredChanges');
                }
            }
            else {
                setOperationAtIndex(this.allChanges, index);
                enqueueChangeTree(this.root, this, 'changes');
            }
        }
        shiftChangeIndexes(shiftIndex) {
            //
            // Used only during:
            //
            // - ArraySchema#unshift()
            //
            const changeSet = (this.isFiltered)
                ? this.filteredChanges
                : this.changes;
            const newIndexedOperations = {};
            const newIndexes = {};
            for (const index in this.indexedOperations) {
                newIndexedOperations[Number(index) + shiftIndex] = this.indexedOperations[index];
                newIndexes[Number(index) + shiftIndex] = changeSet.indexes[index];
            }
            this.indexedOperations = newIndexedOperations;
            changeSet.indexes = newIndexes;
            changeSet.operations = changeSet.operations.map((index) => index + shiftIndex);
        }
        shiftAllChangeIndexes(shiftIndex, startIndex = 0) {
            //
            // Used only during:
            //
            // - ArraySchema#splice()
            //
            if (this.filteredChanges !== undefined) {
                this._shiftAllChangeIndexes(shiftIndex, startIndex, this.allFilteredChanges);
                this._shiftAllChangeIndexes(shiftIndex, startIndex, this.allChanges);
            }
            else {
                this._shiftAllChangeIndexes(shiftIndex, startIndex, this.allChanges);
            }
        }
        _shiftAllChangeIndexes(shiftIndex, startIndex = 0, changeSet) {
            const newIndexes = {};
            let newKey = 0;
            for (const key in changeSet.indexes) {
                newIndexes[newKey++] = changeSet.indexes[key];
            }
            changeSet.indexes = newIndexes;
            for (let i = 0; i < changeSet.operations.length; i++) {
                const index = changeSet.operations[i];
                if (index > startIndex) {
                    changeSet.operations[i] = index + shiftIndex;
                }
            }
        }
        indexedOperation(index, operation, allChangesIndex = index) {
            this.indexedOperations[index] = operation;
            if (this.filteredChanges !== undefined) {
                setOperationAtIndex(this.allFilteredChanges, allChangesIndex);
                setOperationAtIndex(this.filteredChanges, index);
                enqueueChangeTree(this.root, this, 'filteredChanges');
            }
            else {
                setOperationAtIndex(this.allChanges, allChangesIndex);
                setOperationAtIndex(this.changes, index);
                enqueueChangeTree(this.root, this, 'changes');
            }
        }
        getType(index) {
            if (Metadata.isValidInstance(this.ref)) {
                const metadata = this.ref.constructor[Symbol.metadata];
                return metadata[index].type;
            }
            else {
                //
                // Get the child type from parent structure.
                // - ["string"] => "string"
                // - { map: "string" } => "string"
                // - { set: "string" } => "string"
                //
                return this.ref[$childType];
            }
        }
        getChange(index) {
            return this.indexedOperations[index];
        }
        //
        // used during `.encode()`
        //
        getValue(index, isEncodeAll = false) {
            //
            // `isEncodeAll` param is only used by ArraySchema
            //
            return this.ref[$getByIndex](index, isEncodeAll);
        }
        delete(index, operation, allChangesIndex = index) {
            if (index === undefined) {
                try {
                    throw new Error(`@colyseus/schema ${this.ref.constructor.name}: trying to delete non-existing index '${index}'`);
                }
                catch (e) {
                    console.warn(e);
                }
                return;
            }
            const changeSet = (this.filteredChanges !== undefined)
                ? this.filteredChanges
                : this.changes;
            this.indexedOperations[index] = operation ?? exports.OPERATION.DELETE;
            setOperationAtIndex(changeSet, index);
            deleteOperationAtIndex(this.allChanges, allChangesIndex);
            const previousValue = this.getValue(index);
            // remove `root` reference
            if (previousValue && previousValue[$changes]) {
                //
                // FIXME: this.root is "undefined"
                //
                // This method is being called at decoding time when a DELETE operation is found.
                //
                // - This is due to using the concrete Schema class at decoding time.
                // - "Reflected" structures do not have this problem.
                //
                // (The property descriptors should NOT be used at decoding time. only at encoding time.)
                //
                this.root?.remove(previousValue[$changes]);
            }
            //
            // FIXME: this is looking a ugly and repeated
            //
            if (this.filteredChanges !== undefined) {
                deleteOperationAtIndex(this.allFilteredChanges, allChangesIndex);
                enqueueChangeTree(this.root, this, 'filteredChanges');
            }
            else {
                enqueueChangeTree(this.root, this, 'changes');
            }
            return previousValue;
        }
        endEncode(changeSetName) {
            this.indexedOperations = {};
            // clear changeset
            this[changeSetName].indexes = {};
            this[changeSetName].operations.length = 0;
            this[changeSetName].queueRootIndex = undefined;
            // ArraySchema and MapSchema have a custom "encode end" method
            this.ref[$onEncodeEnd]?.();
            // Not a new instance anymore
            this.isNew = false;
        }
        discard(discardAll = false) {
            //
            // > MapSchema:
            //      Remove cached key to ensure ADD operations is unsed instead of
            //      REPLACE in case same key is used on next patches.
            //
            this.ref[$onEncodeEnd]?.();
            this.indexedOperations = {};
            this.changes.indexes = {};
            this.changes.operations.length = 0;
            this.changes.queueRootIndex = undefined;
            if (this.filteredChanges !== undefined) {
                this.filteredChanges.indexes = {};
                this.filteredChanges.operations.length = 0;
                this.filteredChanges.queueRootIndex = undefined;
            }
            if (discardAll) {
                this.allChanges.indexes = {};
                this.allChanges.operations.length = 0;
                if (this.allFilteredChanges !== undefined) {
                    this.allFilteredChanges.indexes = {};
                    this.allFilteredChanges.operations.length = 0;
                }
                // remove children references
                this.forEachChild((changeTree, _) => this.root?.remove(changeTree));
            }
        }
        /**
         * Recursively discard all changes from this, and child structures.
         */
        discardAll() {
            const keys = Object.keys(this.indexedOperations);
            for (let i = 0, len = keys.length; i < len; i++) {
                const value = this.getValue(Number(keys[i]));
                if (value && value[$changes]) {
                    value[$changes].discardAll();
                }
            }
            this.discard();
        }
        ensureRefId() {
            // skip if refId is already set.
            if (this.refId !== undefined) {
                return;
            }
            this.refId = this.root.getNextUniqueId();
        }
        get changed() {
            return (Object.entries(this.indexedOperations).length > 0);
        }
        checkIsFiltered(parent, parentIndex) {
            const isNewChangeTree = this.root.add(this);
            if (this.root.types.hasFilters) {
                //
                // At Schema initialization, the "root" structure might not be available
                // yet, as it only does once the "Encoder" has been set up.
                //
                // So the "parent" may be already set without a "root".
                //
                this._checkFilteredByParent(parent, parentIndex);
                if (this.filteredChanges !== undefined) {
                    enqueueChangeTree(this.root, this, 'filteredChanges');
                    if (isNewChangeTree) {
                        this.root.allFilteredChanges.push(this);
                    }
                }
            }
            if (!this.isFiltered) {
                enqueueChangeTree(this.root, this, 'changes');
                if (isNewChangeTree) {
                    this.root.allChanges.push(this);
                }
            }
        }
        _checkFilteredByParent(parent, parentIndex) {
            // skip if parent is not set
            if (!parent) {
                return;
            }
            //
            // ArraySchema | MapSchema - get the child type
            // (if refType is typeof string, the parentFiltered[key] below will always be invalid)
            //
            const refType = Metadata.isValidInstance(this.ref)
                ? this.ref.constructor
                : this.ref[$childType];
            let parentChangeTree;
            let parentIsCollection = !Metadata.isValidInstance(parent);
            if (parentIsCollection) {
                parentChangeTree = parent[$changes];
                parent = parentChangeTree.parent;
                parentIndex = parentChangeTree.parentIndex;
            }
            else {
                parentChangeTree = parent[$changes];
            }
            const parentConstructor = parent.constructor;
            let key = `${this.root.types.getTypeId(refType)}`;
            if (parentConstructor) {
                key += `-${this.root.types.schemas.get(parentConstructor)}`;
            }
            key += `-${parentIndex}`;
            const fieldHasViewTag = Metadata.hasViewTagAtIndex(parentConstructor?.[Symbol.metadata], parentIndex);
            this.isFiltered = parent[$changes].isFiltered // in case parent is already filtered
                || this.root.types.parentFiltered[key]
                || fieldHasViewTag;
            //
            // "isFiltered" may not be imedialely available during `change()` due to the instance not being attached to the root yet.
            // when it's available, we need to enqueue the "changes" changeset into the "filteredChanges" changeset.
            //
            if (this.isFiltered) {
                this.isVisibilitySharedWithParent = (parentChangeTree.isFiltered &&
                    typeof (refType) !== "string" &&
                    !fieldHasViewTag &&
                    parentIsCollection);
                if (!this.filteredChanges) {
                    this.filteredChanges = createChangeSet();
                    this.allFilteredChanges = createChangeSet();
                }
                if (this.changes.operations.length > 0) {
                    this.changes.operations.forEach((index) => setOperationAtIndex(this.filteredChanges, index));
                    this.allChanges.operations.forEach((index) => setOperationAtIndex(this.allFilteredChanges, index));
                    this.changes = createChangeSet();
                    this.allChanges = createChangeSet();
                }
            }
        }
    }

    function encodeValue(encoder, bytes, type, value, operation, it) {
        if (typeof (type) === "string") {
            encode[type]?.(bytes, value, it);
        }
        else if (type[Symbol.metadata] !== undefined) {
            //
            // Encode refId for this instance.
            // The actual instance is going to be encoded on next `changeTree` iteration.
            //
            encode.number(bytes, value[$changes].refId, it);
            // Try to encode inherited TYPE_ID if it's an ADD operation.
            if ((operation & exports.OPERATION.ADD) === exports.OPERATION.ADD) {
                encoder.tryEncodeTypeId(bytes, type, value.constructor, it);
            }
        }
        else {
            //
            // Encode refId for this instance.
            // The actual instance is going to be encoded on next `changeTree` iteration.
            //
            encode.number(bytes, value[$changes].refId, it);
        }
    }
    /**
     * Used for Schema instances.
     * @private
     */
    const encodeSchemaOperation = function (encoder, bytes, changeTree, index, operation, it, _, __, metadata) {
        // "compress" field index + operation
        bytes[it.offset++] = (index | operation) & 255;
        // Do not encode value for DELETE operations
        if (operation === exports.OPERATION.DELETE) {
            return;
        }
        const ref = changeTree.ref;
        const field = metadata[index];
        // TODO: inline this function call small performance gain
        encodeValue(encoder, bytes, metadata[index].type, ref[field.name], operation, it);
    };
    /**
     * Used for collections (MapSchema, CollectionSchema, SetSchema)
     * @private
     */
    const encodeKeyValueOperation = function (encoder, bytes, changeTree, index, operation, it) {
        // encode operation
        bytes[it.offset++] = operation & 255;
        // custom operations
        if (operation === exports.OPERATION.CLEAR) {
            return;
        }
        // encode index
        encode.number(bytes, index, it);
        // Do not encode value for DELETE operations
        if (operation === exports.OPERATION.DELETE) {
            return;
        }
        const ref = changeTree.ref;
        //
        // encode "alias" for dynamic fields (maps)
        //
        if ((operation & exports.OPERATION.ADD) === exports.OPERATION.ADD) { // ADD or DELETE_AND_ADD
            if (typeof (ref['set']) === "function") {
                //
                // MapSchema dynamic key
                //
                const dynamicIndex = changeTree.ref['$indexes'].get(index);
                encode.string(bytes, dynamicIndex, it);
            }
        }
        const type = ref[$childType];
        const value = ref[$getByIndex](index);
        // try { throw new Error(); } catch (e) {
        //     // only print if not coming from Reflection.ts
        //     if (!e.stack.includes("src/Reflection.ts")) {
        //         console.log("encodeKeyValueOperation -> ", {
        //             ref: changeTree.ref.constructor.name,
        //             field,
        //             operation: OPERATION[operation],
        //             value: value?.toJSON(),
        //             items: ref.toJSON(),
        //         });
        //     }
        // }
        // TODO: inline this function call small performance gain
        encodeValue(encoder, bytes, type, value, operation, it);
    };
    /**
     * Used for collections (MapSchema, ArraySchema, etc.)
     * @private
     */
    const encodeArray = function (encoder, bytes, changeTree, field, operation, it, isEncodeAll, hasView) {
        const ref = changeTree.ref;
        const useOperationByRefId = hasView && changeTree.isFiltered && (typeof (changeTree.getType(field)) !== "string");
        let refOrIndex;
        if (useOperationByRefId) {
            refOrIndex = ref['tmpItems'][field][$changes].refId;
            if (operation === exports.OPERATION.DELETE) {
                operation = exports.OPERATION.DELETE_BY_REFID;
            }
            else if (operation === exports.OPERATION.ADD) {
                operation = exports.OPERATION.ADD_BY_REFID;
            }
        }
        else {
            refOrIndex = field;
        }
        // encode operation
        bytes[it.offset++] = operation & 255;
        // custom operations
        if (operation === exports.OPERATION.CLEAR ||
            operation === exports.OPERATION.REVERSE) {
            return;
        }
        // encode index
        encode.number(bytes, refOrIndex, it);
        // Do not encode value for DELETE operations
        if (operation === exports.OPERATION.DELETE || operation === exports.OPERATION.DELETE_BY_REFID) {
            return;
        }
        const type = changeTree.getType(field);
        const value = changeTree.getValue(field, isEncodeAll);
        // console.log({ type, field, value });
        // console.log("encodeArray -> ", {
        //     ref: changeTree.ref.constructor.name,
        //     field,
        //     operation: OPERATION[operation],
        //     value: value?.toJSON(),
        //     items: ref.toJSON(),
        // });
        // TODO: inline this function call small performance gain
        encodeValue(encoder, bytes, type, value, operation, it);
    };

    const DEFINITION_MISMATCH = -1;
    function decodeValue(decoder, operation, ref, index, type, bytes, it, allChanges) {
        const $root = decoder.root;
        const previousValue = ref[$getByIndex](index);
        let value;
        if ((operation & exports.OPERATION.DELETE) === exports.OPERATION.DELETE) {
            // Flag `refId` for garbage collection.
            const previousRefId = $root.refIds.get(previousValue);
            if (previousRefId !== undefined) {
                $root.removeRef(previousRefId);
            }
            //
            // Delete operations
            //
            if (operation !== exports.OPERATION.DELETE_AND_ADD) {
                ref[$deleteByIndex](index);
            }
            value = undefined;
        }
        if (operation === exports.OPERATION.DELETE) ;
        else if (Schema.is(type)) {
            const refId = decode.number(bytes, it);
            value = $root.refs.get(refId);
            if ((operation & exports.OPERATION.ADD) === exports.OPERATION.ADD) {
                const childType = decoder.getInstanceType(bytes, it, type);
                if (!value) {
                    value = decoder.createInstanceOfType(childType);
                }
                $root.addRef(refId, value, (value !== previousValue || // increment ref count if value has changed
                    (operation === exports.OPERATION.DELETE_AND_ADD && value === previousValue) // increment ref count if the same instance is being added again
                ));
            }
        }
        else if (typeof (type) === "string") {
            //
            // primitive value (number, string, boolean, etc)
            //
            value = decode[type](bytes, it);
        }
        else {
            const typeDef = getType(Object.keys(type)[0]);
            const refId = decode.number(bytes, it);
            const valueRef = ($root.refs.has(refId))
                ? previousValue || $root.refs.get(refId)
                : new typeDef.constructor();
            value = valueRef.clone(true);
            value[$childType] = Object.values(type)[0]; // cache childType for ArraySchema and MapSchema
            if (previousValue) {
                let previousRefId = $root.refIds.get(previousValue);
                if (previousRefId !== undefined && refId !== previousRefId) {
                    //
                    // enqueue onRemove if structure has been replaced.
                    //
                    const entries = previousValue.entries();
                    let iter;
                    while ((iter = entries.next()) && !iter.done) {
                        const [key, value] = iter.value;
                        // if value is a schema, remove its reference
                        if (typeof (value) === "object") {
                            previousRefId = $root.refIds.get(value);
                            $root.removeRef(previousRefId);
                        }
                        allChanges.push({
                            ref: previousValue,
                            refId: previousRefId,
                            op: exports.OPERATION.DELETE,
                            field: key,
                            value: undefined,
                            previousValue: value,
                        });
                    }
                }
            }
            $root.addRef(refId, value, (valueRef !== previousValue ||
                (operation === exports.OPERATION.DELETE_AND_ADD && valueRef === previousValue)));
        }
        return { value, previousValue };
    }
    const decodeSchemaOperation = function (decoder, bytes, it, ref, allChanges) {
        const first_byte = bytes[it.offset++];
        const metadata = ref.constructor[Symbol.metadata];
        // "compressed" index + operation
        const operation = (first_byte >> 6) << 6;
        const index = first_byte % (operation || 255);
        // skip early if field is not defined
        const field = metadata[index];
        if (field === undefined) {
            console.warn("@colyseus/schema: field not defined at", { index, ref: ref.constructor.name, metadata });
            return DEFINITION_MISMATCH;
        }
        const { value, previousValue } = decodeValue(decoder, operation, ref, index, field.type, bytes, it, allChanges);
        if (value !== null && value !== undefined) {
            ref[field.name] = value;
        }
        // add change
        if (previousValue !== value) {
            allChanges.push({
                ref,
                refId: decoder.currentRefId,
                op: operation,
                field: field.name,
                value,
                previousValue,
            });
        }
    };
    const decodeKeyValueOperation = function (decoder, bytes, it, ref, allChanges) {
        // "uncompressed" index + operation (array/map items)
        const operation = bytes[it.offset++];
        if (operation === exports.OPERATION.CLEAR) {
            //
            // When decoding:
            // - enqueue items for DELETE callback.
            // - flag child items for garbage collection.
            //
            decoder.removeChildRefs(ref, allChanges);
            ref.clear();
            return;
        }
        const index = decode.number(bytes, it);
        const type = ref[$childType];
        let dynamicIndex;
        if ((operation & exports.OPERATION.ADD) === exports.OPERATION.ADD) { // ADD or DELETE_AND_ADD
            if (typeof (ref['set']) === "function") {
                dynamicIndex = decode.string(bytes, it); // MapSchema
                ref['setIndex'](index, dynamicIndex);
            }
            else {
                dynamicIndex = index; // ArraySchema
            }
        }
        else {
            // get dynamic index from "ref"
            dynamicIndex = ref['getIndex'](index);
        }
        const { value, previousValue } = decodeValue(decoder, operation, ref, index, type, bytes, it, allChanges);
        if (value !== null && value !== undefined) {
            if (typeof (ref['set']) === "function") {
                // MapSchema
                ref['$items'].set(dynamicIndex, value);
            }
            else if (typeof (ref['$setAt']) === "function") {
                // ArraySchema
                ref['$setAt'](index, value, operation);
            }
            else if (typeof (ref['add']) === "function") {
                // CollectionSchema && SetSchema
                const index = ref.add(value);
                if (typeof (index) === "number") {
                    ref['setIndex'](index, index);
                }
            }
        }
        // add change
        if (previousValue !== value) {
            allChanges.push({
                ref,
                refId: decoder.currentRefId,
                op: operation,
                field: "", // FIXME: remove this
                dynamicIndex,
                value,
                previousValue,
            });
        }
    };
    const decodeArray = function (decoder, bytes, it, ref, allChanges) {
        // "uncompressed" index + operation (array/map items)
        let operation = bytes[it.offset++];
        let index;
        if (operation === exports.OPERATION.CLEAR) {
            //
            // When decoding:
            // - enqueue items for DELETE callback.
            // - flag child items for garbage collection.
            //
            decoder.removeChildRefs(ref, allChanges);
            ref.clear();
            return;
        }
        else if (operation === exports.OPERATION.REVERSE) {
            ref.reverse();
            return;
        }
        else if (operation === exports.OPERATION.DELETE_BY_REFID) {
            // TODO: refactor here, try to follow same flow as below
            const refId = decode.number(bytes, it);
            const previousValue = decoder.root.refs.get(refId);
            index = ref.findIndex((value) => value === previousValue);
            ref[$deleteByIndex](index);
            allChanges.push({
                ref,
                refId: decoder.currentRefId,
                op: exports.OPERATION.DELETE,
                field: "", // FIXME: remove this
                dynamicIndex: index,
                value: undefined,
                previousValue,
            });
            return;
        }
        else if (operation === exports.OPERATION.ADD_BY_REFID) {
            const refId = decode.number(bytes, it);
            const itemByRefId = decoder.root.refs.get(refId);
            // if item already exists, use existing index
            if (itemByRefId) {
                index = ref.findIndex((value) => value === itemByRefId);
            }
            // fallback to use last index
            if (index === -1 || index === undefined) {
                index = ref.length;
            }
        }
        else {
            index = decode.number(bytes, it);
        }
        const type = ref[$childType];
        let dynamicIndex = index;
        const { value, previousValue } = decodeValue(decoder, operation, ref, index, type, bytes, it, allChanges);
        if (value !== null && value !== undefined &&
            value !== previousValue // avoid setting same value twice (if index === 0 it will result in a "unshift" for ArraySchema)
        ) {
            // ArraySchema
            ref['$setAt'](index, value, operation);
        }
        // add change
        if (previousValue !== value) {
            allChanges.push({
                ref,
                refId: decoder.currentRefId,
                op: operation,
                field: "", // FIXME: remove this
                dynamicIndex,
                value,
                previousValue,
            });
        }
    };

    class EncodeSchemaError extends Error {
    }
    function assertType(value, type, klass, field) {
        let typeofTarget;
        let allowNull = false;
        switch (type) {
            case "number":
            case "int8":
            case "uint8":
            case "int16":
            case "uint16":
            case "int32":
            case "uint32":
            case "int64":
            case "uint64":
            case "float32":
            case "float64":
                typeofTarget = "number";
                if (isNaN(value)) {
                    console.log(`trying to encode "NaN" in ${klass.constructor.name}#${field}`);
                }
                break;
            case "bigint64":
            case "biguint64":
                typeofTarget = "bigint";
                break;
            case "string":
                typeofTarget = "string";
                allowNull = true;
                break;
            case "boolean":
                // boolean is always encoded as true/false based on truthiness
                return;
            default:
                // skip assertion for custom types
                // TODO: allow custom types to define their own assertions
                return;
        }
        if (typeof (value) !== typeofTarget && (!allowNull || (allowNull && value !== null))) {
            let foundValue = `'${JSON.stringify(value)}'${(value && value.constructor && ` (${value.constructor.name})`) || ''}`;
            throw new EncodeSchemaError(`a '${typeofTarget}' was expected, but ${foundValue} was provided in ${klass.constructor.name}#${field}`);
        }
    }
    function assertInstanceType(value, type, instance, field) {
        if (!(value instanceof type)) {
            throw new EncodeSchemaError(`a '${type.name}' was expected, but '${value && value.constructor.name}' was provided in ${instance.constructor.name}#${field}`);
        }
    }

    var _a$4, _b$4;
    const DEFAULT_SORT = (a, b) => {
        const A = a.toString();
        const B = b.toString();
        if (A < B)
            return -1;
        else if (A > B)
            return 1;
        else
            return 0;
    };
    class ArraySchema {
        static { this[_a$4] = encodeArray; }
        static { this[_b$4] = decodeArray; }
        /**
         * Determine if a property must be filtered.
         * - If returns false, the property is NOT going to be encoded.
         * - If returns true, the property is going to be encoded.
         *
         * Encoding with "filters" happens in two steps:
         * - First, the encoder iterates over all "not owned" properties and encodes them.
         * - Then, the encoder iterates over all "owned" properties per instance and encodes them.
         */
        static [(_a$4 = $encoder, _b$4 = $decoder, $filter)](ref, index, view) {
            return (!view ||
                typeof (ref[$childType]) === "string" ||
                view.isChangeTreeVisible(ref['tmpItems'][index]?.[$changes]));
        }
        static is(type) {
            return (
            // type format: ["string"]
            Array.isArray(type) ||
                // type format: { array: "string" }
                (type['array'] !== undefined));
        }
        static from(iterable) {
            return new ArraySchema(...Array.from(iterable));
        }
        constructor(...items) {
            this.items = [];
            this.tmpItems = [];
            this.deletedIndexes = {};
            this.isMovingItems = false;
            Object.defineProperty(this, $childType, {
                value: undefined,
                enumerable: false,
                writable: true,
                configurable: true,
            });
            const proxy = new Proxy(this, {
                get: (obj, prop) => {
                    if (typeof (prop) !== "symbol" &&
                        // FIXME: d8 accuses this as low performance
                        !isNaN(prop) // https://stackoverflow.com/a/175787/892698
                    ) {
                        return this.items[prop];
                    }
                    else {
                        return Reflect.get(obj, prop);
                    }
                },
                set: (obj, key, setValue) => {
                    if (typeof (key) !== "symbol" && !isNaN(key)) {
                        if (setValue === undefined || setValue === null) {
                            obj.$deleteAt(key);
                        }
                        else {
                            if (setValue[$changes]) {
                                assertInstanceType(setValue, obj[$childType], obj, key);
                                const previousValue = obj.items[key];
                                if (!obj.isMovingItems) {
                                    obj.$changeAt(Number(key), setValue);
                                }
                                else {
                                    if (previousValue !== undefined) {
                                        if (setValue[$changes].isNew) {
                                            obj[$changes].indexedOperation(Number(key), exports.OPERATION.MOVE_AND_ADD);
                                        }
                                        else {
                                            if ((obj[$changes].getChange(Number(key)) & exports.OPERATION.DELETE) === exports.OPERATION.DELETE) {
                                                obj[$changes].indexedOperation(Number(key), exports.OPERATION.DELETE_AND_MOVE);
                                            }
                                            else {
                                                obj[$changes].indexedOperation(Number(key), exports.OPERATION.MOVE);
                                            }
                                        }
                                    }
                                    else if (setValue[$changes].isNew) {
                                        obj[$changes].indexedOperation(Number(key), exports.OPERATION.ADD);
                                    }
                                    setValue[$changes].setParent(this, obj[$changes].root, key);
                                }
                                if (previousValue !== undefined) {
                                    // remove root reference from previous value
                                    previousValue[$changes].root?.remove(previousValue[$changes]);
                                }
                            }
                            else {
                                obj.$changeAt(Number(key), setValue);
                            }
                            obj.items[key] = setValue;
                            obj.tmpItems[key] = setValue;
                        }
                        return true;
                    }
                    else {
                        return Reflect.set(obj, key, setValue);
                    }
                },
                deleteProperty: (obj, prop) => {
                    if (typeof (prop) === "number") {
                        obj.$deleteAt(prop);
                    }
                    else {
                        delete obj[prop];
                    }
                    return true;
                },
                has: (obj, key) => {
                    if (typeof (key) !== "symbol" && !isNaN(Number(key))) {
                        return Reflect.has(this.items, key);
                    }
                    return Reflect.has(obj, key);
                }
            });
            this[$changes] = new ChangeTree(proxy);
            this[$changes].indexes = {};
            if (items.length > 0) {
                this.push(...items);
            }
            return proxy;
        }
        set length(newLength) {
            if (newLength === 0) {
                this.clear();
            }
            else if (newLength < this.items.length) {
                this.splice(newLength, this.length - newLength);
            }
            else {
                console.warn("ArraySchema: can't set .length to a higher value than its length.");
            }
        }
        get length() {
            return this.items.length;
        }
        push(...values) {
            let length = this.tmpItems.length;
            const changeTree = this[$changes];
            // values.forEach((value, i) => {
            for (let i = 0, l = values.length; i < values.length; i++, length++) {
                const value = values[i];
                if (value === undefined || value === null) {
                    // skip null values
                    return;
                }
                else if (typeof (value) === "object" && this[$childType]) {
                    assertInstanceType(value, this[$childType], this, i);
                    // TODO: move value[$changes]?.setParent() to this block.
                }
                changeTree.indexedOperation(length, exports.OPERATION.ADD, this.items.length);
                this.items.push(value);
                this.tmpItems.push(value);
                //
                // set value's parent after the value is set
                // (to avoid encoding "refId" operations before parent's "ADD" operation)
                //
                value[$changes]?.setParent(this, changeTree.root, length);
            }
            //     length++;
            // });
            return length;
        }
        /**
         * Removes the last element from an array and returns it.
         */
        pop() {
            let index = -1;
            // find last non-undefined index
            for (let i = this.tmpItems.length - 1; i >= 0; i--) {
                // if (this.tmpItems[i] !== undefined) {
                if (this.deletedIndexes[i] !== true) {
                    index = i;
                    break;
                }
            }
            if (index < 0) {
                return undefined;
            }
            this[$changes].delete(index, undefined, this.items.length - 1);
            this.deletedIndexes[index] = true;
            return this.items.pop();
        }
        at(index) {
            // Allow negative indexing from the end
            if (index < 0)
                index += this.length;
            return this.items[index];
        }
        // encoding only
        $changeAt(index, value) {
            if (value === undefined || value === null) {
                console.error("ArraySchema items cannot be null nor undefined; Use `deleteAt(index)` instead.");
                return;
            }
            // skip if the value is the same as cached.
            if (this.items[index] === value) {
                return;
            }
            const operation = (this.items[index] !== undefined)
                ? typeof (value) === "object"
                    ? exports.OPERATION.DELETE_AND_ADD // schema child
                    : exports.OPERATION.REPLACE // primitive
                : exports.OPERATION.ADD;
            const changeTree = this[$changes];
            changeTree.change(index, operation);
            //
            // set value's parent after the value is set
            // (to avoid encoding "refId" operations before parent's "ADD" operation)
            //
            value[$changes]?.setParent(this, changeTree.root, index);
        }
        // encoding only
        $deleteAt(index, operation) {
            this[$changes].delete(index, operation);
        }
        // decoding only
        $setAt(index, value, operation) {
            if (index === 0 &&
                operation === exports.OPERATION.ADD &&
                this.items[index] !== undefined) {
                // handle decoding unshift
                this.items.unshift(value);
            }
            else if (operation === exports.OPERATION.DELETE_AND_MOVE) {
                this.items.splice(index, 1);
                this.items[index] = value;
            }
            else {
                this.items[index] = value;
            }
        }
        clear() {
            // skip if already clear
            if (this.items.length === 0) {
                return;
            }
            // discard previous operations.
            const changeTree = this[$changes];
            // discard children
            changeTree.forEachChild((changeTree, _) => {
                changeTree.discard(true);
                //
                // TODO: add tests with instance sharing + .clear()
                // FIXME: this.root? is required because it is being called at decoding time.
                //
                // TODO: do not use [$changes] at decoding time.
                //
                const root = changeTree.root;
                if (root !== undefined) {
                    root.removeChangeFromChangeSet("changes", changeTree);
                    root.removeChangeFromChangeSet("allChanges", changeTree);
                    root.removeChangeFromChangeSet("allFilteredChanges", changeTree);
                }
            });
            changeTree.discard(true);
            changeTree.operation(exports.OPERATION.CLEAR);
            this.items.length = 0;
            this.tmpItems.length = 0;
        }
        /**
         * Combines two or more arrays.
         * @param items Additional items to add to the end of array1.
         */
        // @ts-ignore
        concat(...items) {
            return new ArraySchema(...this.items.concat(...items));
        }
        /**
         * Adds all the elements of an array separated by the specified separator string.
         * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.
         */
        join(separator) {
            return this.items.join(separator);
        }
        /**
         * Reverses the elements in an Array.
         */
        // @ts-ignore
        reverse() {
            this[$changes].operation(exports.OPERATION.REVERSE);
            this.items.reverse();
            this.tmpItems.reverse();
            return this;
        }
        /**
         * Removes the first element from an array and returns it.
         */
        shift() {
            if (this.items.length === 0) {
                return undefined;
            }
            // const index = Number(Object.keys(changeTree.indexes)[0]);
            const changeTree = this[$changes];
            const index = this.tmpItems.findIndex(item => item === this.items[0]);
            const allChangesIndex = this.items.findIndex(item => item === this.items[0]);
            changeTree.delete(index, exports.OPERATION.DELETE, allChangesIndex);
            changeTree.shiftAllChangeIndexes(-1, allChangesIndex);
            // this.deletedIndexes[index] = true;
            return this.items.shift();
        }
        /**
         * Returns a section of an array.
         * @param start The beginning of the specified portion of the array.
         * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.
         */
        slice(start, end) {
            const sliced = new ArraySchema();
            sliced.push(...this.items.slice(start, end));
            return sliced;
        }
        /**
         * Sorts an array.
         * @param compareFn Function used to determine the order of the elements. It is expected to return
         * a negative value if first argument is less than second argument, zero if they're equal and a positive
         * value otherwise. If omitted, the elements are sorted in ascending, ASCII character order.
         * ```ts
         * [11,2,22,1].sort((a, b) => a - b)
         * ```
         */
        sort(compareFn = DEFAULT_SORT) {
            this.isMovingItems = true;
            const changeTree = this[$changes];
            const sortedItems = this.items.sort(compareFn);
            // wouldn't OPERATION.MOVE make more sense here?
            sortedItems.forEach((_, i) => changeTree.change(i, exports.OPERATION.REPLACE));
            this.tmpItems.sort(compareFn);
            this.isMovingItems = false;
            return this;
        }
        /**
         * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.
         * @param start The zero-based location in the array from which to start removing elements.
         * @param deleteCount The number of elements to remove.
         * @param insertItems Elements to insert into the array in place of the deleted elements.
         */
        splice(start, deleteCount, ...insertItems) {
            const changeTree = this[$changes];
            const itemsLength = this.items.length;
            const tmpItemsLength = this.tmpItems.length;
            const insertCount = insertItems.length;
            // build up-to-date list of indexes, excluding removed values.
            const indexes = [];
            for (let i = 0; i < tmpItemsLength; i++) {
                if (this.deletedIndexes[i] !== true) {
                    indexes.push(i);
                }
            }
            if (itemsLength > start) {
                // if deleteCount is not provided, delete all items from start to end
                if (deleteCount === undefined) {
                    deleteCount = itemsLength - start;
                }
                //
                // delete operations at correct index
                //
                for (let i = start; i < start + deleteCount; i++) {
                    const index = indexes[i];
                    changeTree.delete(index, exports.OPERATION.DELETE);
                    this.deletedIndexes[index] = true;
                }
            }
            else {
                // not enough items to delete
                deleteCount = 0;
            }
            // insert operations
            if (insertCount > 0) {
                if (insertCount > deleteCount) {
                    console.error("Inserting more elements than deleting during ArraySchema#splice()");
                    throw new Error("ArraySchema#splice(): insertCount must be equal or lower than deleteCount.");
                }
                for (let i = 0; i < insertCount; i++) {
                    const addIndex = (indexes[start] ?? itemsLength) + i;
                    changeTree.indexedOperation(addIndex, (this.deletedIndexes[addIndex])
                        ? exports.OPERATION.DELETE_AND_ADD
                        : exports.OPERATION.ADD);
                    // set value's parent/root
                    insertItems[i][$changes]?.setParent(this, changeTree.root, addIndex);
                }
            }
            //
            // delete exceeding indexes from "allChanges"
            // (prevent .encodeAll() from encoding non-existing items)
            //
            if (deleteCount > insertCount) {
                changeTree.shiftAllChangeIndexes(-(deleteCount - insertCount), indexes[start + insertCount]);
                // debugChangeSet("AFTER SHIFT indexes", changeTree.allChanges);
            }
            //
            // FIXME: this code block is duplicated on ChangeTree
            //
            if (changeTree.filteredChanges !== undefined) {
                enqueueChangeTree(changeTree.root, changeTree, 'filteredChanges');
            }
            else {
                enqueueChangeTree(changeTree.root, changeTree, 'changes');
            }
            return this.items.splice(start, deleteCount, ...insertItems);
        }
        /**
         * Inserts new elements at the start of an array.
         * @param items  Elements to insert at the start of the Array.
         */
        unshift(...items) {
            const changeTree = this[$changes];
            // shift indexes
            changeTree.shiftChangeIndexes(items.length);
            // new index
            if (changeTree.isFiltered) {
                setOperationAtIndex(changeTree.filteredChanges, this.items.length);
                // changeTree.filteredChanges[this.items.length] = OPERATION.ADD;
            }
            else {
                setOperationAtIndex(changeTree.allChanges, this.items.length);
                // changeTree.allChanges[this.items.length] = OPERATION.ADD;
            }
            // FIXME: should we use OPERATION.MOVE here instead?
            items.forEach((_, index) => {
                changeTree.change(index, exports.OPERATION.ADD);
            });
            this.tmpItems.unshift(...items);
            return this.items.unshift(...items);
        }
        /**
         * Returns the index of the first occurrence of a value in an array.
         * @param searchElement The value to locate in the array.
         * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
         */
        indexOf(searchElement, fromIndex) {
            return this.items.indexOf(searchElement, fromIndex);
        }
        /**
         * Returns the index of the last occurrence of a specified value in an array.
         * @param searchElement The value to locate in the array.
         * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.
         */
        lastIndexOf(searchElement, fromIndex = this.length - 1) {
            return this.items.lastIndexOf(searchElement, fromIndex);
        }
        every(callbackfn, thisArg) {
            return this.items.every(callbackfn, thisArg);
        }
        /**
         * Determines whether the specified callback function returns true for any element of an array.
         * @param callbackfn A function that accepts up to three arguments. The some method calls
         * the callbackfn function for each element in the array until the callbackfn returns a value
         * which is coercible to the Boolean value true, or until the end of the array.
         * @param thisArg An object to which the this keyword can refer in the callbackfn function.
         * If thisArg is omitted, undefined is used as the this value.
         */
        some(callbackfn, thisArg) {
            return this.items.some(callbackfn, thisArg);
        }
        /**
         * Performs the specified action for each element in an array.
         * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
         * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
         */
        forEach(callbackfn, thisArg) {
            return this.items.forEach(callbackfn, thisArg);
        }
        /**
         * Calls a defined callback function on each element of an array, and returns an array that contains the results.
         * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
         * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
         */
        map(callbackfn, thisArg) {
            return this.items.map(callbackfn, thisArg);
        }
        filter(callbackfn, thisArg) {
            return this.items.filter(callbackfn, thisArg);
        }
        /**
         * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
         * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
         * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
         */
        reduce(callbackfn, initialValue) {
            return this.items.reduce(callbackfn, initialValue);
        }
        /**
         * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
         * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
         * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
         */
        reduceRight(callbackfn, initialValue) {
            return this.items.reduceRight(callbackfn, initialValue);
        }
        /**
         * Returns the value of the first element in the array where predicate is true, and undefined
         * otherwise.
         * @param predicate find calls predicate once for each element of the array, in ascending
         * order, until it finds one where predicate returns true. If such an element is found, find
         * immediately returns that element value. Otherwise, find returns undefined.
         * @param thisArg If provided, it will be used as the this value for each invocation of
         * predicate. If it is not provided, undefined is used instead.
         */
        find(predicate, thisArg) {
            return this.items.find(predicate, thisArg);
        }
        /**
         * Returns the index of the first element in the array where predicate is true, and -1
         * otherwise.
         * @param predicate find calls predicate once for each element of the array, in ascending
         * order, until it finds one where predicate returns true. If such an element is found,
         * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
         * @param thisArg If provided, it will be used as the this value for each invocation of
         * predicate. If it is not provided, undefined is used instead.
         */
        findIndex(predicate, thisArg) {
            return this.items.findIndex(predicate, thisArg);
        }
        /**
         * Returns the this object after filling the section identified by start and end with value
         * @param value value to fill array section with
         * @param start index to start filling the array at. If start is negative, it is treated as
         * length+start where length is the length of the array.
         * @param end index to stop filling the array at. If end is negative, it is treated as
         * length+end.
         */
        fill(value, start, end) {
            //
            // TODO
            //
            throw new Error("ArraySchema#fill() not implemented");
        }
        /**
         * Returns the this object after copying a section of the array identified by start and end
         * to the same array starting at position target
         * @param target If target is negative, it is treated as length+target where length is the
         * length of the array.
         * @param start If start is negative, it is treated as length+start. If end is negative, it
         * is treated as length+end.
         * @param end If not specified, length of the this object is used as its default value.
         */
        copyWithin(target, start, end) {
            //
            // TODO
            //
            throw new Error("ArraySchema#copyWithin() not implemented");
        }
        /**
         * Returns a string representation of an array.
         */
        toString() {
            return this.items.toString();
        }
        /**
         * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.
         */
        toLocaleString() {
            return this.items.toLocaleString();
        }
        ;
        /** Iterator */
        [Symbol.iterator]() {
            return this.items[Symbol.iterator]();
        }
        static get [Symbol.species]() {
            return ArraySchema;
        }
        /**
         * Returns an iterable of key, value pairs for every entry in the array
         */
        entries() { return this.items.entries(); }
        /**
         * Returns an iterable of keys in the array
         */
        keys() { return this.items.keys(); }
        /**
         * Returns an iterable of values in the array
         */
        values() { return this.items.values(); }
        /**
         * Determines whether an array includes a certain element, returning true or false as appropriate.
         * @param searchElement The element to search for.
         * @param fromIndex The position in this array at which to begin searching for searchElement.
         */
        includes(searchElement, fromIndex) {
            return this.items.includes(searchElement, fromIndex);
        }
        //
        // ES2022
        //
        /**
         * Calls a defined callback function on each element of an array. Then, flattens the result into
         * a new array.
         * This is identical to a map followed by flat with depth 1.
         *
         * @param callback A function that accepts up to three arguments. The flatMap method calls the
         * callback function one time for each element in the array.
         * @param thisArg An object to which the this keyword can refer in the callback function. If
         * thisArg is omitted, undefined is used as the this value.
         */
        // @ts-ignore
        flatMap(callback, thisArg) {
            // @ts-ignore
            throw new Error("ArraySchema#flatMap() is not supported.");
        }
        /**
         * Returns a new array with all sub-array elements concatenated into it recursively up to the
         * specified depth.
         *
         * @param depth The maximum recursion depth
         */
        // @ts-ignore
        flat(depth) {
            throw new Error("ArraySchema#flat() is not supported.");
        }
        findLast() {
            // @ts-ignore
            return this.items.findLast.apply(this.items, arguments);
        }
        findLastIndex(...args) {
            // @ts-ignore
            return this.items.findLastIndex.apply(this.items, arguments);
        }
        //
        // ES2023
        //
        with(index, value) {
            const copy = this.items.slice();
            // Allow negative indexing from the end
            if (index < 0)
                index += this.length;
            copy[index] = value;
            return new ArraySchema(...copy);
        }
        toReversed() {
            return this.items.slice().reverse();
        }
        toSorted(compareFn) {
            return this.items.slice().sort(compareFn);
        }
        // @ts-ignore
        toSpliced(start, deleteCount, ...items) {
            // @ts-ignore
            return this.items.toSpliced.apply(copy, arguments);
        }
        shuffle() {
            return this.move((_) => {
                let currentIndex = this.items.length;
                while (currentIndex != 0) {
                    let randomIndex = Math.floor(Math.random() * currentIndex);
                    currentIndex--;
                    [this[currentIndex], this[randomIndex]] = [this[randomIndex], this[currentIndex]];
                }
            });
        }
        /**
         * Allows to move items around in the array.
         *
         * Example:
         *     state.cards.move((cards) => {
         *         [cards[4], cards[3]] = [cards[3], cards[4]];
         *         [cards[3], cards[2]] = [cards[2], cards[3]];
         *         [cards[2], cards[0]] = [cards[0], cards[2]];
         *         [cards[1], cards[1]] = [cards[1], cards[1]];
         *         [cards[0], cards[0]] = [cards[0], cards[0]];
         *     })
         *
         * @param cb
         * @returns
         */
        move(cb) {
            this.isMovingItems = true;
            cb(this);
            this.isMovingItems = false;
            return this;
        }
        [($getByIndex)](index, isEncodeAll = false) {
            //
            // TODO: avoid unecessary `this.tmpItems` check during decoding.
            //
            //    ENCODING uses `this.tmpItems` (or `this.items` if `isEncodeAll` is true)
            //    DECODING uses `this.items`
            //
            return (isEncodeAll)
                ? this.items[index]
                : this.deletedIndexes[index]
                    ? this.items[index]
                    : this.tmpItems[index] || this.items[index];
        }
        [$deleteByIndex](index) {
            this.items[index] = undefined;
            this.tmpItems[index] = undefined; // TODO: do not try to get "tmpItems" at decoding time.
        }
        [$onEncodeEnd]() {
            this.tmpItems = this.items.slice();
            this.deletedIndexes = {};
        }
        [$onDecodeEnd]() {
            this.items = this.items.filter((item) => item !== undefined);
            this.tmpItems = this.items.slice(); // TODO: do no use "tmpItems" at decoding time.
        }
        toArray() {
            return this.items.slice(0);
        }
        toJSON() {
            return this.toArray().map((value) => {
                return (typeof (value['toJSON']) === "function")
                    ? value['toJSON']()
                    : value;
            });
        }
        //
        // Decoding utilities
        //
        clone(isDecoding) {
            let cloned;
            if (isDecoding) {
                cloned = new ArraySchema();
                cloned.push(...this.items);
            }
            else {
                cloned = new ArraySchema(...this.map(item => ((item[$changes])
                    ? item.clone()
                    : item)));
            }
            return cloned;
        }
        ;
    }
    registerType("array", { constructor: ArraySchema });

    var _a$3, _b$3;
    class MapSchema {
        static { this[_a$3] = encodeKeyValueOperation; }
        static { this[_b$3] = decodeKeyValueOperation; }
        /**
         * Determine if a property must be filtered.
         * - If returns false, the property is NOT going to be encoded.
         * - If returns true, the property is going to be encoded.
         *
         * Encoding with "filters" happens in two steps:
         * - First, the encoder iterates over all "not owned" properties and encodes them.
         * - Then, the encoder iterates over all "owned" properties per instance and encodes them.
         */
        static [(_a$3 = $encoder, _b$3 = $decoder, $filter)](ref, index, view) {
            return (!view ||
                typeof (ref[$childType]) === "string" ||
                view.isChangeTreeVisible((ref[$getByIndex](index) ?? ref.deletedItems[index])[$changes]));
        }
        static is(type) {
            return type['map'] !== undefined;
        }
        constructor(initialValues) {
            this.$items = new Map();
            this.$indexes = new Map();
            this.deletedItems = {};
            this[$changes] = new ChangeTree(this);
            this[$changes].indexes = {};
            if (initialValues) {
                if (initialValues instanceof Map ||
                    initialValues instanceof MapSchema) {
                    initialValues.forEach((v, k) => this.set(k, v));
                }
                else {
                    for (const k in initialValues) {
                        this.set(k, initialValues[k]);
                    }
                }
            }
            Object.defineProperty(this, $childType, {
                value: undefined,
                enumerable: false,
                writable: true,
                configurable: true,
            });
        }
        /** Iterator */
        [Symbol.iterator]() { return this.$items[Symbol.iterator](); }
        get [Symbol.toStringTag]() { return this.$items[Symbol.toStringTag]; }
        static get [Symbol.species]() { return MapSchema; }
        set(key, value) {
            if (value === undefined || value === null) {
                throw new Error(`MapSchema#set('${key}', ${value}): trying to set ${value} value on '${key}'.`);
            }
            else if (typeof (value) === "object" && this[$childType]) {
                assertInstanceType(value, this[$childType], this, key);
            }
            // Force "key" as string
            // See: https://github.com/colyseus/colyseus/issues/561#issuecomment-1646733468
            key = key.toString();
            const changeTree = this[$changes];
            const isRef = (value[$changes]) !== undefined;
            let index;
            let operation;
            // IS REPLACE?
            if (typeof (changeTree.indexes[key]) !== "undefined") {
                index = changeTree.indexes[key];
                operation = exports.OPERATION.REPLACE;
                const previousValue = this.$items.get(key);
                if (previousValue === value) {
                    // if value is the same, avoid re-encoding it.
                    return;
                }
                else if (isRef) {
                    // if is schema, force ADD operation if value differ from previous one.
                    operation = exports.OPERATION.DELETE_AND_ADD;
                    // remove reference from previous value
                    if (previousValue !== undefined) {
                        previousValue[$changes].root?.remove(previousValue[$changes]);
                    }
                }
            }
            else {
                index = changeTree.indexes[$numFields] ?? 0;
                operation = exports.OPERATION.ADD;
                this.$indexes.set(index, key);
                changeTree.indexes[key] = index;
                changeTree.indexes[$numFields] = index + 1;
            }
            this.$items.set(key, value);
            changeTree.change(index, operation);
            //
            // set value's parent after the value is set
            // (to avoid encoding "refId" operations before parent's "ADD" operation)
            //
            if (isRef) {
                value[$changes].setParent(this, changeTree.root, index);
            }
            return this;
        }
        get(key) {
            return this.$items.get(key);
        }
        delete(key) {
            const index = this[$changes].indexes[key];
            this.deletedItems[index] = this[$changes].delete(index);
            return this.$items.delete(key);
        }
        clear() {
            const changeTree = this[$changes];
            // discard previous operations.
            changeTree.discard(true);
            changeTree.indexes = {};
            // clear previous indexes
            this.$indexes.clear();
            // clear items
            this.$items.clear();
            changeTree.operation(exports.OPERATION.CLEAR);
        }
        has(key) {
            return this.$items.has(key);
        }
        forEach(callbackfn) {
            this.$items.forEach(callbackfn);
        }
        entries() {
            return this.$items.entries();
        }
        keys() {
            return this.$items.keys();
        }
        values() {
            return this.$items.values();
        }
        get size() {
            return this.$items.size;
        }
        setIndex(index, key) {
            this.$indexes.set(index, key);
        }
        getIndex(index) {
            return this.$indexes.get(index);
        }
        [$getByIndex](index) {
            return this.$items.get(this.$indexes.get(index));
        }
        [$deleteByIndex](index) {
            const key = this.$indexes.get(index);
            this.$items.delete(key);
            this.$indexes.delete(index);
        }
        [$onEncodeEnd]() {
            this.deletedItems = {};
        }
        toJSON() {
            const map = {};
            this.forEach((value, key) => {
                map[key] = (typeof (value['toJSON']) === "function")
                    ? value['toJSON']()
                    : value;
            });
            return map;
        }
        //
        // Decoding utilities
        //
        // @ts-ignore
        clone(isDecoding) {
            let cloned;
            if (isDecoding) {
                // client-side
                cloned = Object.assign(new MapSchema(), this);
            }
            else {
                // server-side
                cloned = new MapSchema();
                this.forEach((value, key) => {
                    if (value[$changes]) {
                        cloned.set(key, value['clone']());
                    }
                    else {
                        cloned.set(key, value);
                    }
                });
            }
            return cloned;
        }
    }
    registerType("map", { constructor: MapSchema });

    const DEFAULT_VIEW_TAG = -1;
    function entity(constructor) {
        TypeContext.register(constructor);
        return constructor;
    }
    /**
     * [See documentation](https://docs.colyseus.io/state/schema/)
     *
     * Annotate a Schema property to be serializeable.
     * \@type()'d fields are automatically flagged as "dirty" for the next patch.
     *
     * @example Standard usage, with automatic change tracking.
     * ```
     * \@type("string") propertyName: string;
     * ```
     *
     * @example You can provide the "manual" option if you'd like to manually control your patches via .setDirty().
     * ```
     * \@type("string", { manual: true })
     * ```
     */
    // export function type(type: DefinitionType, options?: TypeOptions) {
    //     return function ({ get, set }, context: ClassAccessorDecoratorContext): ClassAccessorDecoratorResult<Schema, any> {
    //         if (context.kind !== "accessor") {
    //             throw new Error("@type() is only supported for class accessor properties");
    //         }
    //         const field = context.name.toString();
    //         //
    //         // detect index for this field, considering inheritance
    //         //
    //         const parent = Object.getPrototypeOf(context.metadata);
    //         let fieldIndex: number = context.metadata[$numFields] // current structure already has fields defined
    //             ?? (parent && parent[$numFields]) // parent structure has fields defined
    //             ?? -1; // no fields defined
    //         fieldIndex++;
    //         if (
    //             !parent && // the parent already initializes the `$changes` property
    //             !Metadata.hasFields(context.metadata)
    //         ) {
    //             context.addInitializer(function (this: Ref) {
    //                 Object.defineProperty(this, $changes, {
    //                     value: new ChangeTree(this),
    //                     enumerable: false,
    //                     writable: true
    //                 });
    //             });
    //         }
    //         Metadata.addField(context.metadata, fieldIndex, field, type);
    //         const isArray = ArraySchema.is(type);
    //         const isMap = !isArray && MapSchema.is(type);
    //         // if (options && options.manual) {
    //         //     // do not declare getter/setter descriptor
    //         //     definition.descriptors[field] = {
    //         //         enumerable: true,
    //         //         configurable: true,
    //         //         writable: true,
    //         //     };
    //         //     return;
    //         // }
    //         return {
    //             init(value) {
    //                 // TODO: may need to convert ArraySchema/MapSchema here
    //                 // do not flag change if value is undefined.
    //                 if (value !== undefined) {
    //                     this[$changes].change(fieldIndex);
    //                     // automaticallty transform Array into ArraySchema
    //                     if (isArray) {
    //                         if (!(value instanceof ArraySchema)) {
    //                             value = new ArraySchema(...value);
    //                         }
    //                         value[$childType] = Object.values(type)[0];
    //                     }
    //                     // automaticallty transform Map into MapSchema
    //                     if (isMap) {
    //                         if (!(value instanceof MapSchema)) {
    //                             value = new MapSchema(value);
    //                         }
    //                         value[$childType] = Object.values(type)[0];
    //                     }
    //                     // try to turn provided structure into a Proxy
    //                     if (value['$proxy'] === undefined) {
    //                         if (isMap) {
    //                             value = getMapProxy(value);
    //                         }
    //                     }
    //                 }
    //                 return value;
    //             },
    //             get() {
    //                 return get.call(this);
    //             },
    //             set(value: any) {
    //                 /**
    //                  * Create Proxy for array or map items
    //                  */
    //                 // skip if value is the same as cached.
    //                 if (value === get.call(this)) {
    //                     return;
    //                 }
    //                 if (
    //                     value !== undefined &&
    //                     value !== null
    //                 ) {
    //                     // automaticallty transform Array into ArraySchema
    //                     if (isArray) {
    //                         if (!(value instanceof ArraySchema)) {
    //                             value = new ArraySchema(...value);
    //                         }
    //                         value[$childType] = Object.values(type)[0];
    //                     }
    //                     // automaticallty transform Map into MapSchema
    //                     if (isMap) {
    //                         if (!(value instanceof MapSchema)) {
    //                             value = new MapSchema(value);
    //                         }
    //                         value[$childType] = Object.values(type)[0];
    //                     }
    //                     // try to turn provided structure into a Proxy
    //                     if (value['$proxy'] === undefined) {
    //                         if (isMap) {
    //                             value = getMapProxy(value);
    //                         }
    //                     }
    //                     // flag the change for encoding.
    //                     this[$changes].change(fieldIndex);
    //                     //
    //                     // call setParent() recursively for this and its child
    //                     // structures.
    //                     //
    //                     if (value[$changes]) {
    //                         value[$changes].setParent(
    //                             this,
    //                             this[$changes].root,
    //                             Metadata.getIndex(context.metadata, field),
    //                         );
    //                     }
    //                 } else if (get.call(this)) {
    //                     //
    //                     // Setting a field to `null` or `undefined` will delete it.
    //                     //
    //                     this[$changes].delete(field);
    //                 }
    //                 set.call(this, value);
    //             },
    //         };
    //     }
    // }
    function view(tag = DEFAULT_VIEW_TAG) {
        return function (target, fieldName) {
            const constructor = target.constructor;
            const parentClass = Object.getPrototypeOf(constructor);
            const parentMetadata = parentClass[Symbol.metadata];
            // TODO: use Metadata.initialize()
            const metadata = (constructor[Symbol.metadata] ??= Object.assign({}, constructor[Symbol.metadata], parentMetadata ?? Object.create(null)));
            // const fieldIndex = metadata[fieldName];
            // if (!metadata[fieldIndex]) {
            //     //
            //     // detect index for this field, considering inheritance
            //     //
            //     metadata[fieldIndex] = {
            //         type: undefined,
            //         index: (metadata[$numFields] // current structure already has fields defined
            //             ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined
            //             ?? -1) + 1 // no fields defined
            //     }
            // }
            Metadata.setTag(metadata, fieldName, tag);
        };
    }
    function type(type, options) {
        return function (target, field) {
            const constructor = target.constructor;
            if (!type) {
                throw new Error(`${constructor.name}: @type() reference provided for "${field}" is undefined. Make sure you don't have any circular dependencies.`);
            }
            // for inheritance support
            TypeContext.register(constructor);
            const parentClass = Object.getPrototypeOf(constructor);
            const parentMetadata = parentClass[Symbol.metadata];
            const metadata = Metadata.initialize(constructor);
            let fieldIndex = metadata[field];
            /**
             * skip if descriptor already exists for this field (`@deprecated()`)
             */
            if (metadata[fieldIndex] !== undefined) {
                if (metadata[fieldIndex].deprecated) {
                    // do not create accessors for deprecated properties.
                    return;
                }
                else if (metadata[fieldIndex].type !== undefined) {
                    // trying to define same property multiple times across inheritance.
                    // https://github.com/colyseus/colyseus-unity3d/issues/131#issuecomment-814308572
                    try {
                        throw new Error(`@colyseus/schema: Duplicate '${field}' definition on '${constructor.name}'.\nCheck @type() annotation`);
                    }
                    catch (e) {
                        const definitionAtLine = e.stack.split("\n")[4].trim();
                        throw new Error(`${e.message} ${definitionAtLine}`);
                    }
                }
            }
            else {
                //
                // detect index for this field, considering inheritance
                //
                fieldIndex = metadata[$numFields] // current structure already has fields defined
                    ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined
                    ?? -1; // no fields defined
                fieldIndex++;
            }
            if (options && options.manual) {
                Metadata.addField(metadata, fieldIndex, field, type, {
                    // do not declare getter/setter descriptor
                    enumerable: true,
                    configurable: true,
                    writable: true,
                });
            }
            else {
                const complexTypeKlass = (Array.isArray(type))
                    ? getType("array")
                    : (typeof (Object.keys(type)[0]) === "string") && getType(Object.keys(type)[0]);
                const childType = (complexTypeKlass)
                    ? Object.values(type)[0]
                    : type;
                Metadata.addField(metadata, fieldIndex, field, type, getPropertyDescriptor(`_${field}`, fieldIndex, childType, complexTypeKlass));
            }
        };
    }
    function getPropertyDescriptor(fieldCached, fieldIndex, type, complexTypeKlass) {
        return {
            get: function () { return this[fieldCached]; },
            set: function (value) {
                const previousValue = this[fieldCached] ?? undefined;
                // skip if value is the same as cached.
                if (value === previousValue) {
                    return;
                }
                if (value !== undefined &&
                    value !== null) {
                    if (complexTypeKlass) {
                        // automaticallty transform Array into ArraySchema
                        if (complexTypeKlass.constructor === ArraySchema && !(value instanceof ArraySchema)) {
                            value = new ArraySchema(...value);
                        }
                        // automaticallty transform Map into MapSchema
                        if (complexTypeKlass.constructor === MapSchema && !(value instanceof MapSchema)) {
                            value = new MapSchema(value);
                        }
                        value[$childType] = type;
                    }
                    else if (typeof (type) !== "string") {
                        assertInstanceType(value, type, this, fieldCached.substring(1));
                    }
                    else {
                        assertType(value, type, this, fieldCached.substring(1));
                    }
                    const changeTree = this[$changes];
                    //
                    // Replacing existing "ref", remove it from root.
                    //
                    if (previousValue !== undefined && previousValue[$changes]) {
                        changeTree.root?.remove(previousValue[$changes]);
                        this.constructor[$track](changeTree, fieldIndex, exports.OPERATION.DELETE_AND_ADD);
                    }
                    else {
                        this.constructor[$track](changeTree, fieldIndex, exports.OPERATION.ADD);
                    }
                    //
                    // call setParent() recursively for this and its child
                    // structures.
                    //
                    value[$changes]?.setParent(this, changeTree.root, fieldIndex);
                }
                else if (previousValue !== undefined) {
                    //
                    // Setting a field to `null` or `undefined` will delete it.
                    //
                    this[$changes].delete(fieldIndex);
                }
                this[fieldCached] = value;
            },
            enumerable: true,
            configurable: true
        };
    }
    /**
     * `@deprecated()` flag a field as deprecated.
     * The previous `@type()` annotation should remain along with this one.
     */
    function deprecated(throws = true) {
        return function (klass, field) {
            //
            // FIXME: the following block of code is repeated across `@type()`, `@deprecated()` and `@unreliable()` decorators.
            //
            const constructor = klass.constructor;
            const parentClass = Object.getPrototypeOf(constructor);
            const parentMetadata = parentClass[Symbol.metadata];
            const metadata = (constructor[Symbol.metadata] ??= Object.assign({}, constructor[Symbol.metadata], parentMetadata ?? Object.create(null)));
            const fieldIndex = metadata[field];
            // if (!metadata[field]) {
            //     //
            //     // detect index for this field, considering inheritance
            //     //
            //     metadata[field] = {
            //         type: undefined,
            //         index: (metadata[$numFields] // current structure already has fields defined
            //             ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined
            //             ?? -1) + 1 // no fields defined
            //     }
            // }
            metadata[fieldIndex].deprecated = true;
            if (throws) {
                metadata[$descriptors] ??= {};
                metadata[$descriptors][field] = {
                    get: function () { throw new Error(`${field} is deprecated.`); },
                    set: function (value) { },
                    enumerable: false,
                    configurable: true
                };
            }
            // flag metadata[field] as non-enumerable
            Object.defineProperty(metadata, fieldIndex, {
                value: metadata[fieldIndex],
                enumerable: false,
                configurable: true
            });
        };
    }
    function defineTypes(target, fields, options) {
        for (let field in fields) {
            type(fields[field], options)(target.prototype, field);
        }
        return target;
    }
    function schema(fields, name, inherits = Schema) {
        const defaultValues = {};
        const viewTagFields = {};
        for (let fieldName in fields) {
            const field = fields[fieldName];
            if (typeof (field) === "object") {
                if (field['default'] !== undefined) {
                    defaultValues[fieldName] = field['default'];
                }
                if (field['view'] !== undefined) {
                    viewTagFields[fieldName] = (typeof (field['view']) === "boolean")
                        ? DEFAULT_VIEW_TAG
                        : field['view'];
                }
            }
        }
        const klass = Metadata.setFields(class extends inherits {
            constructor(...args) {
                args[0] = Object.assign({}, defaultValues, args[0]);
                super(...args);
            }
        }, fields);
        for (let fieldName in viewTagFields) {
            view(viewTagFields[fieldName])(klass.prototype, fieldName);
        }
        if (name) {
            Object.defineProperty(klass, "name", { value: name });
        }
        klass.extends = (fields, name) => schema(fields, name, klass);
        return klass;
    }

    function getIndent(level) {
        return (new Array(level).fill(0)).map((_, i) => (i === level - 1) ? ` ` : `   `).join("");
    }
    function dumpChanges(schema) {
        const $root = schema[$changes].root;
        const dump = {
            ops: {},
            refs: []
        };
        // for (const refId in $root.changes) {
        $root.changes.forEach(changeTree => {
            // skip if ChangeTree is undefined
            if (changeTree === undefined) {
                return;
            }
            const changes = changeTree.indexedOperations;
            dump.refs.push(`refId#${changeTree.refId}`);
            for (const index in changes) {
                const op = changes[index];
                const opName = exports.OPERATION[op];
                if (!dump.ops[opName]) {
                    dump.ops[opName] = 0;
                }
                dump.ops[exports.OPERATION[op]]++;
            }
        });
        return dump;
    }

    var _a$2, _b$2;
    /**
     * Schema encoder / decoder
     */
    class Schema {
        static { this[_a$2] = encodeSchemaOperation; }
        static { this[_b$2] = decodeSchemaOperation; }
        /**
         * Assign the property descriptors required to track changes on this instance.
         * @param instance
         */
        static initialize(instance) {
            Object.defineProperty(instance, $changes, {
                value: new ChangeTree(instance),
                enumerable: false,
                writable: true
            });
            Object.defineProperties(instance, instance.constructor[Symbol.metadata]?.[$descriptors] || {});
        }
        static is(type) {
            return typeof (type[Symbol.metadata]) === "object";
            // const metadata = type[Symbol.metadata];
            // return metadata && Object.prototype.hasOwnProperty.call(metadata, -1);
        }
        /**
         * Track property changes
         */
        static [(_a$2 = $encoder, _b$2 = $decoder, $track)](changeTree, index, operation = exports.OPERATION.ADD) {
            changeTree.change(index, operation);
        }
        /**
         * Determine if a property must be filtered.
         * - If returns false, the property is NOT going to be encoded.
         * - If returns true, the property is going to be encoded.
         *
         * Encoding with "filters" happens in two steps:
         * - First, the encoder iterates over all "not owned" properties and encodes them.
         * - Then, the encoder iterates over all "owned" properties per instance and encodes them.
         */
        static [$filter](ref, index, view) {
            const metadata = ref.constructor[Symbol.metadata];
            const tag = metadata[index]?.tag;
            if (view === undefined) {
                // shared pass/encode: encode if doesn't have a tag
                return tag === undefined;
            }
            else if (tag === undefined) {
                // view pass: no tag
                return true;
            }
            else if (tag === DEFAULT_VIEW_TAG) {
                // view pass: default tag
                return view.isChangeTreeVisible(ref[$changes]);
            }
            else {
                // view pass: custom tag
                const tags = view.tags?.get(ref[$changes]);
                return tags && tags.has(tag);
            }
        }
        // allow inherited classes to have a constructor
        constructor(...args) {
            //
            // inline
            // Schema.initialize(this);
            //
            Schema.initialize(this);
            //
            // Assign initial values
            //
            if (args[0]) {
                Object.assign(this, args[0]);
            }
        }
        assign(props) {
            Object.assign(this, props);
            return this;
        }
        /**
         * (Server-side): Flag a property to be encoded for the next patch.
         * @param instance Schema instance
         * @param property string representing the property name, or number representing the index of the property.
         * @param operation OPERATION to perform (detected automatically)
         */
        setDirty(property, operation) {
            const metadata = this.constructor[Symbol.metadata];
            this[$changes].change(metadata[metadata[property]].index, operation);
        }
        clone() {
            const cloned = new (this.constructor);
            const metadata = this.constructor[Symbol.metadata];
            //
            // TODO: clone all properties, not only annotated ones
            //
            // for (const field in this) {
            for (const fieldIndex in metadata) {
                // const field = metadata[metadata[fieldIndex]].name;
                const field = metadata[fieldIndex].name;
                if (typeof (this[field]) === "object" &&
                    typeof (this[field]?.clone) === "function") {
                    // deep clone
                    cloned[field] = this[field].clone();
                }
                else {
                    // primitive values
                    cloned[field] = this[field];
                }
            }
            return cloned;
        }
        toJSON() {
            const obj = {};
            const metadata = this.constructor[Symbol.metadata];
            for (const index in metadata) {
                const field = metadata[index];
                const fieldName = field.name;
                if (!field.deprecated && this[fieldName] !== null && typeof (this[fieldName]) !== "undefined") {
                    obj[fieldName] = (typeof (this[fieldName]['toJSON']) === "function")
                        ? this[fieldName]['toJSON']()
                        : this[fieldName];
                }
            }
            return obj;
        }
        discardAllChanges() {
            this[$changes].discardAll();
        }
        [$getByIndex](index) {
            const metadata = this.constructor[Symbol.metadata];
            return this[metadata[index].name];
        }
        [$deleteByIndex](index) {
            const metadata = this.constructor[Symbol.metadata];
            this[metadata[index].name] = undefined;
        }
        /**
         * Inspect the `refId` of all Schema instances in the tree. Optionally display the contents of the instance.
         *
         * @param ref Schema instance
         * @param showContents display JSON contents of the instance
         * @returns
         */
        static debugRefIds(ref, showContents = false, level = 0) {
            const contents = (showContents) ? ` - ${JSON.stringify(ref.toJSON())}` : "";
            const changeTree = ref[$changes];
            const refId = changeTree.refId;
            let output = "";
            output += `${getIndent(level)}${ref.constructor.name} (refId: ${refId})${contents}\n`;
            changeTree.forEachChild((childChangeTree) => output += this.debugRefIds(childChangeTree.ref, showContents, level + 1));
            return output;
        }
        /**
         * Return a string representation of the changes on a Schema instance.
         * The list of changes is cleared after each encode.
         *
         * @param instance Schema instance
         * @param isEncodeAll Return "full encode" instead of current change set.
         * @returns
         */
        static debugChanges(instance, isEncodeAll = false) {
            const changeTree = instance[$changes];
            const changeSet = (isEncodeAll) ? changeTree.allChanges : changeTree.changes;
            const changeSetName = (isEncodeAll) ? "allChanges" : "changes";
            let output = `${instance.constructor.name} (${changeTree.refId}) -> .${changeSetName}:\n`;
            function dumpChangeSet(changeSet) {
                changeSet.operations
                    .filter(op => op)
                    .forEach((index) => {
                    const operation = changeTree.indexedOperations[index];
                    console.log({ index, operation });
                    output += `- [${index}]: ${exports.OPERATION[operation]} (${JSON.stringify(changeTree.getValue(Number(index), isEncodeAll))})\n`;
                });
            }
            dumpChangeSet(changeSet);
            // display filtered changes
            if (!isEncodeAll &&
                changeTree.filteredChanges &&
                (changeTree.filteredChanges.operations).filter(op => op).length > 0) {
                output += `${instance.constructor.name} (${changeTree.refId}) -> .filteredChanges:\n`;
                dumpChangeSet(changeTree.filteredChanges);
            }
            // display filtered changes
            if (isEncodeAll &&
                changeTree.allFilteredChanges &&
                (changeTree.allFilteredChanges.operations).filter(op => op).length > 0) {
                output += `${instance.constructor.name} (${changeTree.refId}) -> .allFilteredChanges:\n`;
                dumpChangeSet(changeTree.allFilteredChanges);
            }
            return output;
        }
        static debugChangesDeep(ref, changeSetName = "changes") {
            let output = "";
            const rootChangeTree = ref[$changes];
            const root = rootChangeTree.root;
            const changeTrees = new Map();
            const instanceRefIds = [];
            let totalOperations = 0;
            for (const [refId, changes] of Object.entries(root[changeSetName])) {
                const changeTree = root.changeTrees[refId];
                let includeChangeTree = false;
                let parentChangeTrees = [];
                let parentChangeTree = changeTree.parent?.[$changes];
                if (changeTree === rootChangeTree) {
                    includeChangeTree = true;
                }
                else {
                    while (parentChangeTree !== undefined) {
                        parentChangeTrees.push(parentChangeTree);
                        if (parentChangeTree.ref === ref) {
                            includeChangeTree = true;
                            break;
                        }
                        parentChangeTree = parentChangeTree.parent?.[$changes];
                    }
                }
                if (includeChangeTree) {
                    instanceRefIds.push(changeTree.refId);
                    totalOperations += Object.keys(changes).length;
                    changeTrees.set(changeTree, parentChangeTrees.reverse());
                }
            }
            output += "---\n";
            output += `root refId: ${rootChangeTree.refId}\n`;
            output += `Total instances: ${instanceRefIds.length} (refIds: ${instanceRefIds.join(", ")})\n`;
            output += `Total changes: ${totalOperations}\n`;
            output += "---\n";
            // based on root.changes, display a tree of changes that has the "ref" instance as parent
            const visitedParents = new WeakSet();
            for (const [changeTree, parentChangeTrees] of changeTrees.entries()) {
                parentChangeTrees.forEach((parentChangeTree, level) => {
                    if (!visitedParents.has(parentChangeTree)) {
                        output += `${getIndent(level)}${parentChangeTree.ref.constructor.name} (refId: ${parentChangeTree.refId})\n`;
                        visitedParents.add(parentChangeTree);
                    }
                });
                const changes = changeTree.indexedOperations;
                const level = parentChangeTrees.length;
                const indent = getIndent(level);
                const parentIndex = (level > 0) ? `(${changeTree.parentIndex}) ` : "";
                output += `${indent}${parentIndex}${changeTree.ref.constructor.name} (refId: ${changeTree.refId}) - changes: ${Object.keys(changes).length}\n`;
                for (const index in changes) {
                    const operation = changes[index];
                    output += `${getIndent(level + 1)}${exports.OPERATION[operation]}: ${index}\n`;
                }
            }
            return `${output}`;
        }
    }

    var _a$1, _b$1;
    class CollectionSchema {
        static { this[_a$1] = encodeKeyValueOperation; }
        static { this[_b$1] = decodeKeyValueOperation; }
        /**
         * Determine if a property must be filtered.
         * - If returns false, the property is NOT going to be encoded.
         * - If returns true, the property is going to be encoded.
         *
         * Encoding with "filters" happens in two steps:
         * - First, the encoder iterates over all "not owned" properties and encodes them.
         * - Then, the encoder iterates over all "owned" properties per instance and encodes them.
         */
        static [(_a$1 = $encoder, _b$1 = $decoder, $filter)](ref, index, view) {
            return (!view ||
                typeof (ref[$childType]) === "string" ||
                view.isChangeTreeVisible((ref[$getByIndex](index) ?? ref.deletedItems[index])[$changes]));
        }
        static is(type) {
            return type['collection'] !== undefined;
        }
        constructor(initialValues) {
            this.$items = new Map();
            this.$indexes = new Map();
            this.deletedItems = {};
            this.$refId = 0;
            this[$changes] = new ChangeTree(this);
            this[$changes].indexes = {};
            if (initialValues) {
                initialValues.forEach((v) => this.add(v));
            }
            Object.defineProperty(this, $childType, {
                value: undefined,
                enumerable: false,
                writable: true,
                configurable: true,
            });
        }
        add(value) {
            // set "index" for reference.
            const index = this.$refId++;
            const isRef = (value[$changes]) !== undefined;
            if (isRef) {
                value[$changes].setParent(this, this[$changes].root, index);
            }
            this[$changes].indexes[index] = index;
            this.$indexes.set(index, index);
            this.$items.set(index, value);
            this[$changes].change(index);
            return index;
        }
        at(index) {
            const key = Array.from(this.$items.keys())[index];
            return this.$items.get(key);
        }
        entries() {
            return this.$items.entries();
        }
        delete(item) {
            const entries = this.$items.entries();
            let index;
            let entry;
            while (entry = entries.next()) {
                if (entry.done) {
                    break;
                }
                if (item === entry.value[1]) {
                    index = entry.value[0];
                    break;
                }
            }
            if (index === undefined) {
                return false;
            }
            this.deletedItems[index] = this[$changes].delete(index);
            this.$indexes.delete(index);
            return this.$items.delete(index);
        }
        clear() {
            const changeTree = this[$changes];
            // discard previous operations.
            changeTree.discard(true);
            changeTree.indexes = {};
            // clear previous indexes
            this.$indexes.clear();
            // clear items
            this.$items.clear();
            changeTree.operation(exports.OPERATION.CLEAR);
        }
        has(value) {
            return Array.from(this.$items.values()).some((v) => v === value);
        }
        forEach(callbackfn) {
            this.$items.forEach((value, key, _) => callbackfn(value, key, this));
        }
        values() {
            return this.$items.values();
        }
        get size() {
            return this.$items.size;
        }
        /** Iterator */
        [Symbol.iterator]() {
            return this.$items.values();
        }
        setIndex(index, key) {
            this.$indexes.set(index, key);
        }
        getIndex(index) {
            return this.$indexes.get(index);
        }
        [$getByIndex](index) {
            return this.$items.get(this.$indexes.get(index));
        }
        [$deleteByIndex](index) {
            const key = this.$indexes.get(index);
            this.$items.delete(key);
            this.$indexes.delete(index);
        }
        [$onEncodeEnd]() {
            this.deletedItems = {};
        }
        toArray() {
            return Array.from(this.$items.values());
        }
        toJSON() {
            const values = [];
            this.forEach((value, key) => {
                values.push((typeof (value['toJSON']) === "function")
                    ? value['toJSON']()
                    : value);
            });
            return values;
        }
        //
        // Decoding utilities
        //
        clone(isDecoding) {
            let cloned;
            if (isDecoding) {
                // client-side
                cloned = Object.assign(new CollectionSchema(), this);
            }
            else {
                // server-side
                cloned = new CollectionSchema();
                this.forEach((value) => {
                    if (value[$changes]) {
                        cloned.add(value['clone']());
                    }
                    else {
                        cloned.add(value);
                    }
                });
            }
            return cloned;
        }
    }
    registerType("collection", { constructor: CollectionSchema, });

    var _a, _b;
    class SetSchema {
        static { this[_a] = encodeKeyValueOperation; }
        static { this[_b] = decodeKeyValueOperation; }
        /**
         * Determine if a property must be filtered.
         * - If returns false, the property is NOT going to be encoded.
         * - If returns true, the property is going to be encoded.
         *
         * Encoding with "filters" happens in two steps:
         * - First, the encoder iterates over all "not owned" properties and encodes them.
         * - Then, the encoder iterates over all "owned" properties per instance and encodes them.
         */
        static [(_a = $encoder, _b = $decoder, $filter)](ref, index, view) {
            return (!view ||
                typeof (ref[$childType]) === "string" ||
                view.visible.has((ref[$getByIndex](index) ?? ref.deletedItems[index])[$changes]));
        }
        static is(type) {
            return type['set'] !== undefined;
        }
        constructor(initialValues) {
            this.$items = new Map();
            this.$indexes = new Map();
            this.deletedItems = {};
            this.$refId = 0;
            this[$changes] = new ChangeTree(this);
            this[$changes].indexes = {};
            if (initialValues) {
                initialValues.forEach((v) => this.add(v));
            }
            Object.defineProperty(this, $childType, {
                value: undefined,
                enumerable: false,
                writable: true,
                configurable: true,
            });
        }
        add(value) {
            // immediatelly return false if value already added.
            if (this.has(value)) {
                return false;
            }
            // set "index" for reference.
            const index = this.$refId++;
            if ((value[$changes]) !== undefined) {
                value[$changes].setParent(this, this[$changes].root, index);
            }
            const operation = this[$changes].indexes[index]?.op ?? exports.OPERATION.ADD;
            this[$changes].indexes[index] = index;
            this.$indexes.set(index, index);
            this.$items.set(index, value);
            this[$changes].change(index, operation);
            return index;
        }
        entries() {
            return this.$items.entries();
        }
        delete(item) {
            const entries = this.$items.entries();
            let index;
            let entry;
            while (entry = entries.next()) {
                if (entry.done) {
                    break;
                }
                if (item === entry.value[1]) {
                    index = entry.value[0];
                    break;
                }
            }
            if (index === undefined) {
                return false;
            }
            this.deletedItems[index] = this[$changes].delete(index);
            this.$indexes.delete(index);
            return this.$items.delete(index);
        }
        clear() {
            const changeTree = this[$changes];
            // discard previous operations.
            changeTree.discard(true);
            changeTree.indexes = {};
            // clear previous indexes
            this.$indexes.clear();
            // clear items
            this.$items.clear();
            changeTree.operation(exports.OPERATION.CLEAR);
        }
        has(value) {
            const values = this.$items.values();
            let has = false;
            let entry;
            while (entry = values.next()) {
                if (entry.done) {
                    break;
                }
                if (value === entry.value) {
                    has = true;
                    break;
                }
            }
            return has;
        }
        forEach(callbackfn) {
            this.$items.forEach((value, key, _) => callbackfn(value, key, this));
        }
        values() {
            return this.$items.values();
        }
        get size() {
            return this.$items.size;
        }
        /** Iterator */
        [Symbol.iterator]() {
            return this.$items.values();
        }
        setIndex(index, key) {
            this.$indexes.set(index, key);
        }
        getIndex(index) {
            return this.$indexes.get(index);
        }
        [$getByIndex](index) {
            return this.$items.get(this.$indexes.get(index));
        }
        [$deleteByIndex](index) {
            const key = this.$indexes.get(index);
            this.$items.delete(key);
            this.$indexes.delete(index);
        }
        [$onEncodeEnd]() {
            this.deletedItems = {};
        }
        toArray() {
            return Array.from(this.$items.values());
        }
        toJSON() {
            const values = [];
            this.forEach((value, key) => {
                values.push((typeof (value['toJSON']) === "function")
                    ? value['toJSON']()
                    : value);
            });
            return values;
        }
        //
        // Decoding utilities
        //
        clone(isDecoding) {
            let cloned;
            if (isDecoding) {
                // client-side
                cloned = Object.assign(new SetSchema(), this);
            }
            else {
                // server-side
                cloned = new SetSchema();
                this.forEach((value) => {
                    if (value[$changes]) {
                        cloned.add(value['clone']());
                    }
                    else {
                        cloned.add(value);
                    }
                });
            }
            return cloned;
        }
    }
    registerType("set", { constructor: SetSchema });

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise, SuppressedError, Symbol, Iterator */


    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;

    };

    class Root {
        constructor(types) {
            this.types = types;
            this.nextUniqueId = 0;
            this.refCount = {};
            this.changeTrees = {};
            // all changes
            this.allChanges = [];
            this.allFilteredChanges = []; // TODO: do not initialize it if filters are not used
            // pending changes to be encoded
            this.changes = [];
            this.filteredChanges = []; // TODO: do not initialize it if filters are not used
        }
        getNextUniqueId() {
            return this.nextUniqueId++;
        }
        add(changeTree) {
            // FIXME: move implementation of `ensureRefId` to `Root` class
            changeTree.ensureRefId();
            const isNewChangeTree = (this.changeTrees[changeTree.refId] === undefined);
            if (isNewChangeTree) {
                this.changeTrees[changeTree.refId] = changeTree;
            }
            const previousRefCount = this.refCount[changeTree.refId];
            if (previousRefCount === 0) {
                //
                // When a ChangeTree is re-added, it means that it was previously removed.
                // We need to re-add all changes to the `changes` map.
                //
                const ops = changeTree.allChanges.operations;
                let len = ops.length;
                while (len--) {
                    changeTree.indexedOperations[ops[len]] = exports.OPERATION.ADD;
                    setOperationAtIndex(changeTree.changes, len);
                }
            }
            this.refCount[changeTree.refId] = (previousRefCount || 0) + 1;
            return isNewChangeTree;
        }
        remove(changeTree) {
            const refCount = (this.refCount[changeTree.refId]) - 1;
            if (refCount <= 0) {
                //
                // Only remove "root" reference if it's the last reference
                //
                changeTree.root = undefined;
                delete this.changeTrees[changeTree.refId];
                this.removeChangeFromChangeSet("allChanges", changeTree);
                this.removeChangeFromChangeSet("changes", changeTree);
                if (changeTree.filteredChanges) {
                    this.removeChangeFromChangeSet("allFilteredChanges", changeTree);
                    this.removeChangeFromChangeSet("filteredChanges", changeTree);
                }
                this.refCount[changeTree.refId] = 0;
            }
            else {
                this.refCount[changeTree.refId] = refCount;
                //
                // When losing a reference to an instance, it is best to move the
                // ChangeTree to the end of the encoding queue.
                //
                // This way, at decoding time, the instance that contains the
                // ChangeTree will be available before the ChangeTree itself. If the
                // containing instance is not available, the Decoder will throw
                // "refId not found" error.
                //
                if (changeTree.filteredChanges !== undefined) {
                    this.removeChangeFromChangeSet("filteredChanges", changeTree);
                    enqueueChangeTree(this, changeTree, "filteredChanges");
                }
                else {
                    this.removeChangeFromChangeSet("changes", changeTree);
                    enqueueChangeTree(this, changeTree, "changes");
                }
            }
            changeTree.forEachChild((child, _) => this.remove(child));
            return refCount;
        }
        removeChangeFromChangeSet(changeSetName, changeTree) {
            const changeSet = this[changeSetName];
            const changeSetIndex = changeSet.indexOf(changeTree);
            if (changeSetIndex !== -1) {
                changeTree[changeSetName].queueRootIndex = -1;
                changeSet[changeSetIndex] = undefined;
                return true;
            }
            // if (spliceOne(changeSet, changeSet.indexOf(changeTree))) {
            //     changeTree[changeSetName].queueRootIndex = -1;
            //     return true;
            // }
        }
        clear() {
            this.changes.length = 0;
        }
    }

    class Encoder {
        static { this.BUFFER_SIZE = (typeof (Buffer) !== "undefined") && Buffer.poolSize || 8 * 1024; } // 8KB
        constructor(state) {
            this.sharedBuffer = Buffer.allocUnsafe(Encoder.BUFFER_SIZE);
            //
            // Use .cache() here to avoid re-creating a new context for every new room instance.
            //
            // We may need to make this optional in case of dynamically created
            // schemas - which would lead to memory leaks
            //
            this.context = TypeContext.cache(state.constructor);
            this.root = new Root(this.context);
            this.setState(state);
            // console.log(">>>>>>>>>>>>>>>> Encoder types");
            // this.context.schemas.forEach((id, schema) => {
            //     console.log("type:", id, schema.name, Object.keys(schema[Symbol.metadata]));
            // });
        }
        setState(state) {
            this.state = state;
            this.state[$changes].setRoot(this.root);
        }
        encode(it = { offset: 0 }, view, buffer = this.sharedBuffer, changeSetName = "changes", isEncodeAll = changeSetName === "allChanges", initialOffset = it.offset // cache current offset in case we need to resize the buffer
        ) {
            const hasView = (view !== undefined);
            const rootChangeTree = this.state[$changes];
            const changeTrees = this.root[changeSetName];
            for (let i = 0, numChangeTrees = changeTrees.length; i < numChangeTrees; i++) {
                const changeTree = changeTrees[i];
                if (!changeTree) {
                    continue;
                }
                if (hasView) {
                    if (!view.isChangeTreeVisible(changeTree)) {
                        // console.log("MARK AS INVISIBLE:", { ref: changeTree.ref.constructor.name, refId: changeTree.refId, raw: changeTree.ref.toJSON() });
                        view.invisible.add(changeTree);
                        continue; // skip this change tree
                    }
                    view.invisible.delete(changeTree); // remove from invisible list
                }
                const changeSet = changeTree[changeSetName];
                const ref = changeTree.ref;
                // TODO: avoid iterating over change tree if no changes were made
                const numChanges = changeSet.operations.length;
                if (numChanges === 0) {
                    continue;
                }
                const ctor = ref.constructor;
                const encoder = ctor[$encoder];
                const filter = ctor[$filter];
                const metadata = ctor[Symbol.metadata];
                // skip root `refId` if it's the first change tree
                // (unless it "hasView", which will need to revisit the root)
                if (hasView || it.offset > initialOffset || changeTree !== rootChangeTree) {
                    buffer[it.offset++] = SWITCH_TO_STRUCTURE & 255;
                    encode.number(buffer, changeTree.refId, it);
                }
                for (let j = 0; j < numChanges; j++) {
                    const fieldIndex = changeSet.operations[j];
                    const operation = (fieldIndex < 0)
                        ? Math.abs(fieldIndex) // "pure" operation without fieldIndex (e.g. CLEAR, REVERSE, etc.)
                        : (isEncodeAll)
                            ? exports.OPERATION.ADD
                            : changeTree.indexedOperations[fieldIndex];
                    //
                    // first pass (encodeAll), identify "filtered" operations without encoding them
                    // they will be encoded per client, based on their view.
                    //
                    // TODO: how can we optimize filtering out "encode all" operations?
                    // TODO: avoid checking if no view tags were defined
                    //
                    if (fieldIndex === undefined || operation === undefined || (filter && !filter(ref, fieldIndex, view))) {
                        // console.log("ADD AS INVISIBLE:", fieldIndex, changeTree.ref.constructor.name)
                        // view?.invisible.add(changeTree);
                        continue;
                    }
                    encoder(this, buffer, changeTree, fieldIndex, operation, it, isEncodeAll, hasView, metadata);
                }
            }
            if (it.offset > buffer.byteLength) {
                // we can assume that n + 1 poolSize will suffice given that we are likely done with encoding at this point
                // multiples of poolSize are faster to allocate than arbitrary sizes
                // if we are on an older platform that doesn't implement pooling use 8kb as poolSize (that's the default for node)
                const newSize = Math.ceil(it.offset / (Buffer.poolSize ?? 8 * 1024)) * (Buffer.poolSize ?? 8 * 1024);
                console.warn(`@colyseus/schema buffer overflow. Encoded state is higher than default BUFFER_SIZE. Use the following to increase default BUFFER_SIZE:

    import { Encoder } from "@colyseus/schema";
    Encoder.BUFFER_SIZE = ${Math.round(newSize / 1024)} * 1024; // ${Math.round(newSize / 1024)} KB
`);
                //
                // resize buffer and re-encode (TODO: can we avoid re-encoding here?)
                // -> No we probably can't unless we catch the need for resize before encoding which is likely more computationally expensive than resizing on demand
                //
                buffer = Buffer.alloc(newSize, buffer); // fill with buffer here to memcpy previous encoding steps beyond the initialOffset
                // assign resized buffer to local sharedBuffer
                if (buffer === this.sharedBuffer) {
                    this.sharedBuffer = buffer;
                }
                return this.encode({ offset: initialOffset }, view, buffer, changeSetName, isEncodeAll);
            }
            else {
                return buffer.subarray(0, it.offset);
            }
        }
        encodeAll(it = { offset: 0 }, buffer = this.sharedBuffer) {
            return this.encode(it, undefined, buffer, "allChanges", true);
        }
        encodeAllView(view, sharedOffset, it, bytes = this.sharedBuffer) {
            const viewOffset = it.offset;
            // try to encode "filtered" changes
            this.encode(it, view, bytes, "allFilteredChanges", true, viewOffset);
            return Buffer.concat([
                bytes.subarray(0, sharedOffset),
                bytes.subarray(viewOffset, it.offset)
            ]);
        }
        debugChanges(field) {
            const rootChangeSet = (typeof (field) === "string")
                ? this.root[field]
                : field;
            rootChangeSet.forEach((changeTree) => {
                const changeSet = changeTree[field];
                const metadata = changeTree.ref.constructor[Symbol.metadata];
                console.log("->", { ref: changeTree.ref.constructor.name, refId: changeTree.refId, changes: Object.keys(changeSet).length });
                for (const index in changeSet) {
                    const op = changeSet[index];
                    console.log("  ->", {
                        index,
                        field: metadata?.[index],
                        op: exports.OPERATION[op],
                    });
                }
            });
        }
        encodeView(view, sharedOffset, it, bytes = this.sharedBuffer) {
            const viewOffset = it.offset;
            // encode visibility changes (add/remove for this view)
            for (const [refId, changes] of view.changes) {
                const changeTree = this.root.changeTrees[refId];
                if (changeTree === undefined) {
                    // detached instance, remove from view and skip.
                    // console.log("detached instance, remove from view and skip.", refId);
                    view.changes.delete(refId);
                    continue;
                }
                const keys = Object.keys(changes);
                if (keys.length === 0) {
                    // FIXME: avoid having empty changes if no changes were made
                    // console.log("changes.size === 0, skip", refId, changeTree.ref.constructor.name);
                    continue;
                }
                const ref = changeTree.ref;
                const ctor = ref.constructor;
                const encoder = ctor[$encoder];
                const metadata = ctor[Symbol.metadata];
                bytes[it.offset++] = SWITCH_TO_STRUCTURE & 255;
                encode.number(bytes, changeTree.refId, it);
                for (let i = 0, numChanges = keys.length; i < numChanges; i++) {
                    const index = Number(keys[i]);
                    // workaround when using view.add() on item that has been deleted from state (see test "adding to view item that has been removed from state")
                    const value = changeTree.ref[$getByIndex](index);
                    const operation = (value !== undefined && changes[index]) || exports.OPERATION.DELETE;
                    // isEncodeAll = false
                    // hasView = true
                    encoder(this, bytes, changeTree, index, operation, it, false, true, metadata);
                }
            }
            //
            // TODO: only clear view changes after all views are encoded
            // (to allow re-using StateView's for multiple clients)
            //
            // clear "view" changes after encoding
            view.changes.clear();
            // try to encode "filtered" changes
            this.encode(it, view, bytes, "filteredChanges", false, viewOffset);
            return Buffer.concat([
                bytes.subarray(0, sharedOffset),
                bytes.subarray(viewOffset, it.offset)
            ]);
        }
        discardChanges() {
            // discard shared changes
            let length = this.root.changes.length;
            if (length > 0) {
                while (length--) {
                    this.root.changes[length]?.endEncode('changes');
                }
                this.root.changes.length = 0;
            }
            // discard filtered changes
            length = this.root.filteredChanges.length;
            if (length > 0) {
                while (length--) {
                    this.root.filteredChanges[length]?.endEncode('filteredChanges');
                }
                this.root.filteredChanges.length = 0;
            }
        }
        tryEncodeTypeId(bytes, baseType, targetType, it) {
            const baseTypeId = this.context.getTypeId(baseType);
            const targetTypeId = this.context.getTypeId(targetType);
            if (targetTypeId === undefined) {
                console.warn(`@colyseus/schema WARNING: Class "${targetType.name}" is not registered on TypeRegistry - Please either tag the class with @entity or define a @type() field.`);
                return;
            }
            if (baseTypeId !== targetTypeId) {
                bytes[it.offset++] = TYPE_ID & 255;
                encode.number(bytes, targetTypeId, it);
            }
        }
        get hasChanges() {
            return (this.root.changes.length > 0 ||
                this.root.filteredChanges.length > 0);
        }
    }

    function spliceOne(arr, index) {
        // manually splice an array
        if (index === -1 || index >= arr.length) {
            return false;
        }
        const len = arr.length - 1;
        for (let i = index; i < len; i++) {
            arr[i] = arr[i + 1];
        }
        arr.length = len;
        return true;
    }

    class DecodingWarning extends Error {
        constructor(message) {
            super(message);
            this.name = "DecodingWarning";
        }
    }
    class ReferenceTracker {
        constructor() {
            //
            // Relation of refId => Schema structure
            // For direct access of structures during decoding time.
            //
            this.refs = new Map();
            this.refIds = new WeakMap();
            this.refCounts = {};
            this.deletedRefs = new Set();
            this.callbacks = {};
            this.nextUniqueId = 0;
        }
        getNextUniqueId() {
            return this.nextUniqueId++;
        }
        // for decoding
        addRef(refId, ref, incrementCount = true) {
            this.refs.set(refId, ref);
            this.refIds.set(ref, refId);
            if (incrementCount) {
                this.refCounts[refId] = (this.refCounts[refId] || 0) + 1;
            }
            if (this.deletedRefs.has(refId)) {
                this.deletedRefs.delete(refId);
            }
        }
        // for decoding
        removeRef(refId) {
            const refCount = this.refCounts[refId];
            if (refCount === undefined) {
                try {
                    throw new DecodingWarning("trying to remove refId that doesn't exist: " + refId);
                }
                catch (e) {
                    console.warn(e);
                }
                return;
            }
            if (refCount === 0) {
                try {
                    const ref = this.refs.get(refId);
                    throw new DecodingWarning(`trying to remove refId '${refId}' with 0 refCount (${ref.constructor.name}: ${JSON.stringify(ref)})`);
                }
                catch (e) {
                    console.warn(e);
                }
                return;
            }
            if ((this.refCounts[refId] = refCount - 1) <= 0) {
                this.deletedRefs.add(refId);
            }
        }
        clearRefs() {
            this.refs.clear();
            this.deletedRefs.clear();
            this.callbacks = {};
            this.refCounts = {};
        }
        // for decoding
        garbageCollectDeletedRefs() {
            this.deletedRefs.forEach((refId) => {
                //
                // Skip active references.
                //
                if (this.refCounts[refId] > 0) {
                    return;
                }
                const ref = this.refs.get(refId);
                //
                // Ensure child schema instances have their references removed as well.
                //
                if (ref.constructor[Symbol.metadata] !== undefined) {
                    const metadata = ref.constructor[Symbol.metadata];
                    for (const index in metadata) {
                        const field = metadata[index].name;
                        const childRefId = typeof (ref[field]) === "object" && this.refIds.get(ref[field]);
                        if (childRefId && !this.deletedRefs.has(childRefId)) {
                            this.removeRef(childRefId);
                        }
                    }
                }
                else {
                    if (typeof (ref[$childType]) === "function") {
                        Array.from(ref.values())
                            .forEach((child) => {
                            const childRefId = this.refIds.get(child);
                            if (!this.deletedRefs.has(childRefId)) {
                                this.removeRef(childRefId);
                            }
                        });
                    }
                }
                this.refs.delete(refId); // remove ref
                delete this.refCounts[refId]; // remove ref count
                delete this.callbacks[refId]; // remove callbacks
            });
            // clear deleted refs.
            this.deletedRefs.clear();
        }
        addCallback(refId, fieldOrOperation, callback) {
            if (refId === undefined) {
                const name = (typeof (fieldOrOperation) === "number")
                    ? exports.OPERATION[fieldOrOperation]
                    : fieldOrOperation;
                throw new Error(`Can't addCallback on '${name}' (refId is undefined)`);
            }
            if (!this.callbacks[refId]) {
                this.callbacks[refId] = {};
            }
            if (!this.callbacks[refId][fieldOrOperation]) {
                this.callbacks[refId][fieldOrOperation] = [];
            }
            this.callbacks[refId][fieldOrOperation].push(callback);
            return () => this.removeCallback(refId, fieldOrOperation, callback);
        }
        removeCallback(refId, field, callback) {
            const index = this.callbacks?.[refId]?.[field]?.indexOf(callback);
            if (index !== -1) {
                spliceOne(this.callbacks[refId][field], index);
            }
        }
    }

    class Decoder {
        constructor(root, context) {
            this.currentRefId = 0;
            this.setState(root);
            this.context = context || new TypeContext(root.constructor);
            // console.log(">>>>>>>>>>>>>>>> Decoder types");
            // this.context.schemas.forEach((id, schema) => {
            //     console.log("type:", id, schema.name, Object.keys(schema[Symbol.metadata]));
            // });
        }
        setState(root) {
            this.state = root;
            this.root = new ReferenceTracker();
            this.root.addRef(0, root);
        }
        decode(bytes, it = { offset: 0 }, ref = this.state) {
            const allChanges = [];
            const $root = this.root;
            const totalBytes = bytes.byteLength;
            let decoder = ref['constructor'][$decoder];
            this.currentRefId = 0;
            while (it.offset < totalBytes) {
                //
                // Peek ahead, check if it's a switch to a different structure
                //
                if (bytes[it.offset] == SWITCH_TO_STRUCTURE) {
                    it.offset++;
                    this.currentRefId = decode.number(bytes, it);
                    const nextRef = $root.refs.get(this.currentRefId);
                    //
                    // Trying to access a reference that haven't been decoded yet.
                    //
                    if (!nextRef) {
                        throw new Error(`"refId" not found: ${this.currentRefId}`);
                    }
                    ref[$onDecodeEnd]?.();
                    ref = nextRef;
                    decoder = ref.constructor[$decoder];
                    continue;
                }
                const result = decoder(this, bytes, it, ref, allChanges);
                if (result === DEFINITION_MISMATCH) {
                    console.warn("@colyseus/schema: definition mismatch");
                    //
                    // keep skipping next bytes until reaches a known structure
                    // by local decoder.
                    //
                    const nextIterator = { offset: it.offset };
                    while (it.offset < totalBytes) {
                        if (bytes[it.offset] === SWITCH_TO_STRUCTURE) {
                            nextIterator.offset = it.offset + 1;
                            if ($root.refs.has(decode.number(bytes, nextIterator))) {
                                break;
                            }
                        }
                        it.offset++;
                    }
                    continue;
                }
            }
            // FIXME: DRY with SWITCH_TO_STRUCTURE block.
            ref[$onDecodeEnd]?.();
            // trigger changes
            this.triggerChanges?.(allChanges);
            // drop references of unused schemas
            $root.garbageCollectDeletedRefs();
            return allChanges;
        }
        getInstanceType(bytes, it, defaultType) {
            let type;
            if (bytes[it.offset] === TYPE_ID) {
                it.offset++;
                const type_id = decode.number(bytes, it);
                type = this.context.get(type_id);
            }
            return type || defaultType;
        }
        createInstanceOfType(type) {
            // let instance: Schema = new (type as any)();
            // // assign root on $changes
            // instance[$changes].root = this.root[$changes].root;
            // return instance;
            return new type();
        }
        removeChildRefs(ref, allChanges) {
            const needRemoveRef = typeof (ref[$childType]) !== "string";
            const refId = this.root.refIds.get(ref);
            ref.forEach((value, key) => {
                allChanges.push({
                    ref: ref,
                    refId,
                    op: exports.OPERATION.DELETE,
                    field: key,
                    value: undefined,
                    previousValue: value
                });
                if (needRemoveRef) {
                    this.root.removeRef(this.root.refIds.get(value));
                }
            });
        }
    }

    /**
     * Reflection
     */
    class ReflectionField extends Schema {
    }
    __decorate([
        type("string")
    ], ReflectionField.prototype, "name", void 0);
    __decorate([
        type("string")
    ], ReflectionField.prototype, "type", void 0);
    __decorate([
        type("number")
    ], ReflectionField.prototype, "referencedType", void 0);
    class ReflectionType extends Schema {
        constructor() {
            super(...arguments);
            this.fields = new ArraySchema();
        }
    }
    __decorate([
        type("number")
    ], ReflectionType.prototype, "id", void 0);
    __decorate([
        type("number")
    ], ReflectionType.prototype, "extendsId", void 0);
    __decorate([
        type([ReflectionField])
    ], ReflectionType.prototype, "fields", void 0);
    class Reflection extends Schema {
        constructor() {
            super(...arguments);
            this.types = new ArraySchema();
        }
        /**
         * Encodes the TypeContext of an Encoder into a buffer.
         *
         * @param encoder Encoder instance
         * @param it
         * @returns
         */
        static encode(encoder, it = { offset: 0 }) {
            const context = encoder.context;
            const reflection = new Reflection();
            const reflectionEncoder = new Encoder(reflection);
            // rootType is usually the first schema passed to the Encoder
            // (unless it inherits from another schema)
            const rootType = context.schemas.get(encoder.state.constructor);
            if (rootType > 0) {
                reflection.rootType = rootType;
            }
            const includedTypeIds = new Set();
            const pendingReflectionTypes = {};
            // add type to reflection in a way that respects inheritance
            // (parent types should be added before their children)
            const addType = (type) => {
                if (type.extendsId === undefined || includedTypeIds.has(type.extendsId)) {
                    includedTypeIds.add(type.id);
                    reflection.types.push(type);
                    const deps = pendingReflectionTypes[type.id];
                    if (deps !== undefined) {
                        delete pendingReflectionTypes[type.id];
                        deps.forEach((childType) => addType(childType));
                    }
                }
                else {
                    if (pendingReflectionTypes[type.extendsId] === undefined) {
                        pendingReflectionTypes[type.extendsId] = [];
                    }
                    pendingReflectionTypes[type.extendsId].push(type);
                }
            };
            context.schemas.forEach((typeid, klass) => {
                const type = new ReflectionType();
                type.id = Number(typeid);
                // support inheritance
                const inheritFrom = Object.getPrototypeOf(klass);
                if (inheritFrom !== Schema) {
                    type.extendsId = context.schemas.get(inheritFrom);
                }
                const metadata = klass[Symbol.metadata];
                //
                // FIXME: this is a workaround for inherited types without additional fields
                // if metadata is the same reference as the parent class - it means the class has no own metadata
                //
                if (metadata !== inheritFrom[Symbol.metadata]) {
                    for (const fieldIndex in metadata) {
                        const index = Number(fieldIndex);
                        const fieldName = metadata[index].name;
                        // skip fields from parent classes
                        if (!Object.prototype.hasOwnProperty.call(metadata, fieldName)) {
                            continue;
                        }
                        const reflectionField = new ReflectionField();
                        reflectionField.name = fieldName;
                        let fieldType;
                        const field = metadata[index];
                        if (typeof (field.type) === "string") {
                            fieldType = field.type;
                        }
                        else {
                            let childTypeSchema;
                            //
                            // TODO: refactor below.
                            //
                            if (Schema.is(field.type)) {
                                fieldType = "ref";
                                childTypeSchema = field.type;
                            }
                            else {
                                fieldType = Object.keys(field.type)[0];
                                if (typeof (field.type[fieldType]) === "string") {
                                    fieldType += ":" + field.type[fieldType]; // array:string
                                }
                                else {
                                    childTypeSchema = field.type[fieldType];
                                }
                            }
                            reflectionField.referencedType = (childTypeSchema)
                                ? context.getTypeId(childTypeSchema)
                                : -1;
                        }
                        reflectionField.type = fieldType;
                        type.fields.push(reflectionField);
                    }
                }
                addType(type);
            });
            // in case there are types that were not added due to inheritance
            for (const typeid in pendingReflectionTypes) {
                pendingReflectionTypes[typeid].forEach((type) => reflection.types.push(type));
            }
            const buf = reflectionEncoder.encodeAll(it);
            return Buffer.from(buf, 0, it.offset);
        }
        /**
         * Decodes the TypeContext from a buffer into a Decoder instance.
         *
         * @param bytes Reflection.encode() output
         * @param it
         * @returns Decoder instance
         */
        static decode(bytes, it) {
            const reflection = new Reflection();
            const reflectionDecoder = new Decoder(reflection);
            reflectionDecoder.decode(bytes, it);
            const typeContext = new TypeContext();
            // 1st pass, initialize metadata + inheritance
            reflection.types.forEach((reflectionType) => {
                const parentClass = typeContext.get(reflectionType.extendsId) ?? Schema;
                const schema = class _ extends parentClass {
                };
                // register for inheritance support
                TypeContext.register(schema);
                // // for inheritance support
                // Metadata.initialize(schema);
                typeContext.add(schema, reflectionType.id);
            }, {});
            // define fields
            const addFields = (metadata, reflectionType, parentFieldIndex) => {
                reflectionType.fields.forEach((field, i) => {
                    const fieldIndex = parentFieldIndex + i;
                    if (field.referencedType !== undefined) {
                        let fieldType = field.type;
                        let refType = typeContext.get(field.referencedType);
                        // map or array of primitive type (-1)
                        if (!refType) {
                            const typeInfo = field.type.split(":");
                            fieldType = typeInfo[0];
                            refType = typeInfo[1]; // string
                        }
                        if (fieldType === "ref") {
                            Metadata.addField(metadata, fieldIndex, field.name, refType);
                        }
                        else {
                            Metadata.addField(metadata, fieldIndex, field.name, { [fieldType]: refType });
                        }
                    }
                    else {
                        Metadata.addField(metadata, fieldIndex, field.name, field.type);
                    }
                });
            };
            // 2nd pass, set fields
            reflection.types.forEach((reflectionType) => {
                const schema = typeContext.get(reflectionType.id);
                // for inheritance support
                const metadata = Metadata.initialize(schema);
                const inheritedTypes = [];
                let parentType = reflectionType;
                do {
                    inheritedTypes.push(parentType);
                    parentType = reflection.types.find((t) => t.id === parentType.extendsId);
                } while (parentType);
                let parentFieldIndex = 0;
                inheritedTypes.reverse().forEach((reflectionType) => {
                    // add fields from all inherited classes
                    // TODO: refactor this to avoid adding fields from parent classes
                    addFields(metadata, reflectionType, parentFieldIndex);
                    parentFieldIndex += reflectionType.fields.length;
                });
            });
            const state = new (typeContext.get(reflection.rootType || 0))();
            return new Decoder(state, typeContext);
        }
    }
    __decorate([
        type([ReflectionType])
    ], Reflection.prototype, "types", void 0);
    __decorate([
        type("number")
    ], Reflection.prototype, "rootType", void 0);

    function getDecoderStateCallbacks(decoder) {
        const $root = decoder.root;
        const callbacks = $root.callbacks;
        const onAddCalls = new WeakMap();
        let currentOnAddCallback;
        decoder.triggerChanges = function (allChanges) {
            const uniqueRefIds = new Set();
            for (let i = 0, l = allChanges.length; i < l; i++) {
                const change = allChanges[i];
                const refId = change.refId;
                const ref = change.ref;
                const $callbacks = callbacks[refId];
                if (!$callbacks) {
                    continue;
                }
                //
                // trigger onRemove on child structure.
                //
                if ((change.op & exports.OPERATION.DELETE) === exports.OPERATION.DELETE &&
                    change.previousValue instanceof Schema) {
                    const deleteCallbacks = callbacks[$root.refIds.get(change.previousValue)]?.[exports.OPERATION.DELETE];
                    for (let i = deleteCallbacks?.length - 1; i >= 0; i--) {
                        deleteCallbacks[i]();
                    }
                }
                if (ref instanceof Schema) {
                    //
                    // Handle schema instance
                    //
                    if (!uniqueRefIds.has(refId)) {
                        // trigger onChange
                        const replaceCallbacks = $callbacks?.[exports.OPERATION.REPLACE];
                        for (let i = replaceCallbacks?.length - 1; i >= 0; i--) {
                            replaceCallbacks[i]();
                            // try {
                            // } catch (e) {
                            //     console.error(e);
                            // }
                        }
                    }
                    if ($callbacks.hasOwnProperty(change.field)) {
                        const fieldCallbacks = $callbacks[change.field];
                        for (let i = fieldCallbacks?.length - 1; i >= 0; i--) {
                            fieldCallbacks[i](change.value, change.previousValue);
                            // try {
                            // } catch (e) {
                            //     console.error(e);
                            // }
                        }
                    }
                }
                else {
                    //
                    // Handle collection of items
                    //
                    if ((change.op & exports.OPERATION.DELETE) === exports.OPERATION.DELETE) {
                        //
                        // FIXME: `previousValue` should always be available.
                        //
                        if (change.previousValue !== undefined) {
                            // triger onRemove
                            const deleteCallbacks = $callbacks[exports.OPERATION.DELETE];
                            for (let i = deleteCallbacks?.length - 1; i >= 0; i--) {
                                deleteCallbacks[i](change.previousValue, change.dynamicIndex ?? change.field);
                            }
                        }
                        // Handle DELETE_AND_ADD operations
                        if ((change.op & exports.OPERATION.ADD) === exports.OPERATION.ADD) {
                            const addCallbacks = $callbacks[exports.OPERATION.ADD];
                            for (let i = addCallbacks?.length - 1; i >= 0; i--) {
                                addCallbacks[i](change.value, change.dynamicIndex ?? change.field);
                            }
                        }
                    }
                    else if ((change.op & exports.OPERATION.ADD) === exports.OPERATION.ADD &&
                        change.previousValue !== change.value) {
                        // triger onAdd
                        const addCallbacks = $callbacks[exports.OPERATION.ADD];
                        for (let i = addCallbacks?.length - 1; i >= 0; i--) {
                            addCallbacks[i](change.value, change.dynamicIndex ?? change.field);
                        }
                    }
                    // trigger onChange
                    if (change.value !== change.previousValue &&
                        // FIXME: see "should not encode item if added and removed at the same patch" test case.
                        // some "ADD" + "DELETE" operations on same patch are being encoded as "DELETE"
                        (change.value !== undefined || change.previousValue !== undefined)) {
                        const replaceCallbacks = $callbacks[exports.OPERATION.REPLACE];
                        for (let i = replaceCallbacks?.length - 1; i >= 0; i--) {
                            replaceCallbacks[i](change.value, change.dynamicIndex ?? change.field);
                        }
                    }
                }
                uniqueRefIds.add(refId);
            }
        };
        function getProxy(metadataOrType, context) {
            let metadata = context.instance?.constructor[Symbol.metadata] || metadataOrType;
            let isCollection = ((context.instance && typeof (context.instance['forEach']) === "function") ||
                (metadataOrType && typeof (metadataOrType[Symbol.metadata]) === "undefined"));
            if (metadata && !isCollection) {
                const onAddListen = function (ref, prop, callback, immediate) {
                    // immediate trigger
                    if (immediate &&
                        context.instance[prop] !== undefined &&
                        !onAddCalls.has(currentOnAddCallback) // Workaround for https://github.com/colyseus/schema/issues/147
                    ) {
                        callback(context.instance[prop], undefined);
                    }
                    return $root.addCallback($root.refIds.get(ref), prop, callback);
                };
                /**
                 * Schema instances
                 */
                return new Proxy({
                    listen: function listen(prop, callback, immediate = true) {
                        if (context.instance) {
                            return onAddListen(context.instance, prop, callback, immediate);
                        }
                        else {
                            // collection instance not received yet
                            let detachCallback = () => { };
                            context.onInstanceAvailable((ref, existing) => {
                                detachCallback = onAddListen(ref, prop, callback, immediate && existing && !onAddCalls.has(currentOnAddCallback));
                            });
                            return () => detachCallback();
                        }
                    },
                    onChange: function onChange(callback) {
                        return $root.addCallback($root.refIds.get(context.instance), exports.OPERATION.REPLACE, callback);
                    },
                    //
                    // TODO: refactor `bindTo()` implementation.
                    // There is room for improvement.
                    //
                    bindTo: function bindTo(targetObject, properties) {
                        if (!properties) {
                            properties = Object.keys(metadata).map((index) => metadata[index].name);
                        }
                        return $root.addCallback($root.refIds.get(context.instance), exports.OPERATION.REPLACE, () => {
                            properties.forEach((prop) => targetObject[prop] = context.instance[prop]);
                        });
                    }
                }, {
                    get(target, prop) {
                        const metadataField = metadata[metadata[prop]];
                        if (metadataField) {
                            const instance = context.instance?.[prop];
                            const onInstanceAvailable = ((callback) => {
                                const unbind = $(context.instance).listen(prop, (value, _) => {
                                    callback(value, false);
                                    // FIXME: by "unbinding" the callback here,
                                    // it will not support when the server
                                    // re-instantiates the instance.
                                    //
                                    unbind?.();
                                }, false);
                                // has existing value
                                if ($root.refIds.get(instance) !== undefined) {
                                    callback(instance, true);
                                }
                            });
                            return getProxy(metadataField.type, {
                                // make sure refId is available, otherwise need to wait for the instance to be available.
                                instance: ($root.refIds.get(instance) && instance),
                                parentInstance: context.instance,
                                onInstanceAvailable,
                            });
                        }
                        else {
                            // accessing the function
                            return target[prop];
                        }
                    },
                    has(target, prop) { return metadata[prop] !== undefined; },
                    set(_, _1, _2) { throw new Error("not allowed"); },
                    deleteProperty(_, _1) { throw new Error("not allowed"); },
                });
            }
            else {
                /**
                 * Collection instances
                 */
                const onAdd = function (ref, callback, immediate) {
                    // Trigger callback on existing items
                    if (immediate) {
                        ref.forEach((v, k) => callback(v, k));
                    }
                    return $root.addCallback($root.refIds.get(ref), exports.OPERATION.ADD, (value, key) => {
                        onAddCalls.set(callback, true);
                        currentOnAddCallback = callback;
                        callback(value, key);
                        onAddCalls.delete(callback);
                        currentOnAddCallback = undefined;
                    });
                };
                const onRemove = function (ref, callback) {
                    return $root.addCallback($root.refIds.get(ref), exports.OPERATION.DELETE, callback);
                };
                const onChange = function (ref, callback) {
                    return $root.addCallback($root.refIds.get(ref), exports.OPERATION.REPLACE, callback);
                };
                return new Proxy({
                    onAdd: function (callback, immediate = true) {
                        //
                        // https://github.com/colyseus/schema/issues/147
                        // If parent instance has "onAdd" registered, avoid triggering immediate callback.
                        //
                        if (context.instance) {
                            return onAdd(context.instance, callback, immediate && !onAddCalls.has(currentOnAddCallback));
                        }
                        else if (context.onInstanceAvailable) {
                            // collection instance not received yet
                            let detachCallback = () => { };
                            context.onInstanceAvailable((ref, existing) => {
                                detachCallback = onAdd(ref, callback, immediate && existing && !onAddCalls.has(currentOnAddCallback));
                            });
                            return () => detachCallback();
                        }
                    },
                    onRemove: function (callback) {
                        if (context.instance) {
                            return onRemove(context.instance, callback);
                        }
                        else if (context.onInstanceAvailable) {
                            // collection instance not received yet
                            let detachCallback = () => { };
                            context.onInstanceAvailable((ref) => {
                                detachCallback = onRemove(ref, callback);
                            });
                            return () => detachCallback();
                        }
                    },
                    onChange: function (callback) {
                        if (context.instance) {
                            return onChange(context.instance, callback);
                        }
                        else if (context.onInstanceAvailable) {
                            // collection instance not received yet
                            let detachCallback = () => { };
                            context.onInstanceAvailable((ref) => {
                                detachCallback = onChange(ref, callback);
                            });
                            return () => detachCallback();
                        }
                    },
                }, {
                    get(target, prop) {
                        if (!target[prop]) {
                            throw new Error(`Can't access '${prop}' through callback proxy. access the instance directly.`);
                        }
                        return target[prop];
                    },
                    has(target, prop) { return target[prop] !== undefined; },
                    set(_, _1, _2) { throw new Error("not allowed"); },
                    deleteProperty(_, _1) { throw new Error("not allowed"); },
                });
            }
        }
        function $(instance) {
            return getProxy(undefined, { instance });
        }
        return $;
    }

    function getRawChangesCallback(decoder, callback) {
        decoder.triggerChanges = callback;
    }

    class StateView {
        constructor(iterable = false) {
            this.iterable = iterable;
            /**
             * List of ChangeTree's that are visible to this view
             */
            this.visible = new WeakSet();
            /**
             * List of ChangeTree's that are invisible to this view
             */
            this.invisible = new WeakSet();
            /**
             * Manual "ADD" operations for changes per ChangeTree, specific to this view.
             * (This is used to force encoding a property, even if it was not changed)
             */
            this.changes = new Map();
            if (iterable) {
                this.items = [];
            }
        }
        // TODO: allow to set multiple tags at once
        add(obj, tag = DEFAULT_VIEW_TAG, checkIncludeParent = true) {
            const changeTree = obj?.[$changes];
            if (!changeTree) {
                console.warn("StateView#add(), invalid object:", obj);
                return this;
            }
            else if (!changeTree.parent &&
                changeTree.refId !== 0 // allow root object
            ) {
                /**
                 * TODO: can we avoid this?
                 *
                 * When the "parent" structure has the @view() tag, it is currently
                 * not possible to identify it has to be added to the view as well
                 * (this.addParentOf() is not called).
                 */
                throw new Error(`Cannot add a detached instance to the StateView. Make sure to assign the "${changeTree.ref.constructor.name}" instance to the state before calling view.add()`);
            }
            // FIXME: ArraySchema/MapSchema do not have metadata
            const metadata = obj.constructor[Symbol.metadata];
            this.visible.add(changeTree);
            // add to iterable list (only the explicitly added items)
            if (this.iterable && checkIncludeParent) {
                this.items.push(obj);
            }
            // add parent ChangeTree's
            // - if it was invisible to this view
            // - if it were previously filtered out
            if (checkIncludeParent && changeTree.parent) {
                this.addParentOf(changeTree, tag);
            }
            //
            // TODO: when adding an item of a MapSchema, the changes may not
            // be set (only the parent's changes are set)
            //
            let changes = this.changes.get(changeTree.refId);
            if (changes === undefined) {
                changes = {};
                this.changes.set(changeTree.refId, changes);
            }
            // set tag
            if (tag !== DEFAULT_VIEW_TAG) {
                if (!this.tags) {
                    this.tags = new WeakMap();
                }
                let tags;
                if (!this.tags.has(changeTree)) {
                    tags = new Set();
                    this.tags.set(changeTree, tags);
                }
                else {
                    tags = this.tags.get(changeTree);
                }
                tags.add(tag);
                // Ref: add tagged properties
                metadata?.[$fieldIndexesByViewTag]?.[tag]?.forEach((index) => {
                    if (changeTree.getChange(index) !== exports.OPERATION.DELETE) {
                        changes[index] = exports.OPERATION.ADD;
                    }
                });
            }
            else {
                const isInvisible = this.invisible.has(changeTree);
                const changeSet = (changeTree.filteredChanges !== undefined)
                    ? changeTree.allFilteredChanges
                    : changeTree.allChanges;
                for (let i = 0, len = changeSet.operations.length; i < len; i++) {
                    const index = changeSet.operations[i];
                    if (index === undefined) {
                        continue;
                    } // skip "undefined" indexes
                    const op = changeTree.indexedOperations[index] ?? exports.OPERATION.ADD;
                    const tagAtIndex = metadata?.[index].tag;
                    if (!changeTree.isNew && // new structures will be added as part of .encode() call, no need to force it to .encodeView()
                        (isInvisible || // if "invisible", include all
                            tagAtIndex === undefined || // "all change" with no tag
                            tagAtIndex === tag // tagged property
                        ) &&
                        op !== exports.OPERATION.DELETE) {
                        changes[index] = op;
                    }
                }
            }
            // Add children of this ChangeTree to this view
            changeTree.forEachChild((change, index) => {
                // Do not ADD children that don't have the same tag
                if (metadata &&
                    metadata[index].tag !== undefined &&
                    metadata[index].tag !== tag) {
                    return;
                }
                this.add(change.ref, tag, false);
            });
            return this;
        }
        addParentOf(childChangeTree, tag) {
            const changeTree = childChangeTree.parent[$changes];
            const parentIndex = childChangeTree.parentIndex;
            if (!this.visible.has(changeTree)) {
                // view must have all "changeTree" parent tree
                this.visible.add(changeTree);
                // add parent's parent
                const parentChangeTree = changeTree.parent?.[$changes];
                if (parentChangeTree && (parentChangeTree.filteredChanges !== undefined)) {
                    this.addParentOf(changeTree, tag);
                }
                // // parent is already available, no need to add it!
                // if (!this.invisible.has(changeTree)) { return; }
            }
            // add parent's tag properties
            if (changeTree.getChange(parentIndex) !== exports.OPERATION.DELETE) {
                let changes = this.changes.get(changeTree.refId);
                if (changes === undefined) {
                    changes = {};
                    this.changes.set(changeTree.refId, changes);
                }
                if (!this.tags) {
                    this.tags = new WeakMap();
                }
                let tags;
                if (!this.tags.has(changeTree)) {
                    tags = new Set();
                    this.tags.set(changeTree, tags);
                }
                else {
                    tags = this.tags.get(changeTree);
                }
                tags.add(tag);
                changes[parentIndex] = exports.OPERATION.ADD;
            }
        }
        remove(obj, tag = DEFAULT_VIEW_TAG, _isClear = false) {
            const changeTree = obj[$changes];
            if (!changeTree) {
                console.warn("StateView#remove(), invalid object:", obj);
                return this;
            }
            this.visible.delete(changeTree);
            // remove from iterable list
            if (this.iterable &&
                !_isClear // no need to remove during clear(), as it will be cleared entirely
            ) {
                spliceOne(this.items, this.items.indexOf(obj));
            }
            const ref = changeTree.ref;
            const metadata = ref.constructor[Symbol.metadata]; // ArraySchema/MapSchema do not have metadata
            let changes = this.changes.get(changeTree.refId);
            if (changes === undefined) {
                changes = {};
                this.changes.set(changeTree.refId, changes);
            }
            if (tag === DEFAULT_VIEW_TAG) {
                // parent is collection (Map/Array)
                const parent = changeTree.parent;
                if (!Metadata.isValidInstance(parent) && changeTree.isFiltered) {
                    const parentChangeTree = parent[$changes];
                    let changes = this.changes.get(parentChangeTree.refId);
                    if (changes === undefined) {
                        changes = {};
                        this.changes.set(parentChangeTree.refId, changes);
                    }
                    // DELETE / DELETE BY REF ID
                    changes[changeTree.parentIndex] = exports.OPERATION.DELETE;
                }
                else {
                    // delete all "tagged" properties.
                    metadata?.[$viewFieldIndexes]?.forEach((index) => changes[index] = exports.OPERATION.DELETE);
                }
            }
            else {
                // delete only tagged properties
                metadata?.[$fieldIndexesByViewTag][tag].forEach((index) => changes[index] = exports.OPERATION.DELETE);
            }
            // remove tag
            if (this.tags && this.tags.has(changeTree)) {
                const tags = this.tags.get(changeTree);
                if (tag === undefined) {
                    // delete all tags
                    this.tags.delete(changeTree);
                }
                else {
                    // delete specific tag
                    tags.delete(tag);
                    // if tag set is empty, delete it entirely
                    if (tags.size === 0) {
                        this.tags.delete(changeTree);
                    }
                }
            }
            return this;
        }
        has(obj) {
            return this.visible.has(obj[$changes]);
        }
        hasTag(ob, tag = DEFAULT_VIEW_TAG) {
            const tags = this.tags?.get(ob[$changes]);
            return tags?.has(tag) ?? false;
        }
        clear() {
            if (!this.iterable) {
                throw new Error("StateView#clear() is only available for iterable StateView's. Use StateView(iterable: true) constructor.");
            }
            for (let i = 0, l = this.items.length; i < l; i++) {
                this.remove(this.items[i], DEFAULT_VIEW_TAG, true);
            }
            // clear items array
            this.items.length = 0;
        }
        isChangeTreeVisible(changeTree) {
            let isVisible = this.visible.has(changeTree);
            //
            // TODO: avoid checking for parent visibility, most of the time it's not needed
            // See test case: 'should not be required to manually call view.add() items to child arrays without @view() tag'
            //
            if (!isVisible && changeTree.isVisibilitySharedWithParent) {
                // console.log("CHECK AGAINST PARENT...", {
                //     ref: changeTree.ref.constructor.name,
                //     refId: changeTree.refId,
                //     parent: changeTree.parent.constructor.name,
                // });
                if (this.visible.has(changeTree.parent[$changes])) {
                    this.visible.add(changeTree);
                    isVisible = true;
                }
            }
            return isVisible;
        }
    }

    registerType("map", { constructor: MapSchema });
    registerType("array", { constructor: ArraySchema });
    registerType("set", { constructor: SetSchema });
    registerType("collection", { constructor: CollectionSchema, });

    exports.$changes = $changes;
    exports.$childType = $childType;
    exports.$decoder = $decoder;
    exports.$deleteByIndex = $deleteByIndex;
    exports.$encoder = $encoder;
    exports.$filter = $filter;
    exports.$getByIndex = $getByIndex;
    exports.$track = $track;
    exports.ArraySchema = ArraySchema;
    exports.ChangeTree = ChangeTree;
    exports.CollectionSchema = CollectionSchema;
    exports.Decoder = Decoder;
    exports.Encoder = Encoder;
    exports.MapSchema = MapSchema;
    exports.Metadata = Metadata;
    exports.Reflection = Reflection;
    exports.ReflectionField = ReflectionField;
    exports.ReflectionType = ReflectionType;
    exports.Schema = Schema;
    exports.SetSchema = SetSchema;
    exports.StateView = StateView;
    exports.TypeContext = TypeContext;
    exports.decode = decode;
    exports.decodeKeyValueOperation = decodeKeyValueOperation;
    exports.decodeSchemaOperation = decodeSchemaOperation;
    exports.defineCustomTypes = defineCustomTypes;
    exports.defineTypes = defineTypes;
    exports.deprecated = deprecated;
    exports.dumpChanges = dumpChanges;
    exports.encode = encode;
    exports.encodeArray = encodeArray;
    exports.encodeKeyValueOperation = encodeKeyValueOperation;
    exports.encodeSchemaOperation = encodeSchemaOperation;
    exports.entity = entity;
    exports.getDecoderStateCallbacks = getDecoderStateCallbacks;
    exports.getRawChangesCallback = getRawChangesCallback;
    exports.registerType = registerType;
    exports.schema = schema;
    exports.type = type;
    exports.view = view;

}));


}),
"./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js": 
/*!*****************************************************************************!*\
  !*** ./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js ***!
  \*****************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";
/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js */ "./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/.pnpm/console-browserify@1.2.0/node_modules/console-browserify/index.js */ "./node_modules/.pnpm/console-browserify@1.2.0/node_modules/console-browserify/index.js");
// Currently in sync with Node.js lib/assert.js
// https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b

// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
var _require = __webpack_require__(/*! ./internal/errors */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/errors.js"),
  _require$codes = _require.codes,
  ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT,
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE,
  ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE,
  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
var AssertionError = __webpack_require__(/*! ./internal/assert/assertion_error */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/assert/assertion_error.js");
var _require2 = __webpack_require__(/*! util/ */ "./node_modules/.pnpm/util@0.12.5/node_modules/util/util.js"),
  inspect = _require2.inspect;
var _require$types = (__webpack_require__(/*! util/ */ "./node_modules/.pnpm/util@0.12.5/node_modules/util/util.js")/* .types */.types),
  isPromise = _require$types.isPromise,
  isRegExp = _require$types.isRegExp;
var objectAssign = __webpack_require__(/*! object.assign/polyfill */ "./node_modules/.pnpm/object.assign@4.1.7/node_modules/object.assign/polyfill.js")();
var objectIs = __webpack_require__(/*! object-is/polyfill */ "./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/polyfill.js")();
var RegExpPrototypeTest = __webpack_require__(/*! call-bind/callBound */ "./node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/callBound.js")('RegExp.prototype.test');
var errorCache = new Map();
var isDeepEqual;
var isDeepStrictEqual;
var parseExpressionAt;
var findNodeAround;
var decoder;
function lazyLoadComparison() {
  var comparison = __webpack_require__(/*! ./internal/util/comparisons */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/util/comparisons.js");
  isDeepEqual = comparison.isDeepEqual;
  isDeepStrictEqual = comparison.isDeepStrictEqual;
}

// Escape control characters but not \n and \t to keep the line breaks and
// indentation intact.
// eslint-disable-next-line no-control-regex
var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
var meta = ["\\u0000", "\\u0001", "\\u0002", "\\u0003", "\\u0004", "\\u0005", "\\u0006", "\\u0007", '\\b', '', '', "\\u000b", '\\f', '', "\\u000e", "\\u000f", "\\u0010", "\\u0011", "\\u0012", "\\u0013", "\\u0014", "\\u0015", "\\u0016", "\\u0017", "\\u0018", "\\u0019", "\\u001a", "\\u001b", "\\u001c", "\\u001d", "\\u001e", "\\u001f"];
var escapeFn = function escapeFn(str) {
  return meta[str.charCodeAt(0)];
};
var warned = false;

// The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;
var NO_EXCEPTION_SENTINEL = {};

// All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided. All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function innerFail(obj) {
  if (obj.message instanceof Error) throw obj.message;
  throw new AssertionError(obj);
}
function fail(actual, expected, message, operator, stackStartFn) {
  var argsLen = arguments.length;
  var internalMessage;
  if (argsLen === 0) {
    internalMessage = 'Failed';
  } else if (argsLen === 1) {
    message = actual;
    actual = undefined;
  } else {
    if (warned === false) {
      warned = true;
      var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
      warn('assert.fail() with more than one argument is deprecated. ' + 'Please use assert.strictEqual() instead or only pass a message.', 'DeprecationWarning', 'DEP0094');
    }
    if (argsLen === 2) operator = '!=';
  }
  if (message instanceof Error) throw message;
  var errArgs = {
    actual: actual,
    expected: expected,
    operator: operator === undefined ? 'fail' : operator,
    stackStartFn: stackStartFn || fail
  };
  if (message !== undefined) {
    errArgs.message = message;
  }
  var err = new AssertionError(errArgs);
  if (internalMessage) {
    err.message = internalMessage;
    err.generatedMessage = true;
  }
  throw err;
}
assert.fail = fail;

// The AssertionError is defined in internal/error.
assert.AssertionError = AssertionError;
function innerOk(fn, argLen, value, message) {
  if (!value) {
    var generatedMessage = false;
    if (argLen === 0) {
      generatedMessage = true;
      message = 'No value argument passed to `assert.ok()`';
    } else if (message instanceof Error) {
      throw message;
    }
    var err = new AssertionError({
      actual: value,
      expected: true,
      message: message,
      operator: '==',
      stackStartFn: fn
    });
    err.generatedMessage = generatedMessage;
    throw err;
  }
}

// Pure assertion tests whether a value is truthy, as determined
// by !!value.
function ok() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  innerOk.apply(void 0, [ok, args.length].concat(args));
}
assert.ok = ok;

// The equality assertion tests shallow, coercive equality with ==.
/* eslint-disable no-restricted-properties */
assert.equal = function equal(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  // eslint-disable-next-line eqeqeq
  if (actual != expected) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: '==',
      stackStartFn: equal
    });
  }
};

// The non-equality assertion tests for whether two objects are not
// equal with !=.
assert.notEqual = function notEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  // eslint-disable-next-line eqeqeq
  if (actual == expected) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: '!=',
      stackStartFn: notEqual
    });
  }
};

// The equivalence assertion tests a deep equality relation.
assert.deepEqual = function deepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (isDeepEqual === undefined) lazyLoadComparison();
  if (!isDeepEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'deepEqual',
      stackStartFn: deepEqual
    });
  }
};

// The non-equivalence assertion tests for any deep inequality.
assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (isDeepEqual === undefined) lazyLoadComparison();
  if (isDeepEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notDeepEqual',
      stackStartFn: notDeepEqual
    });
  }
};
/* eslint-enable */

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (isDeepEqual === undefined) lazyLoadComparison();
  if (!isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'deepStrictEqual',
      stackStartFn: deepStrictEqual
    });
  }
};
assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (isDeepEqual === undefined) lazyLoadComparison();
  if (isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notDeepStrictEqual',
      stackStartFn: notDeepStrictEqual
    });
  }
}
assert.strictEqual = function strictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (!objectIs(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'strictEqual',
      stackStartFn: strictEqual
    });
  }
};
assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (objectIs(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notStrictEqual',
      stackStartFn: notStrictEqual
    });
  }
};
var Comparison = /*#__PURE__*/_createClass(function Comparison(obj, keys, actual) {
  var _this = this;
  _classCallCheck(this, Comparison);
  keys.forEach(function (key) {
    if (key in obj) {
      if (actual !== undefined && typeof actual[key] === 'string' && isRegExp(obj[key]) && RegExpPrototypeTest(obj[key], actual[key])) {
        _this[key] = actual[key];
      } else {
        _this[key] = obj[key];
      }
    }
  });
});
function compareExceptionKey(actual, expected, key, message, keys, fn) {
  if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
    if (!message) {
      // Create placeholder objects to create a nice output.
      var a = new Comparison(actual, keys);
      var b = new Comparison(expected, keys, actual);
      var err = new AssertionError({
        actual: a,
        expected: b,
        operator: 'deepStrictEqual',
        stackStartFn: fn
      });
      err.actual = actual;
      err.expected = expected;
      err.operator = fn.name;
      throw err;
    }
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: fn.name,
      stackStartFn: fn
    });
  }
}
function expectedException(actual, expected, msg, fn) {
  if (typeof expected !== 'function') {
    if (isRegExp(expected)) return RegExpPrototypeTest(expected, actual);
    // assert.doesNotThrow does not accept objects.
    if (arguments.length === 2) {
      throw new ERR_INVALID_ARG_TYPE('expected', ['Function', 'RegExp'], expected);
    }

    // Handle primitives properly.
    if (_typeof(actual) !== 'object' || actual === null) {
      var err = new AssertionError({
        actual: actual,
        expected: expected,
        message: msg,
        operator: 'deepStrictEqual',
        stackStartFn: fn
      });
      err.operator = fn.name;
      throw err;
    }
    var keys = Object.keys(expected);
    // Special handle errors to make sure the name and the message are compared
    // as well.
    if (expected instanceof Error) {
      keys.push('name', 'message');
    } else if (keys.length === 0) {
      throw new ERR_INVALID_ARG_VALUE('error', expected, 'may not be an empty object');
    }
    if (isDeepEqual === undefined) lazyLoadComparison();
    keys.forEach(function (key) {
      if (typeof actual[key] === 'string' && isRegExp(expected[key]) && RegExpPrototypeTest(expected[key], actual[key])) {
        return;
      }
      compareExceptionKey(actual, expected, key, msg, keys, fn);
    });
    return true;
  }
  // Guard instanceof against arrow functions as they don't have a prototype.
  if (expected.prototype !== undefined && actual instanceof expected) {
    return true;
  }
  if (Error.isPrototypeOf(expected)) {
    return false;
  }
  return expected.call({}, actual) === true;
}
function getActual(fn) {
  if (typeof fn !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn);
  }
  try {
    fn();
  } catch (e) {
    return e;
  }
  return NO_EXCEPTION_SENTINEL;
}
function checkIsPromise(obj) {
  // Accept native ES6 promises and promises that are implemented in a similar
  // way. Do not accept thenables that use a function as `obj` and that have no
  // `catch` handler.

  // TODO: thenables are checked up until they have the correct methods,
  // but according to documentation, the `then` method should receive
  // the `fulfill` and `reject` arguments as well or it may be never resolved.

  return isPromise(obj) || obj !== null && _typeof(obj) === 'object' && typeof obj.then === 'function' && typeof obj.catch === 'function';
}
function waitForActual(promiseFn) {
  return Promise.resolve().then(function () {
    var resultPromise;
    if (typeof promiseFn === 'function') {
      // Return a rejected promise if `promiseFn` throws synchronously.
      resultPromise = promiseFn();
      // Fail in case no promise is returned.
      if (!checkIsPromise(resultPromise)) {
        throw new ERR_INVALID_RETURN_VALUE('instance of Promise', 'promiseFn', resultPromise);
      }
    } else if (checkIsPromise(promiseFn)) {
      resultPromise = promiseFn;
    } else {
      throw new ERR_INVALID_ARG_TYPE('promiseFn', ['Function', 'Promise'], promiseFn);
    }
    return Promise.resolve().then(function () {
      return resultPromise;
    }).then(function () {
      return NO_EXCEPTION_SENTINEL;
    }).catch(function (e) {
      return e;
    });
  });
}
function expectsError(stackStartFn, actual, error, message) {
  if (typeof error === 'string') {
    if (arguments.length === 4) {
      throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);
    }
    if (_typeof(actual) === 'object' && actual !== null) {
      if (actual.message === error) {
        throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error message \"".concat(actual.message, "\" is identical to the message."));
      }
    } else if (actual === error) {
      throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error \"".concat(actual, "\" is identical to the message."));
    }
    message = error;
    error = undefined;
  } else if (error != null && _typeof(error) !== 'object' && typeof error !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);
  }
  if (actual === NO_EXCEPTION_SENTINEL) {
    var details = '';
    if (error && error.name) {
      details += " (".concat(error.name, ")");
    }
    details += message ? ": ".concat(message) : '.';
    var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';
    innerFail({
      actual: undefined,
      expected: error,
      operator: stackStartFn.name,
      message: "Missing expected ".concat(fnType).concat(details),
      stackStartFn: stackStartFn
    });
  }
  if (error && !expectedException(actual, error, message, stackStartFn)) {
    throw actual;
  }
}
function expectsNoError(stackStartFn, actual, error, message) {
  if (actual === NO_EXCEPTION_SENTINEL) return;
  if (typeof error === 'string') {
    message = error;
    error = undefined;
  }
  if (!error || expectedException(actual, error)) {
    var details = message ? ": ".concat(message) : '.';
    var fnType = stackStartFn.name === 'doesNotReject' ? 'rejection' : 'exception';
    innerFail({
      actual: actual,
      expected: error,
      operator: stackStartFn.name,
      message: "Got unwanted ".concat(fnType).concat(details, "\n") + "Actual message: \"".concat(actual && actual.message, "\""),
      stackStartFn: stackStartFn
    });
  }
  throw actual;
}
assert.throws = function throws(promiseFn) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
};
assert.rejects = function rejects(promiseFn) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }
  return waitForActual(promiseFn).then(function (result) {
    return expectsError.apply(void 0, [rejects, result].concat(args));
  });
};
assert.doesNotThrow = function doesNotThrow(fn) {
  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    args[_key4 - 1] = arguments[_key4];
  }
  expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));
};
assert.doesNotReject = function doesNotReject(fn) {
  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
    args[_key5 - 1] = arguments[_key5];
  }
  return waitForActual(fn).then(function (result) {
    return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
  });
};
assert.ifError = function ifError(err) {
  if (err !== null && err !== undefined) {
    var message = 'ifError got unwanted exception: ';
    if (_typeof(err) === 'object' && typeof err.message === 'string') {
      if (err.message.length === 0 && err.constructor) {
        message += err.constructor.name;
      } else {
        message += err.message;
      }
    } else {
      message += inspect(err);
    }
    var newErr = new AssertionError({
      actual: err,
      expected: null,
      operator: 'ifError',
      message: message,
      stackStartFn: ifError
    });

    // Make sure we actually have a stack trace!
    var origStack = err.stack;
    if (typeof origStack === 'string') {
      // This will remove any duplicated frames from the error frames taken
      // from within `ifError` and add the original error frames to the newly
      // created ones.
      var tmp2 = origStack.split('\n');
      tmp2.shift();
      // Filter all frames existing in err.stack.
      var tmp1 = newErr.stack.split('\n');
      for (var i = 0; i < tmp2.length; i++) {
        // Find the first occurrence of the frame.
        var pos = tmp1.indexOf(tmp2[i]);
        if (pos !== -1) {
          // Only keep new frames.
          tmp1 = tmp1.slice(0, pos);
          break;
        }
      }
      newErr.stack = "".concat(tmp1.join('\n'), "\n").concat(tmp2.join('\n'));
    }
    throw newErr;
  }
};

// Currently in sync with Node.js lib/assert.js
// https://github.com/nodejs/node/commit/2a871df3dfb8ea663ef5e1f8f62701ec51384ecb
function internalMatch(string, regexp, message, fn, fnName) {
  if (!isRegExp(regexp)) {
    throw new ERR_INVALID_ARG_TYPE('regexp', 'RegExp', regexp);
  }
  var match = fnName === 'match';
  if (typeof string !== 'string' || RegExpPrototypeTest(regexp, string) !== match) {
    if (message instanceof Error) {
      throw message;
    }
    var generatedMessage = !message;

    // 'The input was expected to not match the regular expression ' +
    message = message || (typeof string !== 'string' ? 'The "string" argument must be of type string. Received type ' + "".concat(_typeof(string), " (").concat(inspect(string), ")") : (match ? 'The input did not match the regular expression ' : 'The input was expected to not match the regular expression ') + "".concat(inspect(regexp), ". Input:\n\n").concat(inspect(string), "\n"));
    var err = new AssertionError({
      actual: string,
      expected: regexp,
      message: message,
      operator: fnName,
      stackStartFn: fn
    });
    err.generatedMessage = generatedMessage;
    throw err;
  }
}
assert.match = function match(string, regexp, message) {
  internalMatch(string, regexp, message, match, 'match');
};
assert.doesNotMatch = function doesNotMatch(string, regexp, message) {
  internalMatch(string, regexp, message, doesNotMatch, 'doesNotMatch');
};

// Expose a strict only variant of assert
function strict() {
  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    args[_key6] = arguments[_key6];
  }
  innerOk.apply(void 0, [strict, args.length].concat(args));
}
assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

}),
"./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/assert/assertion_error.js": 
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/assert/assertion_error.js ***!
  \******************************************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";
/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js */ "./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");
// Currently in sync with Node.js lib/internal/assert/assertion_error.js
// https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c



function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _require = __webpack_require__(/*! util/ */ "./node_modules/.pnpm/util@0.12.5/node_modules/util/util.js"),
  inspect = _require.inspect;
var _require2 = __webpack_require__(/*! ../errors */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/errors.js"),
  ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE;

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
function repeat(str, count) {
  count = Math.floor(count);
  if (str.length == 0 || count == 0) return '';
  var maxCount = str.length * count;
  count = Math.floor(Math.log(count) / Math.log(2));
  while (count) {
    str += str;
    count--;
  }
  str += str.substring(0, maxCount - str.length);
  return str;
}
var blue = '';
var green = '';
var red = '';
var white = '';
var kReadableOperator = {
  deepStrictEqual: 'Expected values to be strictly deep-equal:',
  strictEqual: 'Expected values to be strictly equal:',
  strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
  deepEqual: 'Expected values to be loosely deep-equal:',
  equal: 'Expected values to be loosely equal:',
  notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
  notStrictEqual: 'Expected "actual" to be strictly unequal to:',
  notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
  notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
  notEqual: 'Expected "actual" to be loosely unequal to:',
  notIdentical: 'Values identical but not reference-equal:'
};

// Comparing short primitives should just show === / !== instead of using the
// diff.
var kMaxShortLength = 10;
function copyError(source) {
  var keys = Object.keys(source);
  var target = Object.create(Object.getPrototypeOf(source));
  keys.forEach(function (key) {
    target[key] = source[key];
  });
  Object.defineProperty(target, 'message', {
    value: source.message
  });
  return target;
}
function inspectValue(val) {
  // The util.inspect default values could be changed. This makes sure the
  // error messages contain the necessary information nevertheless.
  return inspect(val, {
    compact: false,
    customInspect: false,
    depth: 1000,
    maxArrayLength: Infinity,
    // Assert compares only enumerable properties (with a few exceptions).
    showHidden: false,
    // Having a long line as error is better than wrapping the line for
    // comparison for now.
    // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
    // have meta information about the inspected properties (i.e., know where
    // in what line the property starts and ends).
    breakLength: Infinity,
    // Assert does not detect proxies currently.
    showProxy: false,
    sorted: true,
    // Inspect getters as we also check them when comparing entries.
    getters: true
  });
}
function createErrDiff(actual, expected, operator) {
  var other = '';
  var res = '';
  var lastPos = 0;
  var end = '';
  var skipped = false;
  var actualInspected = inspectValue(actual);
  var actualLines = actualInspected.split('\n');
  var expectedLines = inspectValue(expected).split('\n');
  var i = 0;
  var indicator = '';

  // In case both values are objects explicitly mark them as not reference equal
  // for the `strictEqual` operator.
  if (operator === 'strictEqual' && _typeof(actual) === 'object' && _typeof(expected) === 'object' && actual !== null && expected !== null) {
    operator = 'strictEqualObject';
  }

  // If "actual" and "expected" fit on a single line and they are not strictly
  // equal, check further special handling.
  if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
    var inputLength = actualLines[0].length + expectedLines[0].length;
    // If the character length of "actual" and "expected" together is less than
    // kMaxShortLength and if neither is an object and at least one of them is
    // not `zero`, use the strict equal comparison to visualize the output.
    if (inputLength <= kMaxShortLength) {
      if ((_typeof(actual) !== 'object' || actual === null) && (_typeof(expected) !== 'object' || expected === null) && (actual !== 0 || expected !== 0)) {
        // -0 === +0
        return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
      }
    } else if (operator !== 'strictEqualObject') {
      // If the stderr is a tty and the input length is lower than the current
      // columns per line, add a mismatch indicator below the output. If it is
      // not a tty, use a default value of 80 characters.
      var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
      if (inputLength < maxLength) {
        while (actualLines[0][i] === expectedLines[0][i]) {
          i++;
        }
        // Ignore the first characters.
        if (i > 2) {
          // Add position indicator for the first mismatch in case it is a
          // single line and the input length is less than the column length.
          indicator = "\n  ".concat(repeat(' ', i), "^");
          i = 0;
        }
      }
    }
  }

  // Remove all ending lines that match (this optimizes the output for
  // readability by reducing the number of total changed lines).
  var a = actualLines[actualLines.length - 1];
  var b = expectedLines[expectedLines.length - 1];
  while (a === b) {
    if (i++ < 2) {
      end = "\n  ".concat(a).concat(end);
    } else {
      other = a;
    }
    actualLines.pop();
    expectedLines.pop();
    if (actualLines.length === 0 || expectedLines.length === 0) break;
    a = actualLines[actualLines.length - 1];
    b = expectedLines[expectedLines.length - 1];
  }
  var maxLines = Math.max(actualLines.length, expectedLines.length);
  // Strict equal with identical objects that are not identical by reference.
  // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })
  if (maxLines === 0) {
    // We have to get the result again. The lines were all removed before.
    var _actualLines = actualInspected.split('\n');

    // Only remove lines in case it makes sense to collapse those.
    // TODO: Accept env to always show the full error.
    if (_actualLines.length > 30) {
      _actualLines[26] = "".concat(blue, "...").concat(white);
      while (_actualLines.length > 27) {
        _actualLines.pop();
      }
    }
    return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join('\n'), "\n");
  }
  if (i > 3) {
    end = "\n".concat(blue, "...").concat(white).concat(end);
    skipped = true;
  }
  if (other !== '') {
    end = "\n  ".concat(other).concat(end);
    other = '';
  }
  var printedLines = 0;
  var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
  var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
  for (i = 0; i < maxLines; i++) {
    // Only extra expected lines exist
    var cur = i - lastPos;
    if (actualLines.length < i + 1) {
      // If the last diverging line is more than one line above and the
      // current line is at least line three, add some of the former lines and
      // also add dots to indicate skipped entries.
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += "\n".concat(blue, "...").concat(white);
          skipped = true;
        } else if (cur > 3) {
          res += "\n  ".concat(expectedLines[i - 2]);
          printedLines++;
        }
        res += "\n  ".concat(expectedLines[i - 1]);
        printedLines++;
      }
      // Mark the current line as the last diverging one.
      lastPos = i;
      // Add the expected line to the cache.
      other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
      printedLines++;
      // Only extra actual lines exist
    } else if (expectedLines.length < i + 1) {
      // If the last diverging line is more than one line above and the
      // current line is at least line three, add some of the former lines and
      // also add dots to indicate skipped entries.
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += "\n".concat(blue, "...").concat(white);
          skipped = true;
        } else if (cur > 3) {
          res += "\n  ".concat(actualLines[i - 2]);
          printedLines++;
        }
        res += "\n  ".concat(actualLines[i - 1]);
        printedLines++;
      }
      // Mark the current line as the last diverging one.
      lastPos = i;
      // Add the actual line to the result.
      res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
      printedLines++;
      // Lines diverge
    } else {
      var expectedLine = expectedLines[i];
      var actualLine = actualLines[i];
      // If the lines diverge, specifically check for lines that only diverge by
      // a trailing comma. In that case it is actually identical and we should
      // mark it as such.
      var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ',') || actualLine.slice(0, -1) !== expectedLine);
      // If the expected line has a trailing comma but is otherwise identical,
      // add a comma at the end of the actual line. Otherwise the output could
      // look weird as in:
      //
      //   [
      //     1         // No comma at the end!
      // +   2
      //   ]
      //
      if (divergingLines && endsWith(expectedLine, ',') && expectedLine.slice(0, -1) === actualLine) {
        divergingLines = false;
        actualLine += ',';
      }
      if (divergingLines) {
        // If the last diverging line is more than one line above and the
        // current line is at least line three, add some of the former lines and
        // also add dots to indicate skipped entries.
        if (cur > 1 && i > 2) {
          if (cur > 4) {
            res += "\n".concat(blue, "...").concat(white);
            skipped = true;
          } else if (cur > 3) {
            res += "\n  ".concat(actualLines[i - 2]);
            printedLines++;
          }
          res += "\n  ".concat(actualLines[i - 1]);
          printedLines++;
        }
        // Mark the current line as the last diverging one.
        lastPos = i;
        // Add the actual line to the result and cache the expected diverging
        // line so consecutive diverging lines show up as +++--- and not +-+-+-.
        res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
        other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
        printedLines += 2;
        // Lines are identical
      } else {
        // Add all cached information to the result before adding other things
        // and reset the cache.
        res += other;
        other = '';
        // If the last diverging line is exactly one line above or if it is the
        // very first line, add the line to the result.
        if (cur === 1 || i === 0) {
          res += "\n  ".concat(actualLine);
          printedLines++;
        }
      }
    }
    // Inspected object to big (Show ~20 rows max)
    if (printedLines > 20 && i < maxLines - 2) {
      return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
    }
  }
  return "".concat(msg).concat(skipped ? skippedMsg : '', "\n").concat(res).concat(other).concat(end).concat(indicator);
}
var AssertionError = /*#__PURE__*/function (_Error, _inspect$custom) {
  _inherits(AssertionError, _Error);
  var _super = _createSuper(AssertionError);
  function AssertionError(options) {
    var _this;
    _classCallCheck(this, AssertionError);
    if (_typeof(options) !== 'object' || options === null) {
      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
    }
    var message = options.message,
      operator = options.operator,
      stackStartFn = options.stackStartFn;
    var actual = options.actual,
      expected = options.expected;
    var limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    if (message != null) {
      _this = _super.call(this, String(message));
    } else {
      if (process.stderr && process.stderr.isTTY) {
        // Reset on each call to make sure we handle dynamically set environment
        // variables correct.
        if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
          blue = "\x1B[34m";
          green = "\x1B[32m";
          white = "\x1B[39m";
          red = "\x1B[31m";
        } else {
          blue = '';
          green = '';
          white = '';
          red = '';
        }
      }
      // Prevent the error stack from being visible by duplicating the error
      // in a very close way to the original in case both sides are actually
      // instances of Error.
      if (_typeof(actual) === 'object' && actual !== null && _typeof(expected) === 'object' && expected !== null && 'stack' in actual && actual instanceof Error && 'stack' in expected && expected instanceof Error) {
        actual = copyError(actual);
        expected = copyError(expected);
      }
      if (operator === 'deepStrictEqual' || operator === 'strictEqual') {
        _this = _super.call(this, createErrDiff(actual, expected, operator));
      } else if (operator === 'notDeepStrictEqual' || operator === 'notStrictEqual') {
        // In case the objects are equal but the operator requires unequal, show
        // the first object and say A equals B
        var base = kReadableOperator[operator];
        var res = inspectValue(actual).split('\n');

        // In case "actual" is an object, it should not be reference equal.
        if (operator === 'notStrictEqual' && _typeof(actual) === 'object' && actual !== null) {
          base = kReadableOperator.notStrictEqualObject;
        }

        // Only remove lines in case it makes sense to collapse those.
        // TODO: Accept env to always show the full error.
        if (res.length > 30) {
          res[26] = "".concat(blue, "...").concat(white);
          while (res.length > 27) {
            res.pop();
          }
        }

        // Only print a single input.
        if (res.length === 1) {
          _this = _super.call(this, "".concat(base, " ").concat(res[0]));
        } else {
          _this = _super.call(this, "".concat(base, "\n\n").concat(res.join('\n'), "\n"));
        }
      } else {
        var _res = inspectValue(actual);
        var other = '';
        var knownOperators = kReadableOperator[operator];
        if (operator === 'notDeepEqual' || operator === 'notEqual') {
          _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
          if (_res.length > 1024) {
            _res = "".concat(_res.slice(0, 1021), "...");
          }
        } else {
          other = "".concat(inspectValue(expected));
          if (_res.length > 512) {
            _res = "".concat(_res.slice(0, 509), "...");
          }
          if (other.length > 512) {
            other = "".concat(other.slice(0, 509), "...");
          }
          if (operator === 'deepEqual' || operator === 'equal') {
            _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
          } else {
            other = " ".concat(operator, " ").concat(other);
          }
        }
        _this = _super.call(this, "".concat(_res).concat(other));
      }
    }
    Error.stackTraceLimit = limit;
    _this.generatedMessage = !message;
    Object.defineProperty(_assertThisInitialized(_this), 'name', {
      value: 'AssertionError [ERR_ASSERTION]',
      enumerable: false,
      writable: true,
      configurable: true
    });
    _this.code = 'ERR_ASSERTION';
    _this.actual = actual;
    _this.expected = expected;
    _this.operator = operator;
    if (Error.captureStackTrace) {
      // eslint-disable-next-line no-restricted-syntax
      Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
    }
    // Create error message including the error code in the name.
    _this.stack;
    // Reset the name.
    _this.name = 'AssertionError';
    return _possibleConstructorReturn(_this);
  }
  _createClass(AssertionError, [{
    key: "toString",
    value: function toString() {
      return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
    }
  }, {
    key: _inspect$custom,
    value: function value(recurseTimes, ctx) {
      // This limits the `actual` and `expected` property default inspection to
      // the minimum depth. Otherwise those values would be too verbose compared
      // to the actual error message which contains a combined view of these two
      // input values.
      return inspect(this, _objectSpread(_objectSpread({}, ctx), {}, {
        customInspect: false,
        depth: 0
      }));
    }
  }]);
  return AssertionError;
}( /*#__PURE__*/_wrapNativeSuper(Error), inspect.custom);
module.exports = AssertionError;

}),
"./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/errors.js": 
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/errors.js ***!
  \**************************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";
// Currently in sync with Node.js lib/internal/errors.js
// https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f

/* eslint node-core/documented-errors: "error" */
/* eslint node-core/alphabetize-errors: "error" */
/* eslint node-core/prefer-util-format-errors: "error" */



// The whole point behind this internal module is to allow Node.js to no
// longer be forced to treat every error message change as a semver-major
// change. The NodeError classes here all expose a `code` property whose
// value statically and permanently identifies the error. While the error
// message may change, the code should not.
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var codes = {};

// Lazy loaded
var assert;
var util;
function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }
  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }
  var NodeError = /*#__PURE__*/function (_Base) {
    _inherits(NodeError, _Base);
    var _super = _createSuper(NodeError);
    function NodeError(arg1, arg2, arg3) {
      var _this;
      _classCallCheck(this, NodeError);
      _this = _super.call(this, getMessage(arg1, arg2, arg3));
      _this.code = code;
      return _this;
    }
    return _createClass(NodeError);
  }(Base);
  codes[code] = NodeError;
}

// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });
    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }
  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}
createErrorType('ERR_AMBIGUOUS_ARGUMENT', 'The "%s" argument is ambiguous. %s', TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  if (assert === undefined) assert = __webpack_require__(/*! ../assert */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js");
  assert(typeof name === 'string', "'name' must be a string");

  // determiner: 'must be' or 'must not be'
  var determiner;
  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }
  var msg;
  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  // TODO(BridgeAR): Improve the output by showing `null` and similar.
  msg += ". Received type ".concat(_typeof(actual));
  return msg;
}, TypeError);
createErrorType('ERR_INVALID_ARG_VALUE', function (name, value) {
  var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';
  if (util === undefined) util = __webpack_require__(/*! util/ */ "./node_modules/.pnpm/util@0.12.5/node_modules/util/util.js");
  var inspected = util.inspect(value);
  if (inspected.length > 128) {
    inspected = "".concat(inspected.slice(0, 128), "...");
  }
  return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
}, TypeError, RangeError);
createErrorType('ERR_INVALID_RETURN_VALUE', function (input, name, value) {
  var type;
  if (value && value.constructor && value.constructor.name) {
    type = "instance of ".concat(value.constructor.name);
  } else {
    type = "type ".concat(_typeof(value));
  }
  return "Expected ".concat(input, " to be returned from the \"").concat(name, "\"") + " function but got ".concat(type, ".");
}, TypeError);
createErrorType('ERR_MISSING_ARGS', function () {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (assert === undefined) assert = __webpack_require__(/*! ../assert */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js");
  assert(args.length > 0, 'At least one arg needs to be specified');
  var msg = 'The ';
  var len = args.length;
  args = args.map(function (a) {
    return "\"".concat(a, "\"");
  });
  switch (len) {
    case 1:
      msg += "".concat(args[0], " argument");
      break;
    case 2:
      msg += "".concat(args[0], " and ").concat(args[1], " arguments");
      break;
    default:
      msg += args.slice(0, len - 1).join(', ');
      msg += ", and ".concat(args[len - 1], " arguments");
      break;
  }
  return "".concat(msg, " must be specified");
}, TypeError);
module.exports.codes = codes;

}),
"./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/util/comparisons.js": 
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/internal/util/comparisons.js ***!
  \************************************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";
// Currently in sync with Node.js lib/internal/util/comparisons.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9



function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var regexFlagsSupported = /a/g.flags !== undefined;
var arrayFromSet = function arrayFromSet(set) {
  var array = [];
  set.forEach(function (value) {
    return array.push(value);
  });
  return array;
};
var arrayFromMap = function arrayFromMap(map) {
  var array = [];
  map.forEach(function (value, key) {
    return array.push([key, value]);
  });
  return array;
};
var objectIs = Object.is ? Object.is : __webpack_require__(/*! object-is */ "./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/index.js");
var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function () {
  return [];
};
var numberIsNaN = Number.isNaN ? Number.isNaN : __webpack_require__(/*! is-nan */ "./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/index.js");
function uncurryThis(f) {
  return f.call.bind(f);
}
var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
var objectToString = uncurryThis(Object.prototype.toString);
var _require$types = (__webpack_require__(/*! util/ */ "./node_modules/.pnpm/util@0.12.5/node_modules/util/util.js")/* .types */.types),
  isAnyArrayBuffer = _require$types.isAnyArrayBuffer,
  isArrayBufferView = _require$types.isArrayBufferView,
  isDate = _require$types.isDate,
  isMap = _require$types.isMap,
  isRegExp = _require$types.isRegExp,
  isSet = _require$types.isSet,
  isNativeError = _require$types.isNativeError,
  isBoxedPrimitive = _require$types.isBoxedPrimitive,
  isNumberObject = _require$types.isNumberObject,
  isStringObject = _require$types.isStringObject,
  isBooleanObject = _require$types.isBooleanObject,
  isBigIntObject = _require$types.isBigIntObject,
  isSymbolObject = _require$types.isSymbolObject,
  isFloat32Array = _require$types.isFloat32Array,
  isFloat64Array = _require$types.isFloat64Array;
function isNonIndex(key) {
  if (key.length === 0 || key.length > 10) return true;
  for (var i = 0; i < key.length; i++) {
    var code = key.charCodeAt(i);
    if (code < 48 || code > 57) return true;
  }
  // The maximum size for an array is 2 ** 32 -1.
  return key.length === 10 && key >= Math.pow(2, 32);
}
function getOwnNonIndexProperties(value) {
  return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
}

// Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }
  var x = a.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }
  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
var ONLY_ENUMERABLE = undefined;
var kStrict = true;
var kLoose = false;
var kNoIterator = 0;
var kIsArray = 1;
var kIsSet = 2;
var kIsMap = 3;

// Check if they have the same source and flags
function areSimilarRegExps(a, b) {
  return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
}
function areSimilarFloatArrays(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (var offset = 0; offset < a.byteLength; offset++) {
    if (a[offset] !== b[offset]) {
      return false;
    }
  }
  return true;
}
function areSimilarTypedArrays(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
}
function areEqualArrayBuffers(buf1, buf2) {
  return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}
function isEqualBoxedPrimitive(val1, val2) {
  if (isNumberObject(val1)) {
    return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
  }
  if (isStringObject(val1)) {
    return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
  }
  if (isBooleanObject(val1)) {
    return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
  }
  if (isBigIntObject(val1)) {
    return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
  }
  return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
}

// Notes: Type tags are historical [[Class]] properties that can be set by
// FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS
// and retrieved using Object.prototype.toString.call(obj) in JS
// See https://tc39.github.io/ecma262/#sec-object.prototype.tostring
// for a list of tags pre-defined in the spec.
// There are some unspecified tags in the wild too (e.g. typed array tags).
// Since tags can be altered, they only serve fast failures
//
// Typed arrays and buffers are checked by comparing the content in their
// underlying ArrayBuffer. This optimization requires that it's
// reasonable to interpret their underlying memory in the same way,
// which is checked by comparing their type tags.
// (e.g. a Uint8Array and a Uint16Array with the same memory content
// could still be different because they will be interpreted differently).
//
// For strict comparison, objects should have
// a) The same built-in type tags
// b) The same prototypes.

function innerDeepEqual(val1, val2, strict, memos) {
  // All identical values are equivalent, as determined by ===.
  if (val1 === val2) {
    if (val1 !== 0) return true;
    return strict ? objectIs(val1, val2) : true;
  }

  // Check more closely if val1 and val2 are equal.
  if (strict) {
    if (_typeof(val1) !== 'object') {
      return typeof val1 === 'number' && numberIsNaN(val1) && numberIsNaN(val2);
    }
    if (_typeof(val2) !== 'object' || val1 === null || val2 === null) {
      return false;
    }
    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
      return false;
    }
  } else {
    if (val1 === null || _typeof(val1) !== 'object') {
      if (val2 === null || _typeof(val2) !== 'object') {
        // eslint-disable-next-line eqeqeq
        return val1 == val2;
      }
      return false;
    }
    if (val2 === null || _typeof(val2) !== 'object') {
      return false;
    }
  }
  var val1Tag = objectToString(val1);
  var val2Tag = objectToString(val2);
  if (val1Tag !== val2Tag) {
    return false;
  }
  if (Array.isArray(val1)) {
    // Check for sparse arrays and general fast path
    if (val1.length !== val2.length) {
      return false;
    }
    var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
    var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
    if (keys1.length !== keys2.length) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
  }
  // [browserify] This triggers on certain types in IE (Map/Set) so we don't
  // wan't to early return out of the rest of the checks. However we can check
  // if the second value is one of these values and the first isn't.
  if (val1Tag === '[object Object]') {
    // return keyCheck(val1, val2, strict, memos, kNoIterator);
    if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
      return false;
    }
  }
  if (isDate(val1)) {
    if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
      return false;
    }
  } else if (isRegExp(val1)) {
    if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
      return false;
    }
  } else if (isNativeError(val1) || val1 instanceof Error) {
    // Do not compare the stack as it might differ even though the error itself
    // is otherwise identical.
    if (val1.message !== val2.message || val1.name !== val2.name) {
      return false;
    }
  } else if (isArrayBufferView(val1)) {
    if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
      if (!areSimilarFloatArrays(val1, val2)) {
        return false;
      }
    } else if (!areSimilarTypedArrays(val1, val2)) {
      return false;
    }
    // Buffer.compare returns true, so val1.length === val2.length. If they both
    // only contain numeric keys, we don't need to exam further than checking
    // the symbols.
    var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
    var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
    if (_keys.length !== _keys2.length) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
  } else if (isSet(val1)) {
    if (!isSet(val2) || val1.size !== val2.size) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, kIsSet);
  } else if (isMap(val1)) {
    if (!isMap(val2) || val1.size !== val2.size) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, kIsMap);
  } else if (isAnyArrayBuffer(val1)) {
    if (!areEqualArrayBuffers(val1, val2)) {
      return false;
    }
  } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
    return false;
  }
  return keyCheck(val1, val2, strict, memos, kNoIterator);
}
function getEnumerables(val, keys) {
  return keys.filter(function (k) {
    return propertyIsEnumerable(val, k);
  });
}
function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
  // For all remaining Object pairs, including Array, objects and Maps,
  // equivalence is determined by having:
  // a) The same number of owned enumerable properties
  // b) The same set of keys/indexes (although not necessarily the same order)
  // c) Equivalent values for every corresponding key/index
  // d) For Sets and Maps, equal contents
  // Note: this accounts for both named and indexed properties on Arrays.
  if (arguments.length === 5) {
    aKeys = Object.keys(val1);
    var bKeys = Object.keys(val2);

    // The pair must have the same number of owned properties.
    if (aKeys.length !== bKeys.length) {
      return false;
    }
  }

  // Cheap key test
  var i = 0;
  for (; i < aKeys.length; i++) {
    if (!hasOwnProperty(val2, aKeys[i])) {
      return false;
    }
  }
  if (strict && arguments.length === 5) {
    var symbolKeysA = objectGetOwnPropertySymbols(val1);
    if (symbolKeysA.length !== 0) {
      var count = 0;
      for (i = 0; i < symbolKeysA.length; i++) {
        var key = symbolKeysA[i];
        if (propertyIsEnumerable(val1, key)) {
          if (!propertyIsEnumerable(val2, key)) {
            return false;
          }
          aKeys.push(key);
          count++;
        } else if (propertyIsEnumerable(val2, key)) {
          return false;
        }
      }
      var symbolKeysB = objectGetOwnPropertySymbols(val2);
      if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
        return false;
      }
    } else {
      var _symbolKeysB = objectGetOwnPropertySymbols(val2);
      if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
        return false;
      }
    }
  }
  if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
    return true;
  }

  // Use memos to handle cycles.
  if (memos === undefined) {
    memos = {
      val1: new Map(),
      val2: new Map(),
      position: 0
    };
  } else {
    // We prevent up to two map.has(x) calls by directly retrieving the value
    // and checking for undefined. The map can only contain numbers, so it is
    // safe to check for undefined only.
    var val2MemoA = memos.val1.get(val1);
    if (val2MemoA !== undefined) {
      var val2MemoB = memos.val2.get(val2);
      if (val2MemoB !== undefined) {
        return val2MemoA === val2MemoB;
      }
    }
    memos.position++;
  }
  memos.val1.set(val1, memos.position);
  memos.val2.set(val2, memos.position);
  var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
  memos.val1.delete(val1);
  memos.val2.delete(val2);
  return areEq;
}
function setHasEqualElement(set, val1, strict, memo) {
  // Go looking.
  var setValues = arrayFromSet(set);
  for (var i = 0; i < setValues.length; i++) {
    var val2 = setValues[i];
    if (innerDeepEqual(val1, val2, strict, memo)) {
      // Remove the matching element to make sure we do not check that again.
      set.delete(val2);
      return true;
    }
  }
  return false;
}

// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using
// Sadly it is not possible to detect corresponding values properly in case the
// type is a string, number, bigint or boolean. The reason is that those values
// can match lots of different string values (e.g., 1n == '+00001').
function findLooseMatchingPrimitives(prim) {
  switch (_typeof(prim)) {
    case 'undefined':
      return null;
    case 'object':
      // Only pass in null as object!
      return undefined;
    case 'symbol':
      return false;
    case 'string':
      prim = +prim;
    // Loose equal entries exist only if the string is possible to convert to
    // a regular number and not NaN.
    // Fall through
    case 'number':
      if (numberIsNaN(prim)) {
        return false;
      }
  }
  return true;
}
function setMightHaveLoosePrim(a, b, prim) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) return altValue;
  return b.has(altValue) && !a.has(altValue);
}
function mapMightHaveLoosePrim(a, b, prim, item, memo) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) {
    return altValue;
  }
  var curB = b.get(altValue);
  if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
    return false;
  }
  return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
}
function setEquiv(a, b, strict, memo) {
  // This is a lazily initiated Set of entries which have to be compared
  // pairwise.
  var set = null;
  var aValues = arrayFromSet(a);
  for (var i = 0; i < aValues.length; i++) {
    var val = aValues[i];
    // Note: Checking for the objects first improves the performance for object
    // heavy sets but it is a minor slow down for primitives. As they are fast
    // to check this improves the worst case scenario instead.
    if (_typeof(val) === 'object' && val !== null) {
      if (set === null) {
        set = new Set();
      }
      // If the specified value doesn't exist in the second set its an not null
      // object (or non strict only: a not matching primitive) we'll need to go
      // hunting for something thats deep-(strict-)equal to it. To make this
      // O(n log n) complexity we have to copy these values in a new set first.
      set.add(val);
    } else if (!b.has(val)) {
      if (strict) return false;

      // Fast path to detect missing string, symbol, undefined and null values.
      if (!setMightHaveLoosePrim(a, b, val)) {
        return false;
      }
      if (set === null) {
        set = new Set();
      }
      set.add(val);
    }
  }
  if (set !== null) {
    var bValues = arrayFromSet(b);
    for (var _i = 0; _i < bValues.length; _i++) {
      var _val = bValues[_i];
      // We have to check if a primitive value is already
      // matching and only if it's not, go hunting for it.
      if (_typeof(_val) === 'object' && _val !== null) {
        if (!setHasEqualElement(set, _val, strict, memo)) return false;
      } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
        return false;
      }
    }
    return set.size === 0;
  }
  return true;
}
function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
  // To be able to handle cases like:
  //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])
  // ... we need to consider *all* matching keys, not just the first we find.
  var setValues = arrayFromSet(set);
  for (var i = 0; i < setValues.length; i++) {
    var key2 = setValues[i];
    if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
      set.delete(key2);
      return true;
    }
  }
  return false;
}
function mapEquiv(a, b, strict, memo) {
  var set = null;
  var aEntries = arrayFromMap(a);
  for (var i = 0; i < aEntries.length; i++) {
    var _aEntries$i = _slicedToArray(aEntries[i], 2),
      key = _aEntries$i[0],
      item1 = _aEntries$i[1];
    if (_typeof(key) === 'object' && key !== null) {
      if (set === null) {
        set = new Set();
      }
      set.add(key);
    } else {
      // By directly retrieving the value we prevent another b.has(key) check in
      // almost all possible cases.
      var item2 = b.get(key);
      if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
        if (strict) return false;
        // Fast path to detect missing string, symbol, undefined and null
        // keys.
        if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;
        if (set === null) {
          set = new Set();
        }
        set.add(key);
      }
    }
  }
  if (set !== null) {
    var bEntries = arrayFromMap(b);
    for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
      var _bEntries$_i = _slicedToArray(bEntries[_i2], 2),
        _key = _bEntries$_i[0],
        item = _bEntries$_i[1];
      if (_typeof(_key) === 'object' && _key !== null) {
        if (!mapHasEqualEntry(set, a, _key, item, strict, memo)) return false;
      } else if (!strict && (!a.has(_key) || !innerDeepEqual(a.get(_key), item, false, memo)) && !mapHasEqualEntry(set, a, _key, item, false, memo)) {
        return false;
      }
    }
    return set.size === 0;
  }
  return true;
}
function objEquiv(a, b, strict, keys, memos, iterationType) {
  // Sets and maps don't have their entries accessible via normal object
  // properties.
  var i = 0;
  if (iterationType === kIsSet) {
    if (!setEquiv(a, b, strict, memos)) {
      return false;
    }
  } else if (iterationType === kIsMap) {
    if (!mapEquiv(a, b, strict, memos)) {
      return false;
    }
  } else if (iterationType === kIsArray) {
    for (; i < a.length; i++) {
      if (hasOwnProperty(a, i)) {
        if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
          return false;
        }
      } else if (hasOwnProperty(b, i)) {
        return false;
      } else {
        // Array is sparse.
        var keysA = Object.keys(a);
        for (; i < keysA.length; i++) {
          var key = keysA[i];
          if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
            return false;
          }
        }
        if (keysA.length !== Object.keys(b).length) {
          return false;
        }
        return true;
      }
    }
  }

  // The pair must have equivalent values for every corresponding key.
  // Possibly expensive deep test:
  for (i = 0; i < keys.length; i++) {
    var _key2 = keys[i];
    if (!innerDeepEqual(a[_key2], b[_key2], strict, memos)) {
      return false;
    }
  }
  return true;
}
function isDeepEqual(val1, val2) {
  return innerDeepEqual(val1, val2, kLoose);
}
function isDeepStrictEqual(val1, val2) {
  return innerDeepEqual(val1, val2, kStrict);
}
module.exports = {
  isDeepEqual: isDeepEqual,
  isDeepStrictEqual: isDeepStrictEqual
};

}),
"./node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js": 
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js ***!
  \****************************************************************************/
(function (__unused_webpack_module, exports) {
"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


}),
"./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js": 
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js ***!
  \**********************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/.pnpm/console-browserify@1.2.0/node_modules/console-browserify/index.js */ "./node_modules/.pnpm/console-browserify@1.2.0/node_modules/console-browserify/index.js");
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



const base64 = __webpack_require__(/*! base64-js */ "./node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js")
const ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js")
const customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

const K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    const arr = new Uint8Array(1)
    const proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  const buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  const valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  const b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  const length = byteLength(string, encoding) | 0
  let buf = createBuffer(length)

  const actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  const length = array.length < 0 ? 0 : checked(array.length) | 0
  const buf = createBuffer(length)
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayView (arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    const copy = new Uint8Array(arrayView)
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  }
  return fromArrayLike(arrayView)
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  let buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    const len = checked(obj.length) | 0
    const buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  let x = a.length
  let y = b.length

  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  let i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  const buffer = Buffer.allocUnsafe(length)
  let pos = 0
  for (i = 0; i < list.length; ++i) {
    let buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)
        buf.copy(buffer, pos)
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos)
    }
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  const len = string.length
  const mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  let loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  const i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  const len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (let i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  const len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (let i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  const len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (let i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  const length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  let str = ''
  const max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  let x = thisEnd - thisStart
  let y = end - start
  const len = Math.min(x, y)

  const thisCopy = this.slice(thisStart, thisEnd)
  const targetCopy = target.slice(start, end)

  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  let indexSize = 1
  let arrLength = arr.length
  let valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  let i
  if (dir) {
    let foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      let found = true
      for (let j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  const remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  const strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  let i
  for (i = 0; i < length; ++i) {
    const parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  const remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  const res = []

  let i = start
  while (i < end) {
    const firstByte = buf[i]
    let codePoint = null
    let bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  const len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  let res = ''
  let i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  const len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  let out = ''
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  const bytes = buf.slice(start, end)
  let res = ''
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  const len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  const newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUintLE =
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUintBE =
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  let val = this[offset + --byteLength]
  let mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUint8 =
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUint16LE =
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUint16BE =
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUint32LE =
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUint32BE =
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const lo = first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24

  const hi = this[++offset] +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    last * 2 ** 24

  return BigInt(lo) + (BigInt(hi) << BigInt(32))
})

Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const hi = first * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  const lo = this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last

  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
})

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let i = byteLength
  let mul = 1
  let val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = this[offset + 4] +
    this[offset + 5] * 2 ** 8 +
    this[offset + 6] * 2 ** 16 +
    (last << 24) // Overflow

  return (BigInt(val) << BigInt(32)) +
    BigInt(first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24)
})

Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  return (BigInt(val) << BigInt(32)) +
    BigInt(this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last)
})

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUintLE =
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let mul = 1
  let i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUintBE =
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let i = byteLength - 1
  let mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUint8 =
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUint16LE =
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUint16BE =
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUint32LE =
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUint32BE =
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function wrtBigUInt64LE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  return offset
}

function wrtBigUInt64BE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset + 7] = lo
  lo = lo >> 8
  buf[offset + 6] = lo
  lo = lo >> 8
  buf[offset + 5] = lo
  lo = lo >> 8
  buf[offset + 4] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset + 3] = hi
  hi = hi >> 8
  buf[offset + 2] = hi
  hi = hi >> 8
  buf[offset + 1] = hi
  hi = hi >> 8
  buf[offset] = hi
  return offset + 8
}

Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = 0
  let mul = 1
  let sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = byteLength - 1
  let mul = 1
  let sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  const len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      const code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  let i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    const bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    const len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// CUSTOM ERRORS
// =============

// Simplified versions from Node, changed for Buffer-only usage
const errors = {}
function E (sym, getMessage, Base) {
  errors[sym] = class NodeError extends Base {
    constructor () {
      super()

      Object.defineProperty(this, 'message', {
        value: getMessage.apply(this, arguments),
        writable: true,
        configurable: true
      })

      // Add the error code to the name to include it in the stack trace.
      this.name = `${this.name} [${sym}]`
      // Access the stack to generate the error message including the error code
      // from the name.
      this.stack // eslint-disable-line no-unused-expressions
      // Reset the name to the actual name.
      delete this.name
    }

    get code () {
      return sym
    }

    set code (value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true
      })
    }

    toString () {
      return `${this.name} [${sym}]: ${this.message}`
    }
  }
}

E('ERR_BUFFER_OUT_OF_BOUNDS',
  function (name) {
    if (name) {
      return `${name} is outside of buffer bounds`
    }

    return 'Attempt to access memory outside buffer bounds'
  }, RangeError)
E('ERR_INVALID_ARG_TYPE',
  function (name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
  }, TypeError)
E('ERR_OUT_OF_RANGE',
  function (str, range, input) {
    let msg = `The value of "${str}" is out of range.`
    let received = input
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input))
    } else if (typeof input === 'bigint') {
      received = String(input)
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received)
      }
      received += 'n'
    }
    msg += ` It must be ${range}. Received ${received}`
    return msg
  }, RangeError)

function addNumericalSeparator (val) {
  let res = ''
  let i = val.length
  const start = val[0] === '-' ? 1 : 0
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`
  }
  return `${val.slice(0, i)}${res}`
}

// CHECK FUNCTIONS
// ===============

function checkBounds (buf, offset, byteLength) {
  validateNumber(offset, 'offset')
  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1))
  }
}

function checkIntBI (value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    const n = typeof min === 'bigint' ? 'n' : ''
    let range
    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
      } else {
        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                `${(byteLength + 1) * 8 - 1}${n}`
      }
    } else {
      range = `>= ${min}${n} and <= ${max}${n}`
    }
    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
  }
  checkBounds(buf, offset, byteLength)
}

function validateNumber (value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
  }
}

function boundsError (value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type)
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
  }

  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
  }

  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
                                    `>= ${type ? 1 : 0} and <= ${length}`,
                                    value)
}

// HELPER FUNCTIONS
// ================

const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  let codePoint
  const length = string.length
  let leadSurrogate = null
  const bytes = []

  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  let c, hi, lo
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  let i
  for (i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = (function () {
  const alphabet = '0123456789abcdef'
  const table = new Array(256)
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16
    for (let j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

// Return not function with Error if BigInt not supported
function defineBigIntMethod (fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
}

function BufferBigIntNotDefined () {
  throw new Error('BigInt not supported')
}


}),
"./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js": 
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js ***!
  \**************************************************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js");

var $apply = __webpack_require__(/*! ./functionApply */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js");
var $call = __webpack_require__(/*! ./functionCall */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js");
var $reflectApply = __webpack_require__(/*! ./reflectApply */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js");

/** @type {import('./actualApply')} */
module.exports = $reflectApply || bind.call($call, $apply);


}),
"./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/applyBind.js": 
/*!************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/applyBind.js ***!
  \************************************************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js");
var $apply = __webpack_require__(/*! ./functionApply */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js");
var actualApply = __webpack_require__(/*! ./actualApply */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js");

/** @type {import('./applyBind')} */
module.exports = function applyBind() {
	return actualApply(bind, $apply, arguments);
};


}),
"./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js": 
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js ***!
  \****************************************************************************************************************/
(function (module) {
"use strict";


/** @type {import('./functionApply')} */
module.exports = Function.prototype.apply;


}),
"./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js": 
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js ***!
  \***************************************************************************************************************/
(function (module) {
"use strict";


/** @type {import('./functionCall')} */
module.exports = Function.prototype.call;


}),
"./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js": 
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js ***!
  \********************************************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js");
var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");

var $call = __webpack_require__(/*! ./functionCall */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js");
var $actualApply = __webpack_require__(/*! ./actualApply */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js");

/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */
module.exports = function callBindBasic(args) {
	if (args.length < 1 || typeof args[0] !== 'function') {
		throw new $TypeError('a function is required');
	}
	return $actualApply(bind, $call, args);
};


}),
"./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js": 
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js ***!
  \***************************************************************************************************************/
(function (module) {
"use strict";


/** @type {import('./reflectApply')} */
module.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;


}),
"./node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/callBound.js": 
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/callBound.js ***!
  \********************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js");

var callBind = __webpack_require__(/*! ./ */ "./node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/index.js");

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};


}),
"./node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/index.js": 
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/index.js ***!
  \****************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var setFunctionLength = __webpack_require__(/*! set-function-length */ "./node_modules/.pnpm/set-function-length@1.2.2/node_modules/set-function-length/index.js");

var $defineProperty = __webpack_require__(/*! es-define-property */ "./node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js");

var callBindBasic = __webpack_require__(/*! call-bind-apply-helpers */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js");
var applyBind = __webpack_require__(/*! call-bind-apply-helpers/applyBind */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/applyBind.js");

module.exports = function callBind(originalFunction) {
	var func = callBindBasic(arguments);
	var adjustedLength = originalFunction.length - (arguments.length - 1);
	return setFunctionLength(
		func,
		1 + (adjustedLength > 0 ? adjustedLength : 0),
		true
	);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}


}),
"./node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js": 
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js ***!
  \******************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js");

var callBindBasic = __webpack_require__(/*! call-bind-apply-helpers */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js");

/** @type {(thisArg: string, searchString: string, position?: number) => number} */
var $indexOf = callBindBasic([GetIntrinsic('%String.prototype.indexOf%')]);

/** @type {import('.')} */
module.exports = function callBoundIntrinsic(name, allowMissing) {
	/* eslint no-extra-parens: 0 */

	var intrinsic = /** @type {(this: unknown, ...args: unknown[]) => unknown} */ (GetIntrinsic(name, !!allowMissing));
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBindBasic(/** @type {const} */ ([intrinsic]));
	}
	return intrinsic;
};


}),
"./node_modules/.pnpm/console-browserify@1.2.0/node_modules/console-browserify/index.js": 
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/console-browserify@1.2.0/node_modules/console-browserify/index.js ***!
  \**********************************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
/*global window, global*/
var util = __webpack_require__(/*! util */ "./node_modules/.pnpm/util@0.12.5/node_modules/util/util.js")
var assert = __webpack_require__(/*! assert */ "./node_modules/.pnpm/assert@2.1.0/node_modules/assert/build/assert.js")
function now() { return new Date().getTime() }

var slice = Array.prototype.slice
var console
var times = {}

if (typeof __webpack_require__.g !== "undefined" && __webpack_require__.g.console) {
    console = __webpack_require__.g.console
} else if (typeof window !== "undefined" && window.console) {
    console = window.console
} else {
    console = {}
}

var functions = [
    [log, "log"],
    [info, "info"],
    [warn, "warn"],
    [error, "error"],
    [time, "time"],
    [timeEnd, "timeEnd"],
    [trace, "trace"],
    [dir, "dir"],
    [consoleAssert, "assert"]
]

for (var i = 0; i < functions.length; i++) {
    var tuple = functions[i]
    var f = tuple[0]
    var name = tuple[1]

    if (!console[name]) {
        console[name] = f
    }
}

module.exports = console

function log() {}

function info() {
    console.log.apply(console, arguments)
}

function warn() {
    console.log.apply(console, arguments)
}

function error() {
    console.warn.apply(console, arguments)
}

function time(label) {
    times[label] = now()
}

function timeEnd(label) {
    var time = times[label]
    if (!time) {
        throw new Error("No such label: " + label)
    }

    delete times[label]
    var duration = now() - time
    console.log(label + ": " + duration + "ms")
}

function trace() {
    var err = new Error()
    err.name = "Trace"
    err.message = util.format.apply(null, arguments)
    console.error(err.stack)
}

function dir(object) {
    console.log(util.inspect(object) + "\n")
}

function consoleAssert(expression) {
    if (!expression) {
        var arr = slice.call(arguments, 1)
        assert.ok(false, util.format.apply(null, arr))
    }
}


}),
"./node_modules/.pnpm/define-data-property@1.1.4/node_modules/define-data-property/index.js": 
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/define-data-property@1.1.4/node_modules/define-data-property/index.js ***!
  \**************************************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var $defineProperty = __webpack_require__(/*! es-define-property */ "./node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js");

var $SyntaxError = __webpack_require__(/*! es-errors/syntax */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js");
var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");

var gopd = __webpack_require__(/*! gopd */ "./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js");

/** @type {import('.')} */
module.exports = function defineDataProperty(
	obj,
	property,
	value
) {
	if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
		throw new $TypeError('`obj` must be an object or a function`');
	}
	if (typeof property !== 'string' && typeof property !== 'symbol') {
		throw new $TypeError('`property` must be a string or a symbol`');
	}
	if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
		throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
		throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
		throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
		throw new $TypeError('`loose`, if provided, must be a boolean');
	}

	var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
	var nonWritable = arguments.length > 4 ? arguments[4] : null;
	var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
	var loose = arguments.length > 6 ? arguments[6] : false;

	/* @type {false | TypedPropertyDescriptor<unknown>} */
	var desc = !!gopd && gopd(obj, property);

	if ($defineProperty) {
		$defineProperty(obj, property, {
			configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
			enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
			value: value,
			writable: nonWritable === null && desc ? desc.writable : !nonWritable
		});
	} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {
		// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
		obj[property] = value; // eslint-disable-line no-param-reassign
	} else {
		throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
	}
};


}),
"./node_modules/.pnpm/define-properties@1.2.1/node_modules/define-properties/index.js": 
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/define-properties@1.2.1/node_modules/define-properties/index.js ***!
  \********************************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var keys = __webpack_require__(/*! object-keys */ "./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/index.js");
var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var defineDataProperty = __webpack_require__(/*! define-data-property */ "./node_modules/.pnpm/define-data-property@1.1.4/node_modules/define-data-property/index.js");

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var supportsDescriptors = __webpack_require__(/*! has-property-descriptors */ "./node_modules/.pnpm/has-property-descriptors@1.0.2/node_modules/has-property-descriptors/index.js")();

var defineProperty = function (object, name, value, predicate) {
	if (name in object) {
		if (predicate === true) {
			if (object[name] === value) {
				return;
			}
		} else if (!isFunction(predicate) || !predicate()) {
			return;
		}
	}

	if (supportsDescriptors) {
		defineDataProperty(object, name, value, true);
	} else {
		defineDataProperty(object, name, value);
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = concat.call(props, Object.getOwnPropertySymbols(map));
	}
	for (var i = 0; i < props.length; i += 1) {
		defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
	}
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;


}),
"./node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js": 
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js ***!
  \********************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var callBind = __webpack_require__(/*! call-bind-apply-helpers */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js");
var gOPD = __webpack_require__(/*! gopd */ "./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js");

var hasProtoAccessor;
try {
	// eslint-disable-next-line no-extra-parens, no-proto
	hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ ([]).__proto__ === Array.prototype;
} catch (e) {
	if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
		throw e;
	}
}

// eslint-disable-next-line no-extra-parens
var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */ ('__proto__'));

var $Object = Object;
var $getPrototypeOf = $Object.getPrototypeOf;

/** @type {import('./get')} */
module.exports = desc && typeof desc.get === 'function'
	? callBind([desc.get])
	: typeof $getPrototypeOf === 'function'
		? /** @type {import('./get')} */ function getDunder(value) {
			// eslint-disable-next-line eqeqeq
			return $getPrototypeOf(value == null ? value : $Object(value));
		}
		: false;


}),
"./node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js": 
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js ***!
  \**********************************************************************************************/
(function (module) {
"use strict";


/** @type {import('.')} */
var $defineProperty = Object.defineProperty || false;
if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = false;
	}
}

module.exports = $defineProperty;


}),
"./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js": 
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js ***!
  \***************************************************************************/
(function (module) {
"use strict";


/** @type {import('./eval')} */
module.exports = EvalError;


}),
"./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js": 
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js ***!
  \****************************************************************************/
(function (module) {
"use strict";


/** @type {import('.')} */
module.exports = Error;


}),
"./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js": 
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js ***!
  \****************************************************************************/
(function (module) {
"use strict";


/** @type {import('./range')} */
module.exports = RangeError;


}),
"./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js": 
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js ***!
  \**************************************************************************/
(function (module) {
"use strict";


/** @type {import('./ref')} */
module.exports = ReferenceError;


}),
"./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js": 
/*!*****************************************************************************!*\
  !*** ./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js ***!
  \*****************************************************************************/
(function (module) {
"use strict";


/** @type {import('./syntax')} */
module.exports = SyntaxError;


}),
"./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js": 
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js ***!
  \***************************************************************************/
(function (module) {
"use strict";


/** @type {import('./type')} */
module.exports = TypeError;


}),
"./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js": 
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js ***!
  \**************************************************************************/
(function (module) {
"use strict";


/** @type {import('./uri')} */
module.exports = URIError;


}),
"./node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js": 
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js ***!
  \****************************************************************************************/
(function (module) {
"use strict";


/** @type {import('.')} */
module.exports = Object;


}),
"./node_modules/.pnpm/for-each@0.3.5/node_modules/for-each/index.js": 
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/for-each@0.3.5/node_modules/for-each/index.js ***!
  \**************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var isCallable = __webpack_require__(/*! is-callable */ "./node_modules/.pnpm/is-callable@1.2.7/node_modules/is-callable/index.js");

var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

/** @type {<This, A extends readonly unknown[]>(arr: A, iterator: (this: This | void, value: A[number], index: number, arr: A) => void, receiver: This | undefined) => void} */
var forEachArray = function forEachArray(array, iterator, receiver) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            if (receiver == null) {
                iterator(array[i], i, array);
            } else {
                iterator.call(receiver, array[i], i, array);
            }
        }
    }
};

/** @type {<This, S extends string>(string: S, iterator: (this: This | void, value: S[number], index: number, string: S) => void, receiver: This | undefined) => void} */
var forEachString = function forEachString(string, iterator, receiver) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        if (receiver == null) {
            iterator(string.charAt(i), i, string);
        } else {
            iterator.call(receiver, string.charAt(i), i, string);
        }
    }
};

/** @type {<This, O>(obj: O, iterator: (this: This | void, value: O[keyof O], index: keyof O, obj: O) => void, receiver: This | undefined) => void} */
var forEachObject = function forEachObject(object, iterator, receiver) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
                iterator(object[k], k, object);
            } else {
                iterator.call(receiver, object[k], k, object);
            }
        }
    }
};

/** @type {(x: unknown) => x is readonly unknown[]} */
function isArray(x) {
    return toStr.call(x) === '[object Array]';
}

/** @type {import('.')._internal} */
module.exports = function forEach(list, iterator, thisArg) {
    if (!isCallable(iterator)) {
        throw new TypeError('iterator must be a function');
    }

    var receiver;
    if (arguments.length >= 3) {
        receiver = thisArg;
    }

    if (isArray(list)) {
        forEachArray(list, iterator, receiver);
    } else if (typeof list === 'string') {
        forEachString(list, iterator, receiver);
    } else {
        forEachObject(list, iterator, receiver);
    }
};


}),
"./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js": 
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js ***!
  \*********************************************************************************************/
(function (module) {
"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';

var concatty = function concatty(a, b) {
    var arr = [];

    for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
    }

    return arr;
};

var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
    }
    return arr;
};

var joiny = function (arr, joiner) {
    var str = '';
    for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                concatty(args, arguments)
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(
            that,
            concatty(args, arguments)
        );

    };

    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = '$' + i;
    }

    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


}),
"./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js": 
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js ***!
  \************************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js");

module.exports = Function.prototype.bind || implementation;


}),
"./node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js": 
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js ***!
  \************************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var undefined;

var $Object = __webpack_require__(/*! es-object-atoms */ "./node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js");

var $Error = __webpack_require__(/*! es-errors */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js");
var $EvalError = __webpack_require__(/*! es-errors/eval */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js");
var $RangeError = __webpack_require__(/*! es-errors/range */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js");
var $ReferenceError = __webpack_require__(/*! es-errors/ref */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js");
var $SyntaxError = __webpack_require__(/*! es-errors/syntax */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js");
var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");
var $URIError = __webpack_require__(/*! es-errors/uri */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js");

var abs = __webpack_require__(/*! math-intrinsics/abs */ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js");
var floor = __webpack_require__(/*! math-intrinsics/floor */ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js");
var max = __webpack_require__(/*! math-intrinsics/max */ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js");
var min = __webpack_require__(/*! math-intrinsics/min */ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js");
var pow = __webpack_require__(/*! math-intrinsics/pow */ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js");
var round = __webpack_require__(/*! math-intrinsics/round */ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js");
var sign = __webpack_require__(/*! math-intrinsics/sign */ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js");

var $Function = Function;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = __webpack_require__(/*! gopd */ "./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js");
var $defineProperty = __webpack_require__(/*! es-define-property */ "./node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js");

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js")();

var getProto = __webpack_require__(/*! get-proto */ "./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js");
var $ObjectGPO = __webpack_require__(/*! get-proto/Object.getPrototypeOf */ "./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js");
var $ReflectGPO = __webpack_require__(/*! get-proto/Reflect.getPrototypeOf */ "./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js");

var $apply = __webpack_require__(/*! call-bind-apply-helpers/functionApply */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js");
var $call = __webpack_require__(/*! call-bind-apply-helpers/functionCall */ "./node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js");

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	__proto__: null,
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': $Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': $EvalError,
	'%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': $Object,
	'%Object.getOwnPropertyDescriptor%': $gOPD,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': $RangeError,
	'%ReferenceError%': $ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': $URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,

	'%Function.prototype.call%': $call,
	'%Function.prototype.apply%': $apply,
	'%Object.defineProperty%': $defineProperty,
	'%Object.getPrototypeOf%': $ObjectGPO,
	'%Math.abs%': abs,
	'%Math.floor%': floor,
	'%Math.max%': max,
	'%Math.min%': min,
	'%Math.pow%': pow,
	'%Math.round%': round,
	'%Math.sign%': sign,
	'%Reflect.getPrototypeOf%': $ReflectGPO
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	__proto__: null,
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(/*! function-bind */ "./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js");
var hasOwn = __webpack_require__(/*! hasown */ "./node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js");
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


}),
"./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js": 
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js ***!
  \********************************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var $Object = __webpack_require__(/*! es-object-atoms */ "./node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js");

/** @type {import('./Object.getPrototypeOf')} */
module.exports = $Object.getPrototypeOf || null;


}),
"./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js": 
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js ***!
  \*********************************************************************************************/
(function (module) {
"use strict";


/** @type {import('./Reflect.getPrototypeOf')} */
module.exports = (typeof Reflect !== 'undefined' && Reflect.getPrototypeOf) || null;


}),
"./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js": 
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js ***!
  \****************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var reflectGetProto = __webpack_require__(/*! ./Reflect.getPrototypeOf */ "./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js");
var originalGetProto = __webpack_require__(/*! ./Object.getPrototypeOf */ "./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js");

var getDunderProto = __webpack_require__(/*! dunder-proto/get */ "./node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js");

/** @type {import('.')} */
module.exports = reflectGetProto
	? function getProto(O) {
		// @ts-expect-error TS can't narrow inside a closure, for some reason
		return reflectGetProto(O);
	}
	: originalGetProto
		? function getProto(O) {
			if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
				throw new TypeError('getProto: not an object');
			}
			// @ts-expect-error TS can't narrow inside a closure, for some reason
			return originalGetProto(O);
		}
		: getDunderProto
			? function getProto(O) {
				// @ts-expect-error TS can't narrow inside a closure, for some reason
				return getDunderProto(O);
			}
			: null;


}),
"./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js": 
/*!*****************************************************************!*\
  !*** ./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js ***!
  \*****************************************************************/
(function (module) {
"use strict";


/** @type {import('./gOPD')} */
module.exports = Object.getOwnPropertyDescriptor;


}),
"./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js": 
/*!******************************************************************!*\
  !*** ./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js ***!
  \******************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


/** @type {import('.')} */
var $gOPD = __webpack_require__(/*! ./gOPD */ "./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js");

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


}),
"./node_modules/.pnpm/has-property-descriptors@1.0.2/node_modules/has-property-descriptors/index.js": 
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/has-property-descriptors@1.0.2/node_modules/has-property-descriptors/index.js ***!
  \**********************************************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var $defineProperty = __webpack_require__(/*! es-define-property */ "./node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js");

var hasPropertyDescriptors = function hasPropertyDescriptors() {
	return !!$defineProperty;
};

hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
	// node v0.6 has a bug where array lengths can be Set but not Defined
	if (!$defineProperty) {
		return null;
	}
	try {
		return $defineProperty([], 'length', { value: 1 }).length !== 1;
	} catch (e) {
		// In Firefox 4-22, defining length on an array throws an exception.
		return true;
	}
};

module.exports = hasPropertyDescriptors;


}),
"./node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js": 
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js ***!
  \********************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(/*! ./shams */ "./node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js");

/** @type {import('.')} */
module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


}),
"./node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js": 
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js ***!
  \********************************************************************************/
(function (module) {
"use strict";


/** @type {import('./shams')} */
/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	/** @type {{ [k in symbol]?: unknown }} */
	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (var _ in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		// eslint-disable-next-line no-extra-parens
		var descriptor = /** @type {PropertyDescriptor} */ (Object.getOwnPropertyDescriptor(obj, sym));
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


}),
"./node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js": 
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js ***!
  \****************************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var hasSymbols = __webpack_require__(/*! has-symbols/shams */ "./node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js");

/** @type {import('.')} */
module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};


}),
"./node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js": 
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js ***!
  \**********************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __webpack_require__(/*! function-bind */ "./node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js");

/** @type {import('.')} */
module.exports = bind.call(call, $hasOwn);


}),
"./node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js": 
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js ***!
  \************************************************************************/
(function (__unused_webpack_module, exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


}),
"./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js": 
/*!*************************************************************************************!*\
  !*** ./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js ***!
  \*************************************************************************************/
(function (module) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


}),
"./node_modules/.pnpm/is-arguments@1.2.0/node_modules/is-arguments/index.js": 
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/is-arguments@1.2.0/node_modules/is-arguments/index.js ***!
  \**********************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js")();
var callBound = __webpack_require__(/*! call-bound */ "./node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js");

var $toString = callBound('Object.prototype.toString');

/** @type {import('.')} */
var isStandardArguments = function isArguments(value) {
	if (
		hasToStringTag
		&& value
		&& typeof value === 'object'
		&& Symbol.toStringTag in value
	) {
		return false;
	}
	return $toString(value) === '[object Arguments]';
};

/** @type {import('.')} */
var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null
		&& typeof value === 'object'
		&& 'length' in value
		&& typeof value.length === 'number'
		&& value.length >= 0
		&& $toString(value) !== '[object Array]'
		&& 'callee' in value
		&& $toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

// @ts-expect-error TODO make this not error
isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

/** @type {import('.')} */
module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;


}),
"./node_modules/.pnpm/is-callable@1.2.7/node_modules/is-callable/index.js": 
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/is-callable@1.2.7/node_modules/is-callable/index.js ***!
  \********************************************************************************/
(function (module) {
"use strict";


var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
	try {
		badArrayLike = Object.defineProperty({}, 'length', {
			get: function () {
				throw isCallableMarker;
			}
		});
		isCallableMarker = {};
		// eslint-disable-next-line no-throw-literal
		reflectApply(function () { throw 42; }, null, badArrayLike);
	} catch (_) {
		if (_ !== isCallableMarker) {
			reflectApply = null;
		}
	}
} else {
	reflectApply = null;
}

var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
	try {
		var fnStr = fnToStr.call(value);
		return constructorRegex.test(fnStr);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionToStr(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var objectClass = '[object Object]';
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var ddaClass = '[object HTMLAllCollection]'; // IE 11
var ddaClass2 = '[object HTML document.all class]';
var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`

var isIE68 = !(0 in [,]); // eslint-disable-line no-sparse-arrays, comma-spacing

var isDDA = function isDocumentDotAll() { return false; };
if (typeof document === 'object') {
	// Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
	var all = document.all;
	if (toStr.call(all) === toStr.call(document.all)) {
		isDDA = function isDocumentDotAll(value) {
			/* globals document: false */
			// in IE 6-8, typeof document.all is "object" and it's truthy
			if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
				try {
					var str = toStr.call(value);
					return (
						str === ddaClass
						|| str === ddaClass2
						|| str === ddaClass3 // opera 12.16
						|| str === objectClass // IE 6-8
					) && value('') == null; // eslint-disable-line eqeqeq
				} catch (e) { /**/ }
			}
			return false;
		};
	}
}

module.exports = reflectApply
	? function isCallable(value) {
		if (isDDA(value)) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		try {
			reflectApply(value, null, badArrayLike);
		} catch (e) {
			if (e !== isCallableMarker) { return false; }
		}
		return !isES6ClassFn(value) && tryFunctionObject(value);
	}
	: function isCallable(value) {
		if (isDDA(value)) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		if (hasToStringTag) { return tryFunctionObject(value); }
		if (isES6ClassFn(value)) { return false; }
		var strClass = toStr.call(value);
		if (strClass !== fnClass && strClass !== genClass && !(/^\[object HTML/).test(strClass)) { return false; }
		return tryFunctionObject(value);
	};


}),
"./node_modules/.pnpm/is-generator-function@1.1.0/node_modules/is-generator-function/index.js": 
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/is-generator-function@1.1.0/node_modules/is-generator-function/index.js ***!
  \****************************************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var callBound = __webpack_require__(/*! call-bound */ "./node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js");
var safeRegexTest = __webpack_require__(/*! safe-regex-test */ "./node_modules/.pnpm/safe-regex-test@1.1.0/node_modules/safe-regex-test/index.js");
var isFnRegex = safeRegexTest(/^\s*(?:function)?\*/);
var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js")();
var getProto = __webpack_require__(/*! get-proto */ "./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js");

var toStr = callBound('Object.prototype.toString');
var fnToStr = callBound('Function.prototype.toString');

var getGeneratorFunc = function () { // eslint-disable-line consistent-return
	if (!hasToStringTag) {
		return false;
	}
	try {
		return Function('return function*() {}')();
	} catch (e) {
	}
};
/** @type {undefined | false | null | GeneratorFunctionConstructor} */
var GeneratorFunction;

/** @type {import('.')} */
module.exports = function isGeneratorFunction(fn) {
	if (typeof fn !== 'function') {
		return false;
	}
	if (isFnRegex(fnToStr(fn))) {
		return true;
	}
	if (!hasToStringTag) {
		var str = toStr(fn);
		return str === '[object GeneratorFunction]';
	}
	if (!getProto) {
		return false;
	}
	if (typeof GeneratorFunction === 'undefined') {
		var generatorFunc = getGeneratorFunc();
		GeneratorFunction = generatorFunc
			// eslint-disable-next-line no-extra-parens
			? /** @type {GeneratorFunctionConstructor} */ (getProto(generatorFunc))
			: false;
	}
	return getProto(fn) === GeneratorFunction;
};


}),
"./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/implementation.js": 
/*!*******************************************************************************!*\
  !*** ./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/implementation.js ***!
  \*******************************************************************************/
(function (module) {
"use strict";


/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

module.exports = function isNaN(value) {
	return value !== value;
};


}),
"./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/index.js": 
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/index.js ***!
  \**********************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var callBind = __webpack_require__(/*! call-bind */ "./node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/index.js");
var define = __webpack_require__(/*! define-properties */ "./node_modules/.pnpm/define-properties@1.2.1/node_modules/define-properties/index.js");

var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/implementation.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/polyfill.js");
var shim = __webpack_require__(/*! ./shim */ "./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/shim.js");

var polyfill = callBind(getPolyfill(), Number);

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;


}),
"./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/polyfill.js": 
/*!*************************************************************************!*\
  !*** ./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/polyfill.js ***!
  \*************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/implementation.js");

module.exports = function getPolyfill() {
	if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {
		return Number.isNaN;
	}
	return implementation;
};


}),
"./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/shim.js": 
/*!*********************************************************************!*\
  !*** ./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/shim.js ***!
  \*********************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var define = __webpack_require__(/*! define-properties */ "./node_modules/.pnpm/define-properties@1.2.1/node_modules/define-properties/index.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/.pnpm/is-nan@1.3.2/node_modules/is-nan/polyfill.js");

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

module.exports = function shimNumberIsNaN() {
	var polyfill = getPolyfill();
	define(Number, { isNaN: polyfill }, {
		isNaN: function testIsNaN() {
			return Number.isNaN !== polyfill;
		}
	});
	return polyfill;
};


}),
"./node_modules/.pnpm/is-regex@1.2.1/node_modules/is-regex/index.js": 
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/is-regex@1.2.1/node_modules/is-regex/index.js ***!
  \**************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var callBound = __webpack_require__(/*! call-bound */ "./node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js");
var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js")();
var hasOwn = __webpack_require__(/*! hasown */ "./node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js");
var gOPD = __webpack_require__(/*! gopd */ "./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js");

/** @type {import('.')} */
var fn;

if (hasToStringTag) {
	/** @type {(receiver: ThisParameterType<typeof RegExp.prototype.exec>, ...args: Parameters<typeof RegExp.prototype.exec>) => ReturnType<typeof RegExp.prototype.exec>} */
	var $exec = callBound('RegExp.prototype.exec');
	/** @type {object} */
	var isRegexMarker = {};

	var throwRegexMarker = function () {
		throw isRegexMarker;
	};
	/** @type {{ toString(): never, valueOf(): never, [Symbol.toPrimitive]?(): never }} */
	var badStringifier = {
		toString: throwRegexMarker,
		valueOf: throwRegexMarker
	};

	if (typeof Symbol.toPrimitive === 'symbol') {
		badStringifier[Symbol.toPrimitive] = throwRegexMarker;
	}

	/** @type {import('.')} */
	// @ts-expect-error TS can't figure out that the $exec call always throws
	// eslint-disable-next-line consistent-return
	fn = function isRegex(value) {
		if (!value || typeof value !== 'object') {
			return false;
		}

		// eslint-disable-next-line no-extra-parens
		var descriptor = /** @type {NonNullable<typeof gOPD>} */ (gOPD)(/** @type {{ lastIndex?: unknown }} */ (value), 'lastIndex');
		var hasLastIndexDataProperty = descriptor && hasOwn(descriptor, 'value');
		if (!hasLastIndexDataProperty) {
			return false;
		}

		try {
			// eslint-disable-next-line no-extra-parens
			$exec(value, /** @type {string} */ (/** @type {unknown} */ (badStringifier)));
		} catch (e) {
			return e === isRegexMarker;
		}
	};
} else {
	/** @type {(receiver: ThisParameterType<typeof Object.prototype.toString>, ...args: Parameters<typeof Object.prototype.toString>) => ReturnType<typeof Object.prototype.toString>} */
	var $toString = callBound('Object.prototype.toString');
	/** @const @type {'[object RegExp]'} */
	var regexClass = '[object RegExp]';

	/** @type {import('.')} */
	fn = function isRegex(value) {
		// In older browsers, typeof regex incorrectly returns 'function'
		if (!value || (typeof value !== 'object' && typeof value !== 'function')) {
			return false;
		}

		return $toString(value) === regexClass;
	};
}

module.exports = fn;


}),
"./node_modules/.pnpm/is-typed-array@1.1.15/node_modules/is-typed-array/index.js": 
/*!***************************************************************************************!*\
  !*** ./node_modules/.pnpm/is-typed-array@1.1.15/node_modules/is-typed-array/index.js ***!
  \***************************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var whichTypedArray = __webpack_require__(/*! which-typed-array */ "./node_modules/.pnpm/which-typed-array@1.1.19/node_modules/which-typed-array/index.js");

/** @type {import('.')} */
module.exports = function isTypedArray(value) {
	return !!whichTypedArray(value);
};


}),
"./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js": 
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js ***!
  \**************************************************************************************/
(function (module) {
"use strict";


/** @type {import('./abs')} */
module.exports = Math.abs;


}),
"./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js": 
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js ***!
  \****************************************************************************************/
(function (module) {
"use strict";


/** @type {import('./floor')} */
module.exports = Math.floor;


}),
"./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js": 
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js ***!
  \****************************************************************************************/
(function (module) {
"use strict";


/** @type {import('./isNaN')} */
module.exports = Number.isNaN || function isNaN(a) {
	return a !== a;
};


}),
"./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js": 
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js ***!
  \**************************************************************************************/
(function (module) {
"use strict";


/** @type {import('./max')} */
module.exports = Math.max;


}),
"./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js": 
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js ***!
  \**************************************************************************************/
(function (module) {
"use strict";


/** @type {import('./min')} */
module.exports = Math.min;


}),
"./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js": 
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js ***!
  \**************************************************************************************/
(function (module) {
"use strict";


/** @type {import('./pow')} */
module.exports = Math.pow;


}),
"./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js": 
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js ***!
  \****************************************************************************************/
(function (module) {
"use strict";


/** @type {import('./round')} */
module.exports = Math.round;


}),
"./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js": 
/*!***************************************************************************************!*\
  !*** ./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js ***!
  \***************************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var $isNaN = __webpack_require__(/*! ./isNaN */ "./node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js");

/** @type {import('./sign')} */
module.exports = function sign(number) {
	if ($isNaN(number) || number === 0) {
		return number;
	}
	return number < 0 ? -1 : +1;
};


}),
"./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/implementation.js": 
/*!*************************************************************************************!*\
  !*** ./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/implementation.js ***!
  \*************************************************************************************/
(function (module) {
"use strict";


var numberIsNaN = function (value) {
	return value !== value;
};

module.exports = function is(a, b) {
	if (a === 0 && b === 0) {
		return 1 / a === 1 / b;
	}
	if (a === b) {
		return true;
	}
	if (numberIsNaN(a) && numberIsNaN(b)) {
		return true;
	}
	return false;
};



}),
"./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/index.js": 
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/index.js ***!
  \****************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var define = __webpack_require__(/*! define-properties */ "./node_modules/.pnpm/define-properties@1.2.1/node_modules/define-properties/index.js");
var callBind = __webpack_require__(/*! call-bind */ "./node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/index.js");

var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/implementation.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/polyfill.js");
var shim = __webpack_require__(/*! ./shim */ "./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/shim.js");

var polyfill = callBind(getPolyfill(), Object);

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;


}),
"./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/polyfill.js": 
/*!*******************************************************************************!*\
  !*** ./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/polyfill.js ***!
  \*******************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/implementation.js");

module.exports = function getPolyfill() {
	return typeof Object.is === 'function' ? Object.is : implementation;
};


}),
"./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/shim.js": 
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/shim.js ***!
  \***************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/.pnpm/object-is@1.1.6/node_modules/object-is/polyfill.js");
var define = __webpack_require__(/*! define-properties */ "./node_modules/.pnpm/define-properties@1.2.1/node_modules/define-properties/index.js");

module.exports = function shimObjectIs() {
	var polyfill = getPolyfill();
	define(Object, { is: polyfill }, {
		is: function testObjectIs() {
			return Object.is !== polyfill;
		}
	});
	return polyfill;
};


}),
"./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/implementation.js": 
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/implementation.js ***!
  \*****************************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var keysShim;
if (!Object.keys) {
	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var isArgs = __webpack_require__(/*! ./isArguments */ "./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/isArguments.js"); // eslint-disable-line global-require
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$applicationCache: true,
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$onmozfullscreenchange: true,
		$onmozfullscreenerror: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
}
module.exports = keysShim;


}),
"./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/index.js": 
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/index.js ***!
  \********************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var slice = Array.prototype.slice;
var isArgs = __webpack_require__(/*! ./isArguments */ "./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/isArguments.js");

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) { return origKeys(o); } : __webpack_require__(/*! ./implementation */ "./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/implementation.js");

var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			var args = Object.keys(arguments);
			return args && args.length === arguments.length;
		}(1, 2));
		if (!keysWorksWithArguments) {
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				}
				return originalKeys(object);
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;


}),
"./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/isArguments.js": 
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/isArguments.js ***!
  \**************************************************************************************/
(function (module) {
"use strict";


var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};


}),
"./node_modules/.pnpm/object.assign@4.1.7/node_modules/object.assign/implementation.js": 
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/object.assign@4.1.7/node_modules/object.assign/implementation.js ***!
  \*********************************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


// modified from https://github.com/es-shims/es6-shim
var objectKeys = __webpack_require__(/*! object-keys */ "./node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/index.js");
var hasSymbols = __webpack_require__(/*! has-symbols/shams */ "./node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js")();
var callBound = __webpack_require__(/*! call-bound */ "./node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js");
var $Object = __webpack_require__(/*! es-object-atoms */ "./node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js");
var $push = callBound('Array.prototype.push');
var $propIsEnumerable = callBound('Object.prototype.propertyIsEnumerable');
var originalGetSymbols = hasSymbols ? $Object.getOwnPropertySymbols : null;

// eslint-disable-next-line no-unused-vars
module.exports = function assign(target, source1) {
	if (target == null) { throw new TypeError('target must be an object'); }
	var to = $Object(target); // step 1
	if (arguments.length === 1) {
		return to; // step 2
	}
	for (var s = 1; s < arguments.length; ++s) {
		var from = $Object(arguments[s]); // step 3.a.i

		// step 3.a.ii:
		var keys = objectKeys(from);
		var getSymbols = hasSymbols && ($Object.getOwnPropertySymbols || originalGetSymbols);
		if (getSymbols) {
			var syms = getSymbols(from);
			for (var j = 0; j < syms.length; ++j) {
				var key = syms[j];
				if ($propIsEnumerable(from, key)) {
					$push(keys, key);
				}
			}
		}

		// step 3.a.iii:
		for (var i = 0; i < keys.length; ++i) {
			var nextKey = keys[i];
			if ($propIsEnumerable(from, nextKey)) { // step 3.a.iii.2
				var propValue = from[nextKey]; // step 3.a.iii.2.a
				to[nextKey] = propValue; // step 3.a.iii.2.b
			}
		}
	}

	return to; // step 4
};


}),
"./node_modules/.pnpm/object.assign@4.1.7/node_modules/object.assign/polyfill.js": 
/*!***************************************************************************************!*\
  !*** ./node_modules/.pnpm/object.assign@4.1.7/node_modules/object.assign/polyfill.js ***!
  \***************************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/.pnpm/object.assign@4.1.7/node_modules/object.assign/implementation.js");

var lacksProperEnumerationOrder = function () {
	if (!Object.assign) {
		return false;
	}
	/*
	 * v8, specifically in node 4.x, has a bug with incorrect property enumeration order
	 * note: this does not detect the bug unless there's 20 characters
	 */
	var str = 'abcdefghijklmnopqrst';
	var letters = str.split('');
	var map = {};
	for (var i = 0; i < letters.length; ++i) {
		map[letters[i]] = letters[i];
	}
	var obj = Object.assign({}, map);
	var actual = '';
	for (var k in obj) {
		actual += k;
	}
	return str !== actual;
};

var assignHasPendingExceptions = function () {
	if (!Object.assign || !Object.preventExtensions) {
		return false;
	}
	/*
	 * Firefox 37 still has "pending exception" logic in its Object.assign implementation,
	 * which is 72% slower than our shim, and Firefox 40's native implementation.
	 */
	var thrower = Object.preventExtensions({ 1: 2 });
	try {
		Object.assign(thrower, 'xy');
	} catch (e) {
		return thrower[1] === 'y';
	}
	return false;
};

module.exports = function getPolyfill() {
	if (!Object.assign) {
		return implementation;
	}
	if (lacksProperEnumerationOrder()) {
		return implementation;
	}
	if (assignHasPendingExceptions()) {
		return implementation;
	}
	return Object.assign;
};


}),
"./node_modules/.pnpm/possible-typed-array-names@1.1.0/node_modules/possible-typed-array-names/index.js": 
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/possible-typed-array-names@1.1.0/node_modules/possible-typed-array-names/index.js ***!
  \**************************************************************************************************************/
(function (module) {
"use strict";


/** @type {import('.')} */
module.exports = [
	'Float16Array',
	'Float32Array',
	'Float64Array',
	'Int8Array',
	'Int16Array',
	'Int32Array',
	'Uint8Array',
	'Uint8ClampedArray',
	'Uint16Array',
	'Uint32Array',
	'BigInt64Array',
	'BigUint64Array'
];


}),
"./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js": 
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js ***!
  \****************************************************************************/
(function (module) {
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


}),
"./node_modules/.pnpm/safe-regex-test@1.1.0/node_modules/safe-regex-test/index.js": 
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/safe-regex-test@1.1.0/node_modules/safe-regex-test/index.js ***!
  \****************************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var callBound = __webpack_require__(/*! call-bound */ "./node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js");
var isRegex = __webpack_require__(/*! is-regex */ "./node_modules/.pnpm/is-regex@1.2.1/node_modules/is-regex/index.js");

var $exec = callBound('RegExp.prototype.exec');
var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");

/** @type {import('.')} */
module.exports = function regexTester(regex) {
	if (!isRegex(regex)) {
		throw new $TypeError('`regex` must be a RegExp');
	}
	return function test(s) {
		return $exec(regex, s) !== null;
	};
};


}),
"./node_modules/.pnpm/set-function-length@1.2.2/node_modules/set-function-length/index.js": 
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/set-function-length@1.2.2/node_modules/set-function-length/index.js ***!
  \************************************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js");
var define = __webpack_require__(/*! define-data-property */ "./node_modules/.pnpm/define-data-property@1.1.4/node_modules/define-data-property/index.js");
var hasDescriptors = __webpack_require__(/*! has-property-descriptors */ "./node_modules/.pnpm/has-property-descriptors@1.0.2/node_modules/has-property-descriptors/index.js")();
var gOPD = __webpack_require__(/*! gopd */ "./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js");

var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");
var $floor = GetIntrinsic('%Math.floor%');

/** @type {import('.')} */
module.exports = function setFunctionLength(fn, length) {
	if (typeof fn !== 'function') {
		throw new $TypeError('`fn` is not a function');
	}
	if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
		throw new $TypeError('`length` must be a positive 32-bit integer');
	}

	var loose = arguments.length > 2 && !!arguments[2];

	var functionLengthIsConfigurable = true;
	var functionLengthIsWritable = true;
	if ('length' in fn && gOPD) {
		var desc = gOPD(fn, 'length');
		if (desc && !desc.configurable) {
			functionLengthIsConfigurable = false;
		}
		if (desc && !desc.writable) {
			functionLengthIsWritable = false;
		}
	}

	if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
		if (hasDescriptors) {
			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length, true, true);
		} else {
			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length);
		}
	}
	return fn;
};


}),
"./node_modules/.pnpm/util@0.12.5/node_modules/util/support/isBufferBrowser.js": 
/*!*************************************************************************************!*\
  !*** ./node_modules/.pnpm/util@0.12.5/node_modules/util/support/isBufferBrowser.js ***!
  \*************************************************************************************/
(function (module) {
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

}),
"./node_modules/.pnpm/util@0.12.5/node_modules/util/support/types.js": 
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/util@0.12.5/node_modules/util/support/types.js ***!
  \***************************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9



var isArgumentsObject = __webpack_require__(/*! is-arguments */ "./node_modules/.pnpm/is-arguments@1.2.0/node_modules/is-arguments/index.js");
var isGeneratorFunction = __webpack_require__(/*! is-generator-function */ "./node_modules/.pnpm/is-generator-function@1.1.0/node_modules/is-generator-function/index.js");
var whichTypedArray = __webpack_require__(/*! which-typed-array */ "./node_modules/.pnpm/which-typed-array@1.1.19/node_modules/which-typed-array/index.js");
var isTypedArray = __webpack_require__(/*! is-typed-array */ "./node_modules/.pnpm/is-typed-array@1.1.15/node_modules/is-typed-array/index.js");

function uncurryThis(f) {
  return f.call.bind(f);
}

var BigIntSupported = typeof BigInt !== 'undefined';
var SymbolSupported = typeof Symbol !== 'undefined';

var ObjectToString = uncurryThis(Object.prototype.toString);

var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);

if (BigIntSupported) {
  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
}

if (SymbolSupported) {
  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
}

function checkBoxedPrimitive(value, prototypeValueOf) {
  if (typeof value !== 'object') {
    return false;
  }
  try {
    prototypeValueOf(value);
    return true;
  } catch(e) {
    return false;
  }
}

exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;

// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
	return (
		(
			typeof Promise !== 'undefined' &&
			input instanceof Promise
		) ||
		(
			input !== null &&
			typeof input === 'object' &&
			typeof input.then === 'function' &&
			typeof input.catch === 'function'
		)
	);
}
exports.isPromise = isPromise;

function isArrayBufferView(value) {
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    return ArrayBuffer.isView(value);
  }

  return (
    isTypedArray(value) ||
    isDataView(value)
  );
}
exports.isArrayBufferView = isArrayBufferView;


function isUint8Array(value) {
  return whichTypedArray(value) === 'Uint8Array';
}
exports.isUint8Array = isUint8Array;

function isUint8ClampedArray(value) {
  return whichTypedArray(value) === 'Uint8ClampedArray';
}
exports.isUint8ClampedArray = isUint8ClampedArray;

function isUint16Array(value) {
  return whichTypedArray(value) === 'Uint16Array';
}
exports.isUint16Array = isUint16Array;

function isUint32Array(value) {
  return whichTypedArray(value) === 'Uint32Array';
}
exports.isUint32Array = isUint32Array;

function isInt8Array(value) {
  return whichTypedArray(value) === 'Int8Array';
}
exports.isInt8Array = isInt8Array;

function isInt16Array(value) {
  return whichTypedArray(value) === 'Int16Array';
}
exports.isInt16Array = isInt16Array;

function isInt32Array(value) {
  return whichTypedArray(value) === 'Int32Array';
}
exports.isInt32Array = isInt32Array;

function isFloat32Array(value) {
  return whichTypedArray(value) === 'Float32Array';
}
exports.isFloat32Array = isFloat32Array;

function isFloat64Array(value) {
  return whichTypedArray(value) === 'Float64Array';
}
exports.isFloat64Array = isFloat64Array;

function isBigInt64Array(value) {
  return whichTypedArray(value) === 'BigInt64Array';
}
exports.isBigInt64Array = isBigInt64Array;

function isBigUint64Array(value) {
  return whichTypedArray(value) === 'BigUint64Array';
}
exports.isBigUint64Array = isBigUint64Array;

function isMapToString(value) {
  return ObjectToString(value) === '[object Map]';
}
isMapToString.working = (
  typeof Map !== 'undefined' &&
  isMapToString(new Map())
);

function isMap(value) {
  if (typeof Map === 'undefined') {
    return false;
  }

  return isMapToString.working
    ? isMapToString(value)
    : value instanceof Map;
}
exports.isMap = isMap;

function isSetToString(value) {
  return ObjectToString(value) === '[object Set]';
}
isSetToString.working = (
  typeof Set !== 'undefined' &&
  isSetToString(new Set())
);
function isSet(value) {
  if (typeof Set === 'undefined') {
    return false;
  }

  return isSetToString.working
    ? isSetToString(value)
    : value instanceof Set;
}
exports.isSet = isSet;

function isWeakMapToString(value) {
  return ObjectToString(value) === '[object WeakMap]';
}
isWeakMapToString.working = (
  typeof WeakMap !== 'undefined' &&
  isWeakMapToString(new WeakMap())
);
function isWeakMap(value) {
  if (typeof WeakMap === 'undefined') {
    return false;
  }

  return isWeakMapToString.working
    ? isWeakMapToString(value)
    : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;

function isWeakSetToString(value) {
  return ObjectToString(value) === '[object WeakSet]';
}
isWeakSetToString.working = (
  typeof WeakSet !== 'undefined' &&
  isWeakSetToString(new WeakSet())
);
function isWeakSet(value) {
  return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;

function isArrayBufferToString(value) {
  return ObjectToString(value) === '[object ArrayBuffer]';
}
isArrayBufferToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  isArrayBufferToString(new ArrayBuffer())
);
function isArrayBuffer(value) {
  if (typeof ArrayBuffer === 'undefined') {
    return false;
  }

  return isArrayBufferToString.working
    ? isArrayBufferToString(value)
    : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;

function isDataViewToString(value) {
  return ObjectToString(value) === '[object DataView]';
}
isDataViewToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  typeof DataView !== 'undefined' &&
  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
);
function isDataView(value) {
  if (typeof DataView === 'undefined') {
    return false;
  }

  return isDataViewToString.working
    ? isDataViewToString(value)
    : value instanceof DataView;
}
exports.isDataView = isDataView;

// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
function isSharedArrayBufferToString(value) {
  return ObjectToString(value) === '[object SharedArrayBuffer]';
}
function isSharedArrayBuffer(value) {
  if (typeof SharedArrayBufferCopy === 'undefined') {
    return false;
  }

  if (typeof isSharedArrayBufferToString.working === 'undefined') {
    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
  }

  return isSharedArrayBufferToString.working
    ? isSharedArrayBufferToString(value)
    : value instanceof SharedArrayBufferCopy;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;

function isAsyncFunction(value) {
  return ObjectToString(value) === '[object AsyncFunction]';
}
exports.isAsyncFunction = isAsyncFunction;

function isMapIterator(value) {
  return ObjectToString(value) === '[object Map Iterator]';
}
exports.isMapIterator = isMapIterator;

function isSetIterator(value) {
  return ObjectToString(value) === '[object Set Iterator]';
}
exports.isSetIterator = isSetIterator;

function isGeneratorObject(value) {
  return ObjectToString(value) === '[object Generator]';
}
exports.isGeneratorObject = isGeneratorObject;

function isWebAssemblyCompiledModule(value) {
  return ObjectToString(value) === '[object WebAssembly.Module]';
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

function isNumberObject(value) {
  return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;

function isStringObject(value) {
  return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;

function isBooleanObject(value) {
  return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;

function isBigIntObject(value) {
  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;

function isSymbolObject(value) {
  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;

function isBoxedPrimitive(value) {
  return (
    isNumberObject(value) ||
    isStringObject(value) ||
    isBooleanObject(value) ||
    isBigIntObject(value) ||
    isSymbolObject(value)
  );
}
exports.isBoxedPrimitive = isBoxedPrimitive;

function isAnyArrayBuffer(value) {
  return typeof Uint8Array !== 'undefined' && (
    isArrayBuffer(value) ||
    isSharedArrayBuffer(value)
  );
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;

['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {
  Object.defineProperty(exports, method, {
    enumerable: false,
    value: function() {
      throw new Error(method + ' is not supported in userland');
    }
  });
});


}),
"./node_modules/.pnpm/util@0.12.5/node_modules/util/util.js": 
/*!******************************************************************!*\
  !*** ./node_modules/.pnpm/util@0.12.5/node_modules/util/util.js ***!
  \******************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js */ "./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/.pnpm/console-browserify@1.2.0/node_modules/console-browserify/index.js */ "./node_modules/.pnpm/console-browserify@1.2.0/node_modules/console-browserify/index.js");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnvRegex = /^$/;

if (process.env.NODE_DEBUG) {
  var debugEnv = process.env.NODE_DEBUG;
  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
    .replace(/\*/g, '.*')
    .replace(/,/g, '$|^')
    .toUpperCase();
  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
}
exports.debuglog = function(set) {
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (debugEnvRegex.test(set)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').slice(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.slice(1, -1);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = __webpack_require__(/*! ./support/types */ "./node_modules/.pnpm/util@0.12.5/node_modules/util/support/types.js");

function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
exports.types.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ "./node_modules/.pnpm/util@0.12.5/node_modules/util/support/isBufferBrowser.js");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(/*! inherits */ "./node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js");

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },
            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;


}),
"./node_modules/.pnpm/which-typed-array@1.1.19/node_modules/which-typed-array/index.js": 
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/which-typed-array@1.1.19/node_modules/which-typed-array/index.js ***!
  \*********************************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var forEach = __webpack_require__(/*! for-each */ "./node_modules/.pnpm/for-each@0.3.5/node_modules/for-each/index.js");
var availableTypedArrays = __webpack_require__(/*! available-typed-arrays */ "./node_modules/.pnpm/available-typed-arrays@1.0.7/node_modules/available-typed-arrays/index.js");
var callBind = __webpack_require__(/*! call-bind */ "./node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/index.js");
var callBound = __webpack_require__(/*! call-bound */ "./node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js");
var gOPD = __webpack_require__(/*! gopd */ "./node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js");
var getProto = __webpack_require__(/*! get-proto */ "./node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js");

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js")();

var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;
var typedArrays = availableTypedArrays();

var $slice = callBound('String.prototype.slice');

/** @type {<T = unknown>(array: readonly T[], value: unknown) => number} */
var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
	for (var i = 0; i < array.length; i += 1) {
		if (array[i] === value) {
			return i;
		}
	}
	return -1;
};

/** @typedef {import('./types').Getter} Getter */
/** @type {import('./types').Cache} */
var cache = { __proto__: null };
if (hasToStringTag && gOPD && getProto) {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		if (Symbol.toStringTag in arr && getProto) {
			var proto = getProto(arr);
			// @ts-expect-error TS won't narrow inside a closure
			var descriptor = gOPD(proto, Symbol.toStringTag);
			if (!descriptor && proto) {
				var superProto = getProto(proto);
				// @ts-expect-error TS won't narrow inside a closure
				descriptor = gOPD(superProto, Symbol.toStringTag);
			}
			// @ts-expect-error TODO: fix
			cache['$' + typedArray] = callBind(descriptor.get);
		}
	});
} else {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		var fn = arr.slice || arr.set;
		if (fn) {
			cache[
				/** @type {`$${import('.').TypedArrayName}`} */ ('$' + typedArray)
			] = /** @type {import('./types').BoundSlice | import('./types').BoundSet} */ (
				// @ts-expect-error TODO FIXME
				callBind(fn)
			);
		}
	});
}

/** @type {(value: object) => false | import('.').TypedArrayName} */
var tryTypedArrays = function tryAllTypedArrays(value) {
	/** @type {ReturnType<typeof tryAllTypedArrays>} */ var found = false;
	forEach(
		/** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */ (cache),
		/** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
		function (getter, typedArray) {
			if (!found) {
				try {
					// @ts-expect-error a throw is fine here
					if ('$' + getter(value) === typedArray) {
						found = /** @type {import('.').TypedArrayName} */ ($slice(typedArray, 1));
					}
				} catch (e) { /**/ }
			}
		}
	);
	return found;
};

/** @type {(value: object) => false | import('.').TypedArrayName} */
var trySlices = function tryAllSlices(value) {
	/** @type {ReturnType<typeof tryAllSlices>} */ var found = false;
	forEach(
		/** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */(cache),
		/** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */ function (getter, name) {
			if (!found) {
				try {
					// @ts-expect-error a throw is fine here
					getter(value);
					found = /** @type {import('.').TypedArrayName} */ ($slice(name, 1));
				} catch (e) { /**/ }
			}
		}
	);
	return found;
};

/** @type {import('.')} */
module.exports = function whichTypedArray(value) {
	if (!value || typeof value !== 'object') { return false; }
	if (!hasToStringTag) {
		/** @type {string} */
		var tag = $slice($toString(value), 8, -1);
		if ($indexOf(typedArrays, tag) > -1) {
			return tag;
		}
		if (tag !== 'Object') {
			return false;
		}
		// node < 0.6 hits here on real Typed Arrays
		return trySlices(value);
	}
	if (!gOPD) { return null; } // unknown engine
	return tryTypedArrays(value);
};


}),
"./src/enums.ts": 
/*!**********************!*\
  !*** ./src/enums.ts ***!
  \**********************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  CustomMessageType: () => (CustomMessageType),
  Protocol: () => (Protocol)
});
var Protocol = /*#__PURE__*/ function(Protocol) {
    // Room-related (10~19)
    Protocol[Protocol["HANDSHAKE"] = 9] = "HANDSHAKE";
    Protocol[Protocol["JOIN_ROOM"] = 10] = "JOIN_ROOM";
    Protocol[Protocol["ERROR"] = 11] = "ERROR";
    Protocol[Protocol["LEAVE_ROOM"] = 12] = "LEAVE_ROOM";
    Protocol[Protocol["ROOM_DATA"] = 13] = "ROOM_DATA";
    Protocol[Protocol["ROOM_STATE"] = 14] = "ROOM_STATE";
    Protocol[Protocol["ROOM_STATE_PATCH"] = 15] = "ROOM_STATE_PATCH";
    Protocol[Protocol["ROOM_DATA_SCHEMA"] = 16] = "ROOM_DATA_SCHEMA";
    Protocol[Protocol["ROOM_DATA_BYTES"] = 17] = "ROOM_DATA_BYTES";
    return Protocol;
}({});
var CustomMessageType = /*#__PURE__*/ function(CustomMessageType) {
    CustomMessageType[CustomMessageType["PositionUpdate"] = 41] = "PositionUpdate";
    CustomMessageType[CustomMessageType["Chat"] = 71] = "Chat";
    CustomMessageType[CustomMessageType["SetGun"] = 88] = "SetGun";
    CustomMessageType[CustomMessageType["Shoot"] = 61] = "Shoot";
    CustomMessageType[CustomMessageType["ShotRejected"] = 39] = "ShotRejected";
    CustomMessageType[CustomMessageType["Explosion"] = 70] = "Explosion";
    CustomMessageType[CustomMessageType["RocketKilled"] = 87] = "RocketKilled";
    CustomMessageType[CustomMessageType["UserDataChanged"] = 81] = "UserDataChanged";
    CustomMessageType[CustomMessageType["Ping"] = 75] = "Ping";
    CustomMessageType[CustomMessageType["Pong"] = 78] = "Pong";
    CustomMessageType[CustomMessageType["RequestSpawn"] = 84] = "RequestSpawn";
    CustomMessageType[CustomMessageType["SceneLoaded"] = 83] = "SceneLoaded";
    CustomMessageType[CustomMessageType["GotShot"] = 69] = "GotShot";
    CustomMessageType[CustomMessageType["GameEnded"] = 35] = "GameEnded";
    CustomMessageType[CustomMessageType["TakeItem"] = 30] = "TakeItem";
    CustomMessageType[CustomMessageType["ThrowGrenade"] = 89] = "ThrowGrenade";
    CustomMessageType[CustomMessageType["GrenadePositionUpdate"] = 31] = "GrenadePositionUpdate";
    CustomMessageType[CustomMessageType["PickupFlag"] = 38] = "PickupFlag";
    CustomMessageType[CustomMessageType["CollectTag"] = 73] = "CollectTag";
    CustomMessageType[CustomMessageType["SubmitFlag"] = 32] = "SubmitFlag";
    CustomMessageType[CustomMessageType["Dash"] = 46] = "Dash";
    CustomMessageType[CustomMessageType["ShowClientNotification"] = 33] = "ShowClientNotification";
    CustomMessageType[CustomMessageType["Crouch"] = 59] = "Crouch";
    return CustomMessageType;
}({});


}),
"./src/schemas.ts": 
/*!************************!*\
  !*** ./src/schemas.ts ***!
  \************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  CapturePoint: () => (CapturePoint),
  DroppedTag: () => (DroppedTag),
  Flag: () => (Flag),
  Grenade: () => (Grenade),
  MyRoomState: () => (MyRoomState),
  Player: () => (Player),
  PublicUserData: () => (PublicUserData),
  SpawnedItem: () => (SpawnedItem),
  Weapon: () => (Weapon)
});
/* ESM import */var _colyseus_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @colyseus/schema */ "./node_modules/.pnpm/@colyseus+schema@3.0.35/node_modules/@colyseus/schema/build/umd/index.js");
/* ESM import */var _colyseus_schema__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__);
function _assert_this_initialized(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _call_super(_this, derived, args) {
    derived = _get_prototype_of(derived);
    return _possible_constructor_return(_this, _is_native_reflect_construct() ? Reflect.construct(derived, args || [], _get_prototype_of(_this).constructor) : derived.apply(_this, args));
}
function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _get_prototype_of(o) {
    _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of(o);
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of(subClass, superClass);
}
function _possible_constructor_return(self, call) {
    if (call && (_type_of(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized(self);
}
function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of(o, p);
}
function _type_of(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _is_native_reflect_construct() {
    try {
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct = function() {
        return !!result;
    })();
}
function _ts_decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

// remember to update alongside the game
var ColyVector3 = /*#__PURE__*/ function(Schema) {
    "use strict";
    _inherits(ColyVector3, Schema);
    function ColyVector3() {
        _class_call_check(this, ColyVector3);
        var _this;
        _this = _call_super(this, ColyVector3, arguments), _define_property(_this, "x", void 0), _define_property(_this, "y", void 0), _define_property(_this, "z", void 0);
        return _this;
    }
    return ColyVector3;
}(_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.Schema);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("number")
], ColyVector3.prototype, "x", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("number")
], ColyVector3.prototype, "y", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("number")
], ColyVector3.prototype, "z", void 0);
var ColyRigid = /*#__PURE__*/ function(Schema) {
    "use strict";
    _inherits(ColyRigid, Schema);
    function ColyRigid() {
        _class_call_check(this, ColyRigid);
        var _this;
        _this = _call_super(this, ColyRigid, arguments), _define_property(_this, "position", void 0), _define_property(_this, "rotationY", void 0), _define_property(_this, "air", void 0), _define_property(_this, "neck", void 0);
        return _this;
    }
    return ColyRigid;
}(_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.Schema);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)(ColyVector3)
], ColyRigid.prototype, "position", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("number")
], ColyRigid.prototype, "rotationY", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("boolean")
], ColyRigid.prototype, "air", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("int8")
], ColyRigid.prototype, "neck", void 0);
var Weapon = /*#__PURE__*/ function(Schema) {
    "use strict";
    _inherits(Weapon, Schema);
    function Weapon() {
        _class_call_check(this, Weapon);
        var _this;
        _this = _call_super(this, Weapon, arguments), _define_property(_this, "weaponId", void 0), _define_property(_this, "skinId", void 0);
        return _this;
    }
    return Weapon;
}(_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.Schema);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("int16")
], Weapon.prototype, "weaponId", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("int16")
], Weapon.prototype, "skinId", void 0);
var PublicUserData = /*#__PURE__*/ function(Schema) {
    "use strict";
    _inherits(PublicUserData, Schema);
    function PublicUserData() {
        _class_call_check(this, PublicUserData);
        var _this;
        _this = _call_super(this, PublicUserData, arguments), _define_property(_this, "username", void 0), _define_property(_this, "pfp", void 0), _define_property(_this, "createdAt", void 0);
        return _this;
    }
    return PublicUserData;
}(_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.Schema);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("string")
], PublicUserData.prototype, "username", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("string")
], PublicUserData.prototype, "pfp", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("string")
], PublicUserData.prototype, "createdAt", void 0);
var Shot = /*#__PURE__*/ function(Schema) {
    "use strict";
    _inherits(Shot, Schema);
    function Shot() {
        _class_call_check(this, Shot);
        var _this;
        _this = _call_super(this, Shot, arguments), _define_property(_this, "byId", void 0), _define_property(_this, "gunId", void 0);
        return _this;
    }
    return Shot;
}(_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.Schema);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("string")
], Shot.prototype, "byId", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("int8")
], Shot.prototype, "gunId", void 0);
var Player = /*#__PURE__*/ function(Schema) {
    "use strict";
    _inherits(Player, Schema);
    function Player() {
        _class_call_check(this, Player);
        var _this;
        _this = _call_super(this, Player, arguments), _define_property(_this, "selectedGunSkins", void 0), _define_property(_this, "playerId", void 0), _define_property(_this, "nickname", void 0), _define_property(_this, "score", void 0), _define_property(_this, "elo", void 0), _define_property(_this, "kills", void 0), _define_property(_this, "deaths", void 0), _define_property(_this, "skin", void 0), _define_property(_this, "hat", void 0), _define_property(_this, "back", void 0), _define_property(_this, "weaponsCollected", void 0), _define_property(_this, "maxKillStreak", void 0), _define_property(_this, "rigid", void 0), _define_property(_this, "health", void 0), _define_property(_this, "weaponClass", void 0), _define_property(_this, "spawned", void 0), _define_property(_this, "dashing", void 0), _define_property(_this, "crouching", void 0), _define_property(_this, "sceneLoaded", void 0), _define_property(_this, "localWeaponIndex", void 0), _define_property(_this, "team", void 0), _define_property(_this, "healthProtected", void 0), _define_property(_this, "inventory", void 0), _define_property(_this, "userId", void 0), _define_property(_this, "user", void 0), _define_property(_this, "lastGotShot", void 0), _define_property(_this, "currentKillStreak", void 0), _define_property(_this, "killsWithWeapon", void 0), _define_property(_this, "headshots", void 0), _define_property(_this, "startPlayTime", void 0), _define_property(_this, "lastShotTime", void 0), _define_property(_this, "lastShootTime", void 0);
        return _this;
    }
    return Player;
}(_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.Schema);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)({
        map: "int16"
    })
], Player.prototype, "selectedGunSkins", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("string")
], Player.prototype, "playerId", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("string")
], Player.prototype, "nickname", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("uint32")
], Player.prototype, "score", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("number")
], Player.prototype, "elo", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("uint16")
], Player.prototype, "kills", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("uint16")
], Player.prototype, "deaths", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("int16")
], Player.prototype, "skin", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("int16")
], Player.prototype, "hat", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("int16")
], Player.prototype, "back", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("uint16")
], Player.prototype, "weaponsCollected", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("uint16")
], Player.prototype, "maxKillStreak", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)(ColyRigid)
], Player.prototype, "rigid", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("uint8")
], Player.prototype, "health", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("uint8")
], Player.prototype, "weaponClass", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("boolean")
], Player.prototype, "spawned", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("boolean")
], Player.prototype, "dashing", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("boolean")
], Player.prototype, "crouching", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("boolean")
], Player.prototype, "sceneLoaded", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("int8")
], Player.prototype, "localWeaponIndex", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("int8")
], Player.prototype, "team", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("boolean")
], Player.prototype, "healthProtected", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)([
        Weapon
    ])
], Player.prototype, "inventory", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("string")
], Player.prototype, "userId", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)(PublicUserData)
], Player.prototype, "user", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)(Shot)
], Player.prototype, "lastGotShot", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("number")
], Player.prototype, "currentKillStreak", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)({
        map: "number"
    })
], Player.prototype, "killsWithWeapon", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("number")
], Player.prototype, "headshots", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("number")
], Player.prototype, "startPlayTime", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("number")
], Player.prototype, "lastShotTime", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("number")
], Player.prototype, "lastShootTime", void 0);
var SpawnedItem = /*#__PURE__*/ function(Schema) {
    "use strict";
    _inherits(SpawnedItem, Schema);
    function SpawnedItem() {
        _class_call_check(this, SpawnedItem);
        var _this;
        _this = _call_super(this, SpawnedItem, arguments), _define_property(_this, "x", void 0), _define_property(_this, "y", void 0), _define_property(_this, "z", void 0), _define_property(_this, "type", void 0), _define_property(_this, "rewardParam", void 0), _define_property(_this, "id", void 0);
        return _this;
    }
    return SpawnedItem;
}(_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.Schema);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("number")
], SpawnedItem.prototype, "x", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("number")
], SpawnedItem.prototype, "y", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("number")
], SpawnedItem.prototype, "z", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("string")
], SpawnedItem.prototype, "type", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("int8")
], SpawnedItem.prototype, "rewardParam", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("string")
], SpawnedItem.prototype, "id", void 0);
var Grenade = /*#__PURE__*/ function(Schema) {
    "use strict";
    _inherits(Grenade, Schema);
    function Grenade() {
        _class_call_check(this, Grenade);
        var _this;
        _this = _call_super(this, Grenade, arguments), _define_property(_this, "position", void 0), _define_property(_this, "rotation", void 0), _define_property(_this, "grenadeId", void 0), _define_property(_this, "weaponId", void 0), _define_property(_this, "ownerSessionId", void 0), _define_property(_this, "initialVelocity", void 0);
        return _this;
    }
    return Grenade;
}(_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.Schema);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)(ColyVector3)
], Grenade.prototype, "position", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)(ColyVector3)
], Grenade.prototype, "rotation", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("string")
], Grenade.prototype, "grenadeId", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("int16")
], Grenade.prototype, "weaponId", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("string")
], Grenade.prototype, "ownerSessionId", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)(ColyVector3)
], Grenade.prototype, "initialVelocity", void 0);
var CapturePoint = /*#__PURE__*/ function(Schema) {
    "use strict";
    _inherits(CapturePoint, Schema);
    function CapturePoint() {
        _class_call_check(this, CapturePoint);
        var _this;
        _this = _call_super(this, CapturePoint, arguments), _define_property(_this, "id", void 0), _define_property(_this, "position", void 0), _define_property(_this, "controllingTeam", void 0), _define_property(_this, "captureProgress", void 0), _define_property(_this, "progressPerSecond", void 0);
        return _this;
    }
    return CapturePoint;
}(_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.Schema);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("string")
], CapturePoint.prototype, "id", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)(ColyVector3)
], CapturePoint.prototype, "position", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("int8")
], CapturePoint.prototype, "controllingTeam", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("float32")
], CapturePoint.prototype, "captureProgress", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("float32")
], CapturePoint.prototype, "progressPerSecond", void 0);
var Flag = /*#__PURE__*/ function(Schema) {
    "use strict";
    _inherits(Flag, Schema);
    function Flag() {
        _class_call_check(this, Flag);
        var _this;
        _this = _call_super(this, Flag, arguments), _define_property(_this, "teamId", void 0), _define_property(_this, "isAtBase", void 0), _define_property(_this, "carriedBy", void 0), _define_property(_this, "position", void 0), _define_property(_this, "basePosition", void 0);
        return _this;
    }
    return Flag;
}(_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.Schema);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("int8")
], Flag.prototype, "teamId", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("boolean")
], Flag.prototype, "isAtBase", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("string")
], Flag.prototype, "carriedBy", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)(ColyVector3)
], Flag.prototype, "position", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)(ColyVector3)
], Flag.prototype, "basePosition", void 0);
var DroppedTag = /*#__PURE__*/ function(Schema) {
    "use strict";
    _inherits(DroppedTag, Schema);
    function DroppedTag() {
        _class_call_check(this, DroppedTag);
        var _this;
        _this = _call_super(this, DroppedTag, arguments), _define_property(_this, "id", void 0), _define_property(_this, "position", void 0), _define_property(_this, "teamId", void 0), _define_property(_this, "expireTime", void 0);
        return _this;
    }
    return DroppedTag;
}(_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.Schema);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("string")
], DroppedTag.prototype, "id", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)(ColyVector3)
], DroppedTag.prototype, "position", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("int8")
], DroppedTag.prototype, "teamId", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("number")
], DroppedTag.prototype, "expireTime", void 0);
var MyRoomState = /*#__PURE__*/ function(Schema) {
    "use strict";
    _inherits(MyRoomState, Schema);
    function MyRoomState() {
        _class_call_check(this, MyRoomState);
        var _this;
        _this = _call_super(this, MyRoomState, arguments), _define_property(_this, "avgElo", void 0), _define_property(_this, "players", void 0), _define_property(_this, "map", void 0), _define_property(_this, "light", void 0), _define_property(_this, "mode", void 0), _define_property(_this, "matchLength", void 0), _define_property(_this, "maxPlayers", void 0), _define_property(_this, "region", void 0), _define_property(_this, "startTime", void 0), _define_property(_this, "teamScores", void 0), _define_property(_this, "spawnedItems", void 0), _define_property(_this, "grenades", void 0), _define_property(_this, "capturePoints", void 0), _define_property(_this, "flags", void 0), _define_property(_this, "droppedTags", void 0), _define_property(_this, "aboutToShutdown", void 0);
        return _this;
    }
    return MyRoomState;
}(_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.Schema);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("float32")
], MyRoomState.prototype, "avgElo", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)({
        map: Player
    })
], MyRoomState.prototype, "players", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("int8")
], MyRoomState.prototype, "map", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("int8")
], MyRoomState.prototype, "light", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("int8")
], MyRoomState.prototype, "mode", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("int32")
], MyRoomState.prototype, "matchLength", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("int32")
], MyRoomState.prototype, "maxPlayers", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("int8")
], MyRoomState.prototype, "region", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("float64")
], MyRoomState.prototype, "startTime", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)({
        map: "int32"
    })
], MyRoomState.prototype, "teamScores", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)({
        map: SpawnedItem
    })
], MyRoomState.prototype, "spawnedItems", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)({
        map: Grenade
    })
], MyRoomState.prototype, "grenades", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)({
        map: CapturePoint
    })
], MyRoomState.prototype, "capturePoints", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)({
        map: Flag
    })
], MyRoomState.prototype, "flags", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)({
        map: DroppedTag
    })
], MyRoomState.prototype, "droppedTags", void 0);
_ts_decorate([
    (0,_colyseus_schema__WEBPACK_IMPORTED_MODULE_0__.type)("boolean")
], MyRoomState.prototype, "aboutToShutdown", void 0);


}),
"./node_modules/.pnpm/available-typed-arrays@1.0.7/node_modules/available-typed-arrays/index.js": 
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/available-typed-arrays@1.0.7/node_modules/available-typed-arrays/index.js ***!
  \******************************************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var possibleNames = __webpack_require__(/*! possible-typed-array-names */ "./node_modules/.pnpm/possible-typed-array-names@1.1.0/node_modules/possible-typed-array-names/index.js");

var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;

/** @type {import('.')} */
module.exports = function availableTypedArrays() {
	var /** @type {ReturnType<typeof availableTypedArrays>} */ out = [];
	for (var i = 0; i < possibleNames.length; i++) {
		if (typeof g[possibleNames[i]] === 'function') {
			// @ts-expect-error
			out[out.length] = possibleNames[i];
		}
	}
	return out;
};


}),
"./node_modules/.pnpm/@colyseus+msgpackr@1.11.2/node_modules/@colyseus/msgpackr/index.js": 
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@colyseus+msgpackr@1.11.2/node_modules/@colyseus/msgpackr/index.js ***!
  \***********************************************************************************************/
(function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  ALWAYS: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.ALWAYS),
  C1: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.C1),
  DECIMAL_FIT: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.DECIMAL_FIT),
  DECIMAL_ROUND: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.DECIMAL_ROUND),
  Decoder: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.Decoder),
  Encoder: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.Encoder),
  FLOAT32_OPTIONS: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.FLOAT32_OPTIONS),
  NEVER: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.NEVER),
  Packr: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.Packr),
  RESERVE_START_SPACE: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.RESERVE_START_SPACE),
  RESET_BUFFER_MODE: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.RESET_BUFFER_MODE),
  REUSE_BUFFER_MODE: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.REUSE_BUFFER_MODE),
  Unpackr: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.Unpackr),
  addExtension: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.addExtension),
  clearSource: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.clearSource),
  decode: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.decode),
  decodeIter: () => (/* reexport safe */ _iterators_js__WEBPACK_IMPORTED_MODULE_2__.decodeIter),
  encode: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.encode),
  encodeIter: () => (/* reexport safe */ _iterators_js__WEBPACK_IMPORTED_MODULE_2__.encodeIter),
  isNativeAccelerationEnabled: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.isNativeAccelerationEnabled),
  mapsAsObjects: () => (mapsAsObjects),
  pack: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.pack),
  roundFloat32: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.roundFloat32),
  unpack: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.unpack),
  unpackMultiple: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.unpackMultiple),
  useRecords: () => (useRecords)
});
/* ESM import */var _pack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pack.js */ "./node_modules/.pnpm/@colyseus+msgpackr@1.11.2/node_modules/@colyseus/msgpackr/pack.js");
/* ESM import */var _unpack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./unpack.js */ "./node_modules/.pnpm/@colyseus+msgpackr@1.11.2/node_modules/@colyseus/msgpackr/unpack.js");
/* ESM import */var _iterators_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./iterators.js */ "./node_modules/.pnpm/@colyseus+msgpackr@1.11.2/node_modules/@colyseus/msgpackr/iterators.js");



const useRecords = false
const mapsAsObjects = true


}),
"./node_modules/.pnpm/@colyseus+msgpackr@1.11.2/node_modules/@colyseus/msgpackr/iterators.js": 
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@colyseus+msgpackr@1.11.2/node_modules/@colyseus/msgpackr/iterators.js ***!
  \***************************************************************************************************/
(function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  decodeIter: () => (decodeIter),
  encodeIter: () => (encodeIter),
  packIter: () => (packIter),
  unpackIter: () => (unpackIter)
});
/* ESM import */var _pack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pack.js */ "./node_modules/.pnpm/@colyseus+msgpackr@1.11.2/node_modules/@colyseus/msgpackr/pack.js");
/* ESM import */var _unpack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./unpack.js */ "./node_modules/.pnpm/@colyseus+msgpackr@1.11.2/node_modules/@colyseus/msgpackr/unpack.js");
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")["Buffer"];



/**
 * Given an Iterable first argument, returns an Iterable where each value is packed as a Buffer
 * If the argument is only Async Iterable, the return value will be an Async Iterable.
 * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object
 * @param {options} [options] - msgpackr pack options
 * @returns {IterableIterator|Promise.<AsyncIterableIterator>}
 */
function packIter (objectIterator, options = {}) {
  if (!objectIterator || typeof objectIterator !== 'object') {
    throw new Error('first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable')
  } else if (typeof objectIterator[Symbol.iterator] === 'function') {
    return packIterSync(objectIterator, options)
  } else if (typeof objectIterator.then === 'function' || typeof objectIterator[Symbol.asyncIterator] === 'function') {
    return packIterAsync(objectIterator, options)
  } else {
    throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise')
  }
}

function * packIterSync (objectIterator, options) {
  const packr = new _pack_js__WEBPACK_IMPORTED_MODULE_0__.Packr(options)
  for (const value of objectIterator) {
    yield packr.pack(value)
  }
}

async function * packIterAsync (objectIterator, options) {
  const packr = new _pack_js__WEBPACK_IMPORTED_MODULE_0__.Packr(options)
  for await (const value of objectIterator) {
    yield packr.pack(value)
  }
}

/**
 * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects
 * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.
 * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator
 * @param {object} [options] - unpackr options
 * @returns {IterableIterator|Promise.<AsyncIterableIterator}
 */
function unpackIter (bufferIterator, options = {}) {
  if (!bufferIterator || typeof bufferIterator !== 'object') {
    throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise')
  }

  const unpackr = new _unpack_js__WEBPACK_IMPORTED_MODULE_1__.Unpackr(options)
  let incomplete
  const parser = (chunk) => {
    let yields
    // if there's incomplete data from previous chunk, concatinate and try again
    if (incomplete) {
      chunk = Buffer.concat([incomplete, chunk])
      incomplete = undefined
    }

    try {
      yields = unpackr.unpackMultiple(chunk)
    } catch (err) {
      if (err.incomplete) {
        incomplete = chunk.slice(err.lastPosition)
        yields = err.values
      } else {
        throw err
      }
    }
    return yields
  }

  if (typeof bufferIterator[Symbol.iterator] === 'function') {
    return (function * iter () {
      for (const value of bufferIterator) {
        yield * parser(value)
      }
    })()
  } else if (typeof bufferIterator[Symbol.asyncIterator] === 'function') {
    return (async function * iter () {
      for await (const value of bufferIterator) {
        yield * parser(value)
      }
    })()
  }
}
const decodeIter = unpackIter
const encodeIter = packIter

}),
"./node_modules/.pnpm/@colyseus+msgpackr@1.11.2/node_modules/@colyseus/msgpackr/pack.js": 
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@colyseus+msgpackr@1.11.2/node_modules/@colyseus/msgpackr/pack.js ***!
  \**********************************************************************************************/
(function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  ALWAYS: () => (ALWAYS),
  DECIMAL_FIT: () => (DECIMAL_FIT),
  DECIMAL_ROUND: () => (DECIMAL_ROUND),
  Encoder: () => (Encoder),
  FLOAT32_OPTIONS: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_0__.FLOAT32_OPTIONS),
  NEVER: () => (NEVER),
  Packr: () => (Packr),
  RECORD_SYMBOL: () => (RECORD_SYMBOL),
  RESERVE_START_SPACE: () => (RESERVE_START_SPACE),
  RESET_BUFFER_MODE: () => (RESET_BUFFER_MODE),
  REUSE_BUFFER_MODE: () => (REUSE_BUFFER_MODE),
  addExtension: () => (addExtension),
  encode: () => (encode),
  pack: () => (pack),
  setWriteStructSlots: () => (setWriteStructSlots)
});
/* ESM import */var _unpack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./unpack.js */ "./node_modules/.pnpm/@colyseus+msgpackr@1.11.2/node_modules/@colyseus/msgpackr/unpack.js");
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")["Buffer"];

let textEncoder
try {
	textEncoder = new TextEncoder()
} catch (error) {}
let extensions, extensionClasses
const hasNodeBuffer = typeof Buffer !== 'undefined'
const ByteArrayAllocate = hasNodeBuffer ?
	function(length) { return Buffer.allocUnsafeSlow(length) } : Uint8Array
const ByteArray = hasNodeBuffer ? Buffer : Uint8Array
const MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000
let target, keysTarget
let targetView
let position = 0
let safeEnd
let bundledStrings = null
let writeStructSlots
const MAX_BUNDLE_SIZE = 0x5500 // maximum characters such that the encoded bytes fits in 16 bits.
const hasNonLatin = /[\u0080-\uFFFF]/
const RECORD_SYMBOL = Symbol('record-id')
class Packr extends _unpack_js__WEBPACK_IMPORTED_MODULE_0__.Unpackr {
	constructor(options) {
		super(options)
		this.offset = 0
		let typeBuffer
		let start
		let hasSharedUpdate
		let structures
		let referenceMap
		let encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position) {
			return target.utf8Write(string, position, target.byteLength - position)
		} : (textEncoder && textEncoder.encodeInto) ?
			function(string, position) {
				return textEncoder.encodeInto(string, target.subarray(position)).written
			} : false

		let packr = this
		if (!options)
			options = {}
		let isSequential = options && options.sequential
		let hasSharedStructures = options.structures || options.saveStructures
		let maxSharedStructures = options.maxSharedStructures
		if (maxSharedStructures == null)
			maxSharedStructures = hasSharedStructures ? 32 : 0
		if (maxSharedStructures > 8160)
			throw new Error('Maximum maxSharedStructure is 8160')
		if (options.structuredClone && options.moreTypes == undefined) {
			this.moreTypes = true
		}
		let maxOwnStructures = options.maxOwnStructures
		if (maxOwnStructures == null)
			maxOwnStructures = hasSharedStructures ? 32 : 64
		if (!this.structures && options.useRecords != false)
			this.structures = []
		// two byte record ids for shared structures
		let useTwoByteRecords = maxSharedStructures > 32 || (maxOwnStructures + maxSharedStructures > 64)
		let sharedLimitId = maxSharedStructures + 0x40
		let maxStructureId = maxSharedStructures + maxOwnStructures + 0x40
		if (maxStructureId > 8256) {
			throw new Error('Maximum maxSharedStructure + maxOwnStructure is 8192')
		}
		let recordIdsToRemove = []
		let transitionsCount = 0
		let serializationsSinceTransitionRebuild = 0

		this.pack = this.encode = function(value, encodeOptions) {
			if (!target) {
				target = new ByteArrayAllocate(8192)
				targetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, 8192))
				position = 0
			}
			safeEnd = target.length - 10
			if (safeEnd - position < 0x800) {
				// don't start too close to the end,
				target = new ByteArrayAllocate(target.length)
				targetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length))
				safeEnd = target.length - 10
				position = 0
			} else
				position = (position + 7) & 0x7ffffff8 // Word align to make any future copying of this buffer faster
			start = position
			if (encodeOptions & RESERVE_START_SPACE) position += (encodeOptions & 0xff)
			referenceMap = packr.structuredClone ? new Map() : null
			if (packr.bundleStrings && typeof value !== 'string') {
				bundledStrings = []
				bundledStrings.size = Infinity // force a new bundle start on first string
			} else
				bundledStrings = null
			structures = packr.structures
			if (structures) {
				if (structures.uninitialized)
					structures = packr._mergeStructures(packr.getStructures())
				let sharedLength = structures.sharedLength || 0
				if (sharedLength > maxSharedStructures) {
					//if (maxSharedStructures <= 32 && structures.sharedLength > 32) // TODO: could support this, but would need to update the limit ids
					throw new Error('Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to ' + structures.sharedLength)
				}
				if (!structures.transitions) {
					// rebuild our structure transitions
					structures.transitions = Object.create(null)
					for (let i = 0; i < sharedLength; i++) {
						let keys = structures[i]
						if (!keys)
							continue
						let nextTransition, transition = structures.transitions
						for (let j = 0, l = keys.length; j < l; j++) {
							let key = keys[j]
							nextTransition = transition[key]
							if (!nextTransition) {
								nextTransition = transition[key] = Object.create(null)
							}
							transition = nextTransition
						}
						transition[RECORD_SYMBOL] = i + 0x40
					}
					this.lastNamedStructuresLength = sharedLength
				}
				if (!isSequential) {
					structures.nextId = sharedLength + 0x40
				}
			}
			if (hasSharedUpdate)
				hasSharedUpdate = false
			let encodingError;
			try {
				if (packr.randomAccessStructure && value && value.constructor && value.constructor === Object)
					writeStruct(value);
				else
					pack(value)
				let lastBundle = bundledStrings;
				if (bundledStrings)
					writeBundles(start, pack, 0)
				if (referenceMap && referenceMap.idsToInsert) {
					let idsToInsert = referenceMap.idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);
					let i = idsToInsert.length;
					let incrementPosition = -1;
					while (lastBundle && i > 0) {
						let insertionPoint = idsToInsert[--i].offset + start;
						if (insertionPoint < (lastBundle.stringsPosition + start) && incrementPosition === -1)
							incrementPosition = 0;
						if (insertionPoint > (lastBundle.position + start)) {
							if (incrementPosition >= 0)
								incrementPosition += 6;
						} else {
							if (incrementPosition >= 0) {
								// update the bundle reference now
								targetView.setUint32(lastBundle.position + start,
									targetView.getUint32(lastBundle.position + start) + incrementPosition)
								incrementPosition = -1; // reset
							}
							lastBundle = lastBundle.previous;
							i++;
						}
					}
					if (incrementPosition >= 0 && lastBundle) {
						// update the bundle reference now
						targetView.setUint32(lastBundle.position + start,
							targetView.getUint32(lastBundle.position + start) + incrementPosition)
					}
					position += idsToInsert.length * 6;
					if (position > safeEnd)
						makeRoom(position)
					packr.offset = position
					let serialized = insertIds(target.subarray(start, position), idsToInsert)
					referenceMap = null
					return serialized
				}
				packr.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially
				if (encodeOptions & REUSE_BUFFER_MODE) {
					target.start = start
					target.end = position
					return target
				}
				return target.subarray(start, position) // position can change if we call pack again in saveStructures, so we get the buffer now
			} catch(error) {
				encodingError = error;
				throw error;
			} finally {
				if (structures) {
					resetStructures();
					if (hasSharedUpdate && packr.saveStructures) {
						let sharedLength = structures.sharedLength || 0
						// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save
						let returnBuffer = target.subarray(start, position)
						let newSharedData = prepareStructures(structures, packr);
						if (!encodingError) { // TODO: If there is an encoding error, should make the structures as uninitialized so they get rebuilt next time
							if (packr.saveStructures(newSharedData, newSharedData.isCompatible) === false) {
								// get updated structures and try again if the update failed
								return packr.pack(value, encodeOptions)
							}
							packr.lastNamedStructuresLength = sharedLength
							// don't keep large buffers around
							if (target.length > 0x40000000) target = null
							return returnBuffer
						}
					}
				}
				// don't keep large buffers around, they take too much memory and cause problems (limit at 1GB)
				if (target.length > 0x40000000) target = null
				if (encodeOptions & RESET_BUFFER_MODE)
					position = start
			}
		}
		const resetStructures = () => {
			if (serializationsSinceTransitionRebuild < 10)
				serializationsSinceTransitionRebuild++
			let sharedLength = structures.sharedLength || 0
			if (structures.length > sharedLength && !isSequential)
				structures.length = sharedLength
			if (transitionsCount > 10000) {
				// force a rebuild occasionally after a lot of transitions so it can get cleaned up
				structures.transitions = null
				serializationsSinceTransitionRebuild = 0
				transitionsCount = 0
				if (recordIdsToRemove.length > 0)
					recordIdsToRemove = []
			} else if (recordIdsToRemove.length > 0 && !isSequential) {
				for (let i = 0, l = recordIdsToRemove.length; i < l; i++) {
					recordIdsToRemove[i][RECORD_SYMBOL] = 0
				}
				recordIdsToRemove = []
			}
		}
		const packArray = (value) => {
			var length = value.length
			if (length < 0x10) {
				target[position++] = 0x90 | length
			} else if (length < 0x10000) {
				target[position++] = 0xdc
				target[position++] = length >> 8
				target[position++] = length & 0xff
			} else {
				target[position++] = 0xdd
				targetView.setUint32(position, length)
				position += 4
			}
			for (let i = 0; i < length; i++) {
				pack(value[i])
			}
		}
		const pack = (value) => {
			if (position > safeEnd)
				target = makeRoom(position)

			var type = typeof value
			var length
			if (type === 'string') {
				let strLength = value.length
				if (bundledStrings && strLength >= 4 && strLength < 0x1000) {
					if ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {
						let extStart
						let maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10
						if (position + maxBytes > safeEnd)
							target = makeRoom(position + maxBytes)
						let lastBundle
						if (bundledStrings.position) { // here we use the 0x62 extension to write the last bundle and reserve space for the reference pointer to the next/current bundle
							lastBundle = bundledStrings
							target[position] = 0xc8 // ext 16
							position += 3 // reserve for the writing bundle size
							target[position++] = 0x62 // 'b'
							extStart = position - start
							position += 4 // reserve for writing bundle reference
							writeBundles(start, pack, 0) // write the last bundles
							targetView.setUint16(extStart + start - 3, position - start - extStart)
						} else { // here we use the 0x62 extension just to reserve the space for the reference pointer to the bundle (will be updated once the bundle is written)
							target[position++] = 0xd6 // fixext 4
							target[position++] = 0x62 // 'b'
							extStart = position - start
							position += 4 // reserve for writing bundle reference
						}
						bundledStrings = ['', ''] // create new ones
						bundledStrings.previous = lastBundle;
						bundledStrings.size = 0
						bundledStrings.position = extStart
					}
					let twoByte = hasNonLatin.test(value)
					bundledStrings[twoByte ? 0 : 1] += value
					target[position++] = 0xc1
					pack(twoByte ? -strLength : strLength);
					return
				}
				let headerSize
				// first we estimate the header size, so we can write to the correct location
				if (strLength < 0x20) {
					headerSize = 1
				} else if (strLength < 0x100) {
					headerSize = 2
				} else if (strLength < 0x10000) {
					headerSize = 3
				} else {
					headerSize = 5
				}
				let maxBytes = strLength * 3
				if (position + maxBytes > safeEnd)
					target = makeRoom(position + maxBytes)

				if (strLength < 0x40 || !encodeUtf8) {
					let i, c1, c2, strPosition = position + headerSize
					for (i = 0; i < strLength; i++) {
						c1 = value.charCodeAt(i)
						if (c1 < 0x80) {
							target[strPosition++] = c1
						} else if (c1 < 0x800) {
							target[strPosition++] = c1 >> 6 | 0xc0
							target[strPosition++] = c1 & 0x3f | 0x80
						} else if (
							(c1 & 0xfc00) === 0xd800 &&
							((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00
						) {
							c1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)
							i++
							target[strPosition++] = c1 >> 18 | 0xf0
							target[strPosition++] = c1 >> 12 & 0x3f | 0x80
							target[strPosition++] = c1 >> 6 & 0x3f | 0x80
							target[strPosition++] = c1 & 0x3f | 0x80
						} else {
							target[strPosition++] = c1 >> 12 | 0xe0
							target[strPosition++] = c1 >> 6 & 0x3f | 0x80
							target[strPosition++] = c1 & 0x3f | 0x80
						}
					}
					length = strPosition - position - headerSize
				} else {
					length = encodeUtf8(value, position + headerSize)
				}

				if (length < 0x20) {
					target[position++] = 0xa0 | length
				} else if (length < 0x100) {
					if (headerSize < 2) {
						target.copyWithin(position + 2, position + 1, position + 1 + length)
					}
					target[position++] = 0xd9
					target[position++] = length
				} else if (length < 0x10000) {
					if (headerSize < 3) {
						target.copyWithin(position + 3, position + 2, position + 2 + length)
					}
					target[position++] = 0xda
					target[position++] = length >> 8
					target[position++] = length & 0xff
				} else {
					if (headerSize < 5) {
						target.copyWithin(position + 5, position + 3, position + 3 + length)
					}
					target[position++] = 0xdb
					targetView.setUint32(position, length)
					position += 4
				}
				position += length
			} else if (type === 'number') {
				if (value >>> 0 === value) {// positive integer, 32-bit or less
					// positive uint
					if (value < 0x20 || (value < 0x80 && this.useRecords === false) || (value < 0x40 && !this.randomAccessStructure)) {
						target[position++] = value
					} else if (value < 0x100) {
						target[position++] = 0xcc
						target[position++] = value
					} else if (value < 0x10000) {
						target[position++] = 0xcd
						target[position++] = value >> 8
						target[position++] = value & 0xff
					} else {
						target[position++] = 0xce
						targetView.setUint32(position, value)
						position += 4
					}
				} else if (value >> 0 === value) { // negative integer
					if (value >= -0x20) {
						target[position++] = 0x100 + value
					} else if (value >= -0x80) {
						target[position++] = 0xd0
						target[position++] = value + 0x100
					} else if (value >= -0x8000) {
						target[position++] = 0xd1
						targetView.setInt16(position, value)
						position += 2
					} else {
						target[position++] = 0xd2
						targetView.setInt32(position, value)
						position += 4
					}
				} else {
					let useFloat32
					if ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {
						target[position++] = 0xca
						targetView.setFloat32(position, value)
						let xShifted
						if (useFloat32 < 4 ||
								// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
								((xShifted = value * _unpack_js__WEBPACK_IMPORTED_MODULE_0__.mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {
							position += 4
							return
						} else
							position-- // move back into position for writing a double
					}
					target[position++] = 0xcb
					targetView.setFloat64(position, value)
					position += 8
				}
			} else if (type === 'object' || type === 'function') {
				if (!value)
					target[position++] = 0xc0
				else {
					if (referenceMap) {
						let referee = referenceMap.get(value)
						if (referee) {
							if (!referee.id) {
								let idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = [])
								referee.id = idsToInsert.push(referee)
							}
							target[position++] = 0xd6 // fixext 4
							target[position++] = 0x70 // "p" for pointer
							targetView.setUint32(position, referee.id)
							position += 4
							return
						} else
							referenceMap.set(value, { offset: position - start })
					}
					let constructor = value.constructor
					if (constructor === Object) {
						writeObject(value)
					} else if (constructor === Array) {
						packArray(value)
					} else if (constructor === Map) {
						if (this.mapAsEmptyObject) target[position++] = 0x80
						else {
							length = value.size
							if (length < 0x10) {
								target[position++] = 0x80 | length
							} else if (length < 0x10000) {
								target[position++] = 0xde
								target[position++] = length >> 8
								target[position++] = length & 0xff
							} else {
								target[position++] = 0xdf
								targetView.setUint32(position, length)
								position += 4
							}
							for (let [key, entryValue] of value) {
								pack(key)
								pack(entryValue)
							}
						}
					} else {
						for (let i = 0, l = extensions.length; i < l; i++) {
							let extensionClass = extensionClasses[i]
							if (value instanceof extensionClass) {
								let extension = extensions[i]
								if (extension.write) {
									if (extension.type) {
										target[position++] = 0xd4 // one byte "tag" extension
										target[position++] = extension.type
										target[position++] = 0
									}
									let writeResult = extension.write.call(this, value)
									if (writeResult === value) { // avoid infinite recursion
										if (Array.isArray(value)) {
											packArray(value)
										} else {
											writeObject(value)
										}
									} else {
										pack(writeResult)
									}
									return
								}
								let currentTarget = target
								let currentTargetView = targetView
								let currentPosition = position
								target = null
								let result
								try {
									result = extension.pack.call(this, value, (size) => {
										// restore target and use it
										target = currentTarget
										currentTarget = null
										position += size
										if (position > safeEnd)
											makeRoom(position)
										return {
											target, targetView, position: position - size
										}
									}, pack)
								} finally {
									// restore current target information (unless already restored)
									if (currentTarget) {
										target = currentTarget
										targetView = currentTargetView
										position = currentPosition
										safeEnd = target.length - 10
									}
								}
								if (result) {
									if (result.length + position > safeEnd)
										makeRoom(result.length + position)
									position = writeExtensionData(result, target, position, extension.type)
								}
								return
							}
						}
						// check isArray after extensions, because extensions can extend Array
						if (Array.isArray(value)) {
							packArray(value)
						} else {
							// use this as an alternate mechanism for expressing how to serialize
							if (value.toJSON) {
								const json = value.toJSON()
								// if for some reason value.toJSON returns itself it'll loop forever
								if (json !== value)
									return pack(json)
							}

							// if there is a writeFunction, use it, otherwise just encode as undefined
							if (type === 'function')
								return pack(this.writeFunction && this.writeFunction(value));

							// no extension found, write as plain object
							writeObject(value)
						}
					}
				}
			} else if (type === 'boolean') {
				target[position++] = value ? 0xc3 : 0xc2
			} else if (type === 'bigint') {
				if (value < (BigInt(1)<<BigInt(63)) && value >= -(BigInt(1)<<BigInt(63))) {
					// use a signed int as long as it fits
					target[position++] = 0xd3
					targetView.setBigInt64(position, value)
				} else if (value < (BigInt(1)<<BigInt(64)) && value > 0) {
					// if we can fit an unsigned int, use that
					target[position++] = 0xcf
					targetView.setBigUint64(position, value)
				} else {
					// overflow
					if (this.largeBigIntToFloat) {
						target[position++] = 0xcb
						targetView.setFloat64(position, Number(value))
					} else if (this.largeBigIntToString) {
						return pack(value.toString());
					} else if (this.useBigIntExtension && value < BigInt(2)**BigInt(1023) && value > -(BigInt(2)**BigInt(1023))) {
						target[position++] = 0xc7
						position++;
						target[position++] = 0x42 // "B" for BigInt
						let bytes = [];
						let alignedSign;
						do {
							let byte = value & BigInt(0xff);
							alignedSign = (byte & BigInt(0x80)) === (value < BigInt(0) ? BigInt(0x80) : BigInt(0));
							bytes.push(byte);
							value >>= BigInt(8);
						} while (!((value === BigInt(0) || value === BigInt(-1)) && alignedSign));
						target[position-2] = bytes.length;
						for (let i = bytes.length; i > 0;) {
							target[position++] = Number(bytes[--i]);
						}
						return
					} else {
						throw new RangeError(value + ' was too large to fit in MessagePack 64-bit integer format, use' +
							' useBigIntExtension, or set largeBigIntToFloat to convert to float-64, or set' +
							' largeBigIntToString to convert to string')
					}
				}
				position += 8
			} else if (type === 'undefined') {
				if (this.encodeUndefinedAsNil)
					target[position++] = 0xc0
				else {
					target[position++] = 0xd4 // a number of implementations use fixext1 with type 0, data 0 to denote undefined, so we follow suite
					target[position++] = 0
					target[position++] = 0
				}
			} else {
				throw new Error('Unknown type: ' + type)
			}
		}

		const writePlainObject = (this.variableMapSize || this.coercibleKeyAsNumber || this.skipValues) ? (object) => {
			// this method is slightly slower, but generates "preferred serialization" (optimally small for smaller objects)
			let keys;
			if (this.skipValues) {
				keys = [];
				for (let key in object) {
					if ((typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) &&
						!this.skipValues.includes(object[key]))
						keys.push(key);
				}
			} else {
				keys = Object.keys(object)
			}
			let length = keys.length
			if (length < 0x10) {
				target[position++] = 0x80 | length
			} else if (length < 0x10000) {
				target[position++] = 0xde
				target[position++] = length >> 8
				target[position++] = length & 0xff
			} else {
				target[position++] = 0xdf
				targetView.setUint32(position, length)
				position += 4
			}
			let key
			if (this.coercibleKeyAsNumber) {
				for (let i = 0; i < length; i++) {
					key = keys[i]
					let num = Number(key)
					pack(isNaN(num) ? key : num)
					pack(object[key])
				}

			} else {
				for (let i = 0; i < length; i++) {
					pack(key = keys[i])
					pack(object[key])
				}
			}
		} :
		(object) => {
			target[position++] = 0xde // always using map 16, so we can preallocate and set the length afterwards
			let objectOffset = position - start
			position += 2
			let size = 0
			for (let key in object) {
				if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {
					pack(key)
					pack(object[key])
					size++
				}
			}
			if (size > 0xffff) {
				throw new Error('Object is too large to serialize with fast 16-bit map size,' +
				' use the "variableMapSize" option to serialize this object');
			}
			target[objectOffset++ + start] = size >> 8
			target[objectOffset + start] = size & 0xff
		}

		const writeRecord = this.useRecords === false ? writePlainObject :
		(options.progressiveRecords && !useTwoByteRecords) ?  // this is about 2% faster for highly stable structures, since it only requires one for-in loop (but much more expensive when new structure needs to be written)
		(object) => {
			let nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))
			let objectOffset = position++ - start
			let wroteKeys
			for (let key in object) {
				if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {
					nextTransition = transition[key]
					if (nextTransition)
						transition = nextTransition
					else {
						// record doesn't exist, create full new record and insert it
						let keys = Object.keys(object)
						let lastTransition = transition
						transition = structures.transitions
						let newTransitions = 0
						for (let i = 0, l = keys.length; i < l; i++) {
							let key = keys[i]
							nextTransition = transition[key]
							if (!nextTransition) {
								nextTransition = transition[key] = Object.create(null)
								newTransitions++
							}
							transition = nextTransition
						}
						if (objectOffset + start + 1 == position) {
							// first key, so we don't need to insert, we can just write record directly
							position--
							newRecord(transition, keys, newTransitions)
						} else // otherwise we need to insert the record, moving existing data after the record
							insertNewRecord(transition, keys, objectOffset, newTransitions)
						wroteKeys = true
						transition = lastTransition[key]
					}
					pack(object[key])
				}
			}
			if (!wroteKeys) {
				let recordId = transition[RECORD_SYMBOL]
				if (recordId)
					target[objectOffset + start] = recordId
				else
					insertNewRecord(transition, Object.keys(object), objectOffset, 0)
			}
		} :
		(object) => {
			let nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))
			let newTransitions = 0
			for (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {
				nextTransition = transition[key]
				if (!nextTransition) {
					nextTransition = transition[key] = Object.create(null)
					newTransitions++
				}
				transition = nextTransition
			}
			let recordId = transition[RECORD_SYMBOL]
			if (recordId) {
				if (recordId >= 0x60 && useTwoByteRecords) {
					target[position++] = ((recordId -= 0x60) & 0x1f) + 0x60
					target[position++] = recordId >> 5
				} else
					target[position++] = recordId
			} else {
				newRecord(transition, transition.__keys__ || Object.keys(object), newTransitions)
			}
			// now write the values
			for (let key in object)
				if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {
					pack(object[key])
				}
		}

		// create reference to useRecords if useRecords is a function
		const checkUseRecords = typeof this.useRecords == 'function' && this.useRecords;

		const writeObject = checkUseRecords ? (object) => {
			checkUseRecords(object) ? writeRecord(object) : writePlainObject(object)
		} : writeRecord

		const makeRoom = (end) => {
			let newSize
			if (end > 0x1000000) {
				// special handling for really large buffers
				if ((end - start) > MAX_BUFFER_SIZE)
					throw new Error('Packed buffer would be larger than maximum buffer size')
				newSize = Math.min(MAX_BUFFER_SIZE,
					Math.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000)
			} else // faster handling for smaller buffers
				newSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12
			let newBuffer = new ByteArrayAllocate(newSize)
			targetView = newBuffer.dataView || (newBuffer.dataView = new DataView(newBuffer.buffer, 0, newSize))
			end = Math.min(end, target.length)
			if (target.copy)
				target.copy(newBuffer, 0, start, end)
			else
				newBuffer.set(target.slice(start, end))
			position -= start
			start = 0
			safeEnd = newBuffer.length - 10
			return target = newBuffer
		}
		const newRecord = (transition, keys, newTransitions) => {
			let recordId = structures.nextId
			if (!recordId)
				recordId = 0x40
			if (recordId < sharedLimitId && this.shouldShareStructure && !this.shouldShareStructure(keys)) {
				recordId = structures.nextOwnId
				if (!(recordId < maxStructureId))
					recordId = sharedLimitId
				structures.nextOwnId = recordId + 1
			} else {
				if (recordId >= maxStructureId)// cycle back around
					recordId = sharedLimitId
				structures.nextId = recordId + 1
			}
			let highByte = keys.highByte = recordId >= 0x60 && useTwoByteRecords ? (recordId - 0x60) >> 5 : -1
			transition[RECORD_SYMBOL] = recordId
			transition.__keys__ = keys
			structures[recordId - 0x40] = keys

			if (recordId < sharedLimitId) {
				keys.isShared = true
				structures.sharedLength = recordId - 0x3f
				hasSharedUpdate = true
				if (highByte >= 0) {
					target[position++] = (recordId & 0x1f) + 0x60
					target[position++] = highByte
				} else {
					target[position++] = recordId
				}
			} else {
				if (highByte >= 0) {
					target[position++] = 0xd5 // fixext 2
					target[position++] = 0x72 // "r" record defintion extension type
					target[position++] = (recordId & 0x1f) + 0x60
					target[position++] = highByte
				} else {
					target[position++] = 0xd4 // fixext 1
					target[position++] = 0x72 // "r" record defintion extension type
					target[position++] = recordId
				}

				if (newTransitions)
					transitionsCount += serializationsSinceTransitionRebuild * newTransitions
				// record the removal of the id, we can maintain our shared structure
				if (recordIdsToRemove.length >= maxOwnStructures)
					recordIdsToRemove.shift()[RECORD_SYMBOL] = 0 // we are cycling back through, and have to remove old ones
				recordIdsToRemove.push(transition)
				pack(keys)
			}
		}
		const insertNewRecord = (transition, keys, insertionOffset, newTransitions) => {
			let mainTarget = target
			let mainPosition = position
			let mainSafeEnd = safeEnd
			let mainStart = start
			target = keysTarget
			position = 0
			start = 0
			if (!target)
				keysTarget = target = new ByteArrayAllocate(8192)
			safeEnd = target.length - 10
			newRecord(transition, keys, newTransitions)
			keysTarget = target
			let keysPosition = position
			target = mainTarget
			position = mainPosition
			safeEnd = mainSafeEnd
			start = mainStart
			if (keysPosition > 1) {
				let newEnd = position + keysPosition - 1
				if (newEnd > safeEnd)
					makeRoom(newEnd)
				let insertionPosition = insertionOffset + start
				target.copyWithin(insertionPosition + keysPosition, insertionPosition + 1, position)
				target.set(keysTarget.slice(0, keysPosition), insertionPosition)
				position = newEnd
			} else {
				target[insertionOffset + start] = keysTarget[0]
			}
		}
		const writeStruct = (object) => {
			let newPosition = writeStructSlots(object, target, start, position, structures, makeRoom, (value, newPosition, notifySharedUpdate) => {
				if (notifySharedUpdate)
					return hasSharedUpdate = true;
				position = newPosition;
				let startTarget = target;
				pack(value);
				resetStructures();
				if (startTarget !== target) {
					return { position, targetView, target }; // indicate the buffer was re-allocated
				}
				return position;
			}, this);
			if (newPosition === 0) // bail and go to a msgpack object
				return writeObject(object);
			position = newPosition;
		}
	}
	useBuffer(buffer) {
		// this means we are finished using our own buffer and we can write over it safely
		target = buffer
		target.dataView || (target.dataView = new DataView(target.buffer, target.byteOffset, target.byteLength))
		position = 0
	}
	set position (value) {
		position = value;
	}
	get position() {
		return position;
	}
	set buffer (buffer) {
		target = buffer;
	}
	get buffer () {
		return target;
	}
	clearSharedData() {
		if (this.structures)
			this.structures = []
		if (this.typedStructs)
			this.typedStructs = []
	}
}

extensionClasses = [ Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/, _unpack_js__WEBPACK_IMPORTED_MODULE_0__.C1Type ]
extensions = [{
	pack(date, allocateForWrite, pack) {
		let seconds = date.getTime() / 1000
		if ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {
			// Timestamp 32
			let { target, targetView, position} = allocateForWrite(6)
			target[position++] = 0xd6
			target[position++] = 0xff
			targetView.setUint32(position, seconds)
		} else if (seconds > 0 && seconds < 0x100000000) {
			// Timestamp 64
			let { target, targetView, position} = allocateForWrite(10)
			target[position++] = 0xd7
			target[position++] = 0xff
			targetView.setUint32(position, date.getMilliseconds() * 4000000 + ((seconds / 1000 / 0x100000000) >> 0))
			targetView.setUint32(position + 4, seconds)
		} else if (isNaN(seconds)) {
			if (this.onInvalidDate) {
				allocateForWrite(0)
				return pack(this.onInvalidDate())
			}
			// Intentionally invalid timestamp
			let { target, targetView, position} = allocateForWrite(3)
			target[position++] = 0xd4
			target[position++] = 0xff
			target[position++] = 0xff
		} else {
			// Timestamp 96
			let { target, targetView, position} = allocateForWrite(15)
			target[position++] = 0xc7
			target[position++] = 12
			target[position++] = 0xff
			targetView.setUint32(position, date.getMilliseconds() * 1000000)
			targetView.setBigInt64(position + 4, BigInt(Math.floor(seconds)))
		}
	}
}, {
	pack(set, allocateForWrite, pack) {
		if (this.setAsEmptyObject) {
			allocateForWrite(0);
			return pack({})
		}
		let array = Array.from(set)
		let { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)
		if (this.moreTypes) {
			target[position++] = 0xd4
			target[position++] = 0x73 // 's' for Set
			target[position++] = 0
		}
		pack(array)
	}
}, {
	pack(error, allocateForWrite, pack) {
		let { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)
		if (this.moreTypes) {
			target[position++] = 0xd4
			target[position++] = 0x65 // 'e' for error
			target[position++] = 0
		}
		pack([ error.name, error.message, error.cause ])
	}
}, {
	pack(regex, allocateForWrite, pack) {
		let { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)
		if (this.moreTypes) {
			target[position++] = 0xd4
			target[position++] = 0x78 // 'x' for regeXp
			target[position++] = 0
		}
		pack([ regex.source, regex.flags ])
	}
}, {
	pack(arrayBuffer, allocateForWrite) {
		if (this.moreTypes)
			writeExtBuffer(arrayBuffer, 0x10, allocateForWrite)
		else
			writeBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite)
	}
}, {
	pack(typedArray, allocateForWrite) {
		let constructor = typedArray.constructor
		if (constructor !== ByteArray && this.moreTypes)
			writeExtBuffer(typedArray, _unpack_js__WEBPACK_IMPORTED_MODULE_0__.typedArrays.indexOf(constructor.name), allocateForWrite)
		else
			writeBuffer(typedArray, allocateForWrite)
	}
}, {
	pack(c1, allocateForWrite) { // specific 0xC1 object
		let { target, position} = allocateForWrite(1)
		target[position] = 0xc1
	}
}]

function writeExtBuffer(typedArray, type, allocateForWrite, encode) {
	let length = typedArray.byteLength
	if (length + 1 < 0x100) {
		var { target, position } = allocateForWrite(4 + length)
		target[position++] = 0xc7
		target[position++] = length + 1
	} else if (length + 1 < 0x10000) {
		var { target, position } = allocateForWrite(5 + length)
		target[position++] = 0xc8
		target[position++] = (length + 1) >> 8
		target[position++] = (length + 1) & 0xff
	} else {
		var { target, position, targetView } = allocateForWrite(7 + length)
		target[position++] = 0xc9
		targetView.setUint32(position, length + 1) // plus one for the type byte
		position += 4
	}
	target[position++] = 0x74 // "t" for typed array
	target[position++] = type
	if (!typedArray.buffer) typedArray = new Uint8Array(typedArray)
	target.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength), position)
}
function writeBuffer(buffer, allocateForWrite) {
	let length = buffer.byteLength
	var target, position
	if (length < 0x100) {
		var { target, position } = allocateForWrite(length + 2)
		target[position++] = 0xc4
		target[position++] = length
	} else if (length < 0x10000) {
		var { target, position } = allocateForWrite(length + 3)
		target[position++] = 0xc5
		target[position++] = length >> 8
		target[position++] = length & 0xff
	} else {
		var { target, position, targetView } = allocateForWrite(length + 5)
		target[position++] = 0xc6
		targetView.setUint32(position, length)
		position += 4
	}
	target.set(buffer, position)
}

function writeExtensionData(result, target, position, type) {
	let length = result.length
	switch (length) {
		case 1:
			target[position++] = 0xd4
			break
		case 2:
			target[position++] = 0xd5
			break
		case 4:
			target[position++] = 0xd6
			break
		case 8:
			target[position++] = 0xd7
			break
		case 16:
			target[position++] = 0xd8
			break
		default:
			if (length < 0x100) {
				target[position++] = 0xc7
				target[position++] = length
			} else if (length < 0x10000) {
				target[position++] = 0xc8
				target[position++] = length >> 8
				target[position++] = length & 0xff
			} else {
				target[position++] = 0xc9
				target[position++] = length >> 24
				target[position++] = (length >> 16) & 0xff
				target[position++] = (length >> 8) & 0xff
				target[position++] = length & 0xff
			}
	}
	target[position++] = type
	target.set(result, position)
	position += length
	return position
}

function insertIds(serialized, idsToInsert) {
	// insert the ids that need to be referenced for structured clones
	let nextId
	let distanceToMove = idsToInsert.length * 6
	let lastEnd = serialized.length - distanceToMove
	while (nextId = idsToInsert.pop()) {
		let offset = nextId.offset
		let id = nextId.id
		serialized.copyWithin(offset + distanceToMove, offset, lastEnd)
		distanceToMove -= 6
		let position = offset + distanceToMove
		serialized[position++] = 0xd6
		serialized[position++] = 0x69 // 'i'
		serialized[position++] = id >> 24
		serialized[position++] = (id >> 16) & 0xff
		serialized[position++] = (id >> 8) & 0xff
		serialized[position++] = id & 0xff
		lastEnd = offset
	}
	return serialized
}

function writeBundles(start, pack, incrementPosition) {
	if (bundledStrings.length > 0) {
		targetView.setUint32(bundledStrings.position + start, position + incrementPosition - bundledStrings.position - start)
		bundledStrings.stringsPosition = position - start;
		let writeStrings = bundledStrings
		bundledStrings = null
		pack(writeStrings[0])
		pack(writeStrings[1])
	}
}

function addExtension(extension) {
	if (extension.Class) {
		if (!extension.pack && !extension.write)
			throw new Error('Extension has no pack or write function')
		if (extension.pack && !extension.type)
			throw new Error('Extension has no type (numeric code to identify the extension)')
		extensionClasses.unshift(extension.Class)
		extensions.unshift(extension)
	}
	(0,_unpack_js__WEBPACK_IMPORTED_MODULE_0__.addExtension)(extension)
}
function prepareStructures(structures, packr) {
	structures.isCompatible = (existingStructures) => {
		let compatible = !existingStructures || ((packr.lastNamedStructuresLength || 0) === existingStructures.length)
		if (!compatible) // we want to merge these existing structures immediately since we already have it and we are in the right transaction
			packr._mergeStructures(existingStructures);
		return compatible;
	}
	return structures
}
function setWriteStructSlots(writeSlots, makeStructures) {
	writeStructSlots = writeSlots;
	prepareStructures = makeStructures;
}

let defaultPackr = new Packr({ useRecords: false })
const pack = defaultPackr.pack
const encode = defaultPackr.pack
const Encoder = Packr

;
const { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = _unpack_js__WEBPACK_IMPORTED_MODULE_0__.FLOAT32_OPTIONS
const REUSE_BUFFER_MODE = 512
const RESET_BUFFER_MODE = 1024
const RESERVE_START_SPACE = 2048


}),
"./node_modules/.pnpm/@colyseus+msgpackr@1.11.2/node_modules/@colyseus/msgpackr/unpack.js": 
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@colyseus+msgpackr@1.11.2/node_modules/@colyseus/msgpackr/unpack.js ***!
  \************************************************************************************************/
(function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  C1: () => (C1),
  C1Type: () => (C1Type),
  Decoder: () => (Decoder),
  FLOAT32_OPTIONS: () => (FLOAT32_OPTIONS),
  Unpackr: () => (Unpackr),
  addExtension: () => (addExtension),
  checkedRead: () => (checkedRead),
  clearSource: () => (clearSource),
  decode: () => (decode),
  getPosition: () => (getPosition),
  isNativeAccelerationEnabled: () => (isNativeAccelerationEnabled),
  loadStructures: () => (loadStructures),
  mult10: () => (mult10),
  read: () => (read),
  readString: () => (readString),
  roundFloat32: () => (roundFloat32),
  setExtractor: () => (setExtractor),
  setReadStruct: () => (setReadStruct),
  typedArrays: () => (typedArrays),
  unpack: () => (unpack),
  unpackMultiple: () => (unpackMultiple)
});
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js */ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")["Buffer"];
var decoder
try {
	decoder = new TextDecoder()
} catch(error) {}
var src
var srcEnd
var position = 0
var alreadySet
const EMPTY_ARRAY = []
var strings = EMPTY_ARRAY
var stringPosition = 0
var currentUnpackr = {}
var currentStructures
var srcString
var srcStringStart = 0
var srcStringEnd = 0
var bundledStrings
var referenceMap
var currentExtensions = []
var dataView
var defaultOptions = {
	useRecords: false,
	mapsAsObjects: true
}
class C1Type {}
const C1 = new C1Type()
C1.name = 'MessagePack 0xC1'
var sequentialMode = false
var inlineObjectReadThreshold = 2
var readStruct, onLoadedStructures, onSaveState
var BlockedFunction // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for
// no-eval build
try {
	new Function('')
} catch(error) {
	// if eval variants are not supported, do not create inline object readers ever
	inlineObjectReadThreshold = Infinity
}

class Unpackr {
	constructor(options) {
		if (options) {
			if (options.useRecords === false && options.mapsAsObjects === undefined)
				options.mapsAsObjects = true
			if (options.sequential && options.trusted !== false) {
				options.trusted = true;
				if (!options.structures && options.useRecords != false) {
					options.structures = []
					if (!options.maxSharedStructures)
						options.maxSharedStructures = 0
				}
			}
			if (options.structures)
				options.structures.sharedLength = options.structures.length
			else if (options.getStructures) {
				(options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures
				options.structures.sharedLength = 0
			}
			if (options.int64AsNumber) {
				options.int64AsType = 'number'
			}
		}
		Object.assign(this, options)
	}
	unpack(source, options) {
		if (src) {
			// re-entrant execution, save the state and restore it after we do this unpack
			return saveState(() => {
				clearSource()
				return this ? this.unpack(source, options) : Unpackr.prototype.unpack.call(defaultOptions, source, options)
			})
		}
		if (!source.buffer && source.constructor === ArrayBuffer)
			source = typeof Buffer !== 'undefined' ? Buffer.from(source) : new Uint8Array(source);
		if (typeof options === 'object') {
			srcEnd = options.end || source.length
			position = options.start || 0
		} else {
			position = 0
			srcEnd = options > -1 ? options : source.length
		}
		stringPosition = 0
		srcStringEnd = 0
		srcString = null
		strings = EMPTY_ARRAY
		bundledStrings = null
		src = source
		// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend
		// technique for getting data from a database where it can be copied into an existing buffer instead of creating
		// new ones
		try {
			dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))
		} catch(error) {
			// if it doesn't have a buffer, maybe it is the wrong type of object
			src = null
			if (source instanceof Uint8Array)
				throw error
			throw new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))
		}
		if (this instanceof Unpackr) {
			currentUnpackr = this
			if (this.structures) {
				currentStructures = this.structures
				return checkedRead(options)
			} else if (!currentStructures || currentStructures.length > 0) {
				currentStructures = []
			}
		} else {
			currentUnpackr = defaultOptions
			if (!currentStructures || currentStructures.length > 0)
				currentStructures = []
		}
		return checkedRead(options)
	}
	unpackMultiple(source, forEach) {
		let values, lastPosition = 0
		try {
			sequentialMode = true
			let size = source.length
			let value = this ? this.unpack(source, size) : defaultUnpackr.unpack(source, size)
			if (forEach) {
				if (forEach(value, lastPosition, position) === false) return;
				while(position < size) {
					lastPosition = position
					if (forEach(checkedRead(), lastPosition, position) === false) {
						return
					}
				}
			}
			else {
				values = [ value ]
				while(position < size) {
					lastPosition = position
					values.push(checkedRead())
				}
				return values
			}
		} catch(error) {
			error.lastPosition = lastPosition
			error.values = values
			throw error
		} finally {
			sequentialMode = false
			clearSource()
		}
	}
	_mergeStructures(loadedStructures, existingStructures) {
		if (onLoadedStructures)
			loadedStructures = onLoadedStructures.call(this, loadedStructures);
		loadedStructures = loadedStructures || []
		if (Object.isFrozen(loadedStructures))
			loadedStructures = loadedStructures.map(structure => structure.slice(0))
		for (let i = 0, l = loadedStructures.length; i < l; i++) {
			let structure = loadedStructures[i]
			if (structure) {
				structure.isShared = true
				if (i >= 32)
					structure.highByte = (i - 32) >> 5
			}
		}
		loadedStructures.sharedLength = loadedStructures.length
		for (let id in existingStructures || []) {
			if (id >= 0) {
				let structure = loadedStructures[id]
				let existing = existingStructures[id]
				if (existing) {
					if (structure)
						(loadedStructures.restoreStructures || (loadedStructures.restoreStructures = []))[id] = structure
					loadedStructures[id] = existing
				}
			}
		}
		return this.structures = loadedStructures
	}
	decode(source, options) {
		return this.unpack(source, options)
	}
}
function getPosition() {
	return position
}
function checkedRead(options) {
	try {
		if (!currentUnpackr.trusted && !sequentialMode) {
			let sharedLength = currentStructures.sharedLength || 0
			if (sharedLength < currentStructures.length)
				currentStructures.length = sharedLength
		}
		let result
		if (currentUnpackr.randomAccessStructure && src[position] < 0x40 && src[position] >= 0x20 && readStruct) {
			result = readStruct(src, position, srcEnd, currentUnpackr)
			src = null // dispose of this so that recursive unpack calls don't save state
			if (!(options && options.lazy) && result)
				result = result.toJSON()
			position = srcEnd
		} else
			result = read()
		if (bundledStrings) { // bundled strings to skip past
			position = bundledStrings.postBundlePosition
			bundledStrings = null
		}
		if (sequentialMode)
			// we only need to restore the structures if there was an error, but if we completed a read,
			// we can clear this out and keep the structures we read
			currentStructures.restoreStructures = null

		if (position == srcEnd) {
			// finished reading this source, cleanup references
			if (currentStructures && currentStructures.restoreStructures)
				restoreStructures()
			currentStructures = null
			src = null
			if (referenceMap)
				referenceMap = null
		} else if (position > srcEnd) {
			// over read
			throw new Error('Unexpected end of MessagePack data')
		} else if (!sequentialMode) {
			let jsonView;
			try {
				jsonView = JSON.stringify(result, (_, value) => typeof value === "bigint" ? `${value}n` : value).slice(0, 100)
			} catch(error) {
				jsonView = '(JSON view not available ' + error + ')'
			}
			throw new Error('Data read, but end of buffer not reached ' + jsonView)
		}
		// else more to read, but we are reading sequentially, so don't clear source yet
		return result
	} catch(error) {
		if (currentStructures && currentStructures.restoreStructures)
			restoreStructures()
		clearSource()
		if (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer') || position > srcEnd) {
			error.incomplete = true
		}
		throw error
	}
}

function restoreStructures() {
	for (let id in currentStructures.restoreStructures) {
		currentStructures[id] = currentStructures.restoreStructures[id]
	}
	currentStructures.restoreStructures = null
}

function read() {
	let token = src[position++]
	if (token < 0xa0) {
		if (token < 0x80) {
			if (token < 0x40)
				return token
			else {
				let structure = currentStructures[token & 0x3f] ||
					currentUnpackr.getStructures && loadStructures()[token & 0x3f]
				if (structure) {
					if (!structure.read) {
						structure.read = createStructureReader(structure, token & 0x3f)
					}
					return structure.read()
				} else
					return token
			}
		} else if (token < 0x90) {
			// map
			token -= 0x80
			if (currentUnpackr.mapsAsObjects) {
				let object = {}
				for (let i = 0; i < token; i++) {
					let key = readKey()
					if (key === '__proto__')
						key = '__proto_'
					object[key] = read()
				}
				return object
			} else {
				let map = new Map()
				for (let i = 0; i < token; i++) {
					map.set(read(), read())
				}
				return map
			}
		} else {
			token -= 0x90
			let array = new Array(token)
			for (let i = 0; i < token; i++) {
				array[i] = read()
			}
			if (currentUnpackr.freezeData)
				return Object.freeze(array)
			return array
		}
	} else if (token < 0xc0) {
		// fixstr
		let length = token - 0xa0
		if (srcStringEnd >= position) {
			return srcString.slice(position - srcStringStart, (position += length) - srcStringStart)
		}
		if (srcStringEnd == 0 && srcEnd < 140) {
			// for small blocks, avoiding the overhead of the extract call is helpful
			let string = length < 16 ? shortStringInJS(length) : longStringInJS(length)
			if (string != null)
				return string
		}
		return readFixedString(length)
	} else {
		let value
		switch (token) {
			case 0xc0: return null
			case 0xc1:
				if (bundledStrings) {
					value = read() // followed by the length of the string in characters (not bytes!)
					if (value > 0)
						return bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value)
					else
						return bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 -= value)
				}
				return C1; // "never-used", return special object to denote that
			case 0xc2: return false
			case 0xc3: return true
			case 0xc4:
				// bin 8
				value = src[position++]
				if (value === undefined)
					throw new Error('Unexpected end of buffer')
				return readBin(value)
			case 0xc5:
				// bin 16
				value = dataView.getUint16(position)
				position += 2
				return readBin(value)
			case 0xc6:
				// bin 32
				value = dataView.getUint32(position)
				position += 4
				return readBin(value)
			case 0xc7:
				// ext 8
				return readExt(src[position++])
			case 0xc8:
				// ext 16
				value = dataView.getUint16(position)
				position += 2
				return readExt(value)
			case 0xc9:
				// ext 32
				value = dataView.getUint32(position)
				position += 4
				return readExt(value)
			case 0xca:
				value = dataView.getFloat32(position)
				if (currentUnpackr.useFloat32 > 2) {
					// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
					let multiplier = mult10[((src[position] & 0x7f) << 1) | (src[position + 1] >> 7)]
					position += 4
					return ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier
				}
				position += 4
				return value
			case 0xcb:
				value = dataView.getFloat64(position)
				position += 8
				return value
			// uint handlers
			case 0xcc:
				return src[position++]
			case 0xcd:
				value = dataView.getUint16(position)
				position += 2
				return value
			case 0xce:
				value = dataView.getUint32(position)
				position += 4
				return value
			case 0xcf:
				if (currentUnpackr.int64AsType === 'number') {
					value = dataView.getUint32(position) * 0x100000000
					value += dataView.getUint32(position + 4)
				} else if (currentUnpackr.int64AsType === 'string') {
					value = dataView.getBigUint64(position).toString()
				} else if (currentUnpackr.int64AsType === 'auto') {
					value = dataView.getBigUint64(position)
					if (value<=BigInt(2)<<BigInt(52)) value=Number(value)
				} else
					value = dataView.getBigUint64(position)
				position += 8
				return value

			// int handlers
			case 0xd0:
				return dataView.getInt8(position++)
			case 0xd1:
				value = dataView.getInt16(position)
				position += 2
				return value
			case 0xd2:
				value = dataView.getInt32(position)
				position += 4
				return value
			case 0xd3:
				if (currentUnpackr.int64AsType === 'number') {
					value = dataView.getInt32(position) * 0x100000000
					value += dataView.getUint32(position + 4)
				} else if (currentUnpackr.int64AsType === 'string') {
					value = dataView.getBigInt64(position).toString()
				} else if (currentUnpackr.int64AsType === 'auto') {
					value = dataView.getBigInt64(position)
					if (value>=BigInt(-2)<<BigInt(52)&&value<=BigInt(2)<<BigInt(52)) value=Number(value)
				} else
					value = dataView.getBigInt64(position)
				position += 8
				return value

			case 0xd4:
				// fixext 1
				value = src[position++]
				if (value == 0x72) {
					return recordDefinition(src[position++] & 0x3f)
				} else {
					let extension = currentExtensions[value]
					if (extension) {
						if (extension.read) {
							position++ // skip filler byte
							return extension.read(read())
						} else if (extension.noBuffer) {
							position++ // skip filler byte
							return extension()
						} else
							return extension(src.subarray(position, ++position))
					} else
						throw new Error('Unknown extension ' + value)
				}
			case 0xd5:
				// fixext 2
				value = src[position]
				if (value == 0x72) {
					position++
					return recordDefinition(src[position++] & 0x3f, src[position++])
				} else
					return readExt(2)
			case 0xd6:
				// fixext 4
				return readExt(4)
			case 0xd7:
				// fixext 8
				return readExt(8)
			case 0xd8:
				// fixext 16
				return readExt(16)
			case 0xd9:
			// str 8
				value = src[position++]
				if (srcStringEnd >= position) {
					return srcString.slice(position - srcStringStart, (position += value) - srcStringStart)
				}
				return readString8(value)
			case 0xda:
			// str 16
				value = dataView.getUint16(position)
				position += 2
				if (srcStringEnd >= position) {
					return srcString.slice(position - srcStringStart, (position += value) - srcStringStart)
				}
				return readString16(value)
			case 0xdb:
			// str 32
				value = dataView.getUint32(position)
				position += 4
				if (srcStringEnd >= position) {
					return srcString.slice(position - srcStringStart, (position += value) - srcStringStart)
				}
				return readString32(value)
			case 0xdc:
			// array 16
				value = dataView.getUint16(position)
				position += 2
				return readArray(value)
			case 0xdd:
			// array 32
				value = dataView.getUint32(position)
				position += 4
				return readArray(value)
			case 0xde:
			// map 16
				value = dataView.getUint16(position)
				position += 2
				return readMap(value)
			case 0xdf:
			// map 32
				value = dataView.getUint32(position)
				position += 4
				return readMap(value)
			default: // negative int
				if (token >= 0xe0)
					return token - 0x100
				if (token === undefined) {
					let error = new Error('Unexpected end of MessagePack data')
					error.incomplete = true
					throw error
				}
				throw new Error('Unknown MessagePack token ' + token)

		}
	}
}
const validName = /^[a-zA-Z_$][a-zA-Z\d_$]*$/
function createStructureReader(structure, firstId) {
	function readObject() {
		// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function
		if (readObject.count++ > inlineObjectReadThreshold) {
			let readObject = structure.read = (new Function('r', 'return function(){return ' + (currentUnpackr.freezeData ? 'Object.freeze' : '') +
				'({' + structure.map(key => key === '__proto__' ? '__proto_:r()' : validName.test(key) ? key + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '})}'))(read)
			if (structure.highByte === 0)
				structure.read = createSecondByteReader(firstId, structure.read)
			return readObject() // second byte is already read, if there is one so immediately read object
		}
		let object = {}
		for (let i = 0, l = structure.length; i < l; i++) {
			let key = structure[i]
			if (key === '__proto__')
				key = '__proto_'
			object[key] = read()
		}
		if (currentUnpackr.freezeData)
			return Object.freeze(object);
		return object
	}
	readObject.count = 0
	if (structure.highByte === 0) {
		return createSecondByteReader(firstId, readObject)
	}
	return readObject
}

const createSecondByteReader = (firstId, read0) => {
	return function() {
		let highByte = src[position++]
		if (highByte === 0)
			return read0()
		let id = firstId < 32 ? -(firstId + (highByte << 5)) : firstId + (highByte << 5)
		let structure = currentStructures[id] || loadStructures()[id]
		if (!structure) {
			throw new Error('Record id is not defined for ' + id)
		}
		if (!structure.read)
			structure.read = createStructureReader(structure, firstId)
		return structure.read()
	}
}

function loadStructures() {
	let loadedStructures = saveState(() => {
		// save the state in case getStructures modifies our buffer
		src = null
		return currentUnpackr.getStructures()
	})
	return currentStructures = currentUnpackr._mergeStructures(loadedStructures, currentStructures)
}

var readFixedString = readStringJS
var readString8 = readStringJS
var readString16 = readStringJS
var readString32 = readStringJS
let isNativeAccelerationEnabled = false

function setExtractor(extractStrings) {
	isNativeAccelerationEnabled = true
	readFixedString = readString(1)
	readString8 = readString(2)
	readString16 = readString(3)
	readString32 = readString(5)
	function readString(headerLength) {
		return function readString(length) {
			let string = strings[stringPosition++]
			if (string == null) {
				if (bundledStrings)
					return readStringJS(length)
				let byteOffset = src.byteOffset
				let extraction = extractStrings(position - headerLength + byteOffset, srcEnd + byteOffset, src.buffer)
				if (typeof extraction == 'string') {
					string = extraction
					strings = EMPTY_ARRAY
				} else {
					strings = extraction
					stringPosition = 1
					srcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings
					string = strings[0]
					if (string === undefined)
						throw new Error('Unexpected end of buffer')
				}
			}
			let srcStringLength = string.length
			if (srcStringLength <= length) {
				position += length
				return string
			}
			srcString = string
			srcStringStart = position
			srcStringEnd = position + srcStringLength
			position += length
			return string.slice(0, length) // we know we just want the beginning
		}
	}
}
function readStringJS(length) {
	let result
	if (length < 16) {
		if (result = shortStringInJS(length))
			return result
	}
	if (length > 64 && decoder)
		return decoder.decode(src.subarray(position, position += length))
	const end = position + length
	const units = []
	result = ''
	while (position < end) {
		const byte1 = src[position++]
		if ((byte1 & 0x80) === 0) {
			// 1 byte
			units.push(byte1)
		} else if ((byte1 & 0xe0) === 0xc0) {
			// 2 bytes
			const byte2 = src[position++] & 0x3f
			units.push(((byte1 & 0x1f) << 6) | byte2)
		} else if ((byte1 & 0xf0) === 0xe0) {
			// 3 bytes
			const byte2 = src[position++] & 0x3f
			const byte3 = src[position++] & 0x3f
			units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)
		} else if ((byte1 & 0xf8) === 0xf0) {
			// 4 bytes
			const byte2 = src[position++] & 0x3f
			const byte3 = src[position++] & 0x3f
			const byte4 = src[position++] & 0x3f
			let unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4
			if (unit > 0xffff) {
				unit -= 0x10000
				units.push(((unit >>> 10) & 0x3ff) | 0xd800)
				unit = 0xdc00 | (unit & 0x3ff)
			}
			units.push(unit)
		} else {
			units.push(byte1)
		}

		if (units.length >= 0x1000) {
			result += fromCharCode.apply(String, units)
			units.length = 0
		}
	}

	if (units.length > 0) {
		result += fromCharCode.apply(String, units)
	}

	return result
}
function readString(source, start, length) {
	let existingSrc = src;
	src = source;
	position = start;
	try {
		return readStringJS(length);
	} finally {
		src = existingSrc;
	}
}

function readArray(length) {
	let array = new Array(length)
	for (let i = 0; i < length; i++) {
		array[i] = read()
	}
	if (currentUnpackr.freezeData)
		return Object.freeze(array)
	return array
}

function readMap(length) {
	if (currentUnpackr.mapsAsObjects) {
		let object = {}
		for (let i = 0; i < length; i++) {
			let key = readKey()
			if (key === '__proto__')
				key = '__proto_';
			object[key] = read()
		}
		return object
	} else {
		let map = new Map()
		for (let i = 0; i < length; i++) {
			map.set(read(), read())
		}
		return map
	}
}

var fromCharCode = String.fromCharCode
function longStringInJS(length) {
	let start = position
	let bytes = new Array(length)
	for (let i = 0; i < length; i++) {
		const byte = src[position++];
		if ((byte & 0x80) > 0) {
				position = start
				return
			}
			bytes[i] = byte
		}
		return fromCharCode.apply(String, bytes)
}
function shortStringInJS(length) {
	if (length < 4) {
		if (length < 2) {
			if (length === 0)
				return ''
			else {
				let a = src[position++]
				if ((a & 0x80) > 1) {
					position -= 1
					return
				}
				return fromCharCode(a)
			}
		} else {
			let a = src[position++]
			let b = src[position++]
			if ((a & 0x80) > 0 || (b & 0x80) > 0) {
				position -= 2
				return
			}
			if (length < 3)
				return fromCharCode(a, b)
			let c = src[position++]
			if ((c & 0x80) > 0) {
				position -= 3
				return
			}
			return fromCharCode(a, b, c)
		}
	} else {
		let a = src[position++]
		let b = src[position++]
		let c = src[position++]
		let d = src[position++]
		if ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {
			position -= 4
			return
		}
		if (length < 6) {
			if (length === 4)
				return fromCharCode(a, b, c, d)
			else {
				let e = src[position++]
				if ((e & 0x80) > 0) {
					position -= 5
					return
				}
				return fromCharCode(a, b, c, d, e)
			}
		} else if (length < 8) {
			let e = src[position++]
			let f = src[position++]
			if ((e & 0x80) > 0 || (f & 0x80) > 0) {
				position -= 6
				return
			}
			if (length < 7)
				return fromCharCode(a, b, c, d, e, f)
			let g = src[position++]
			if ((g & 0x80) > 0) {
				position -= 7
				return
			}
			return fromCharCode(a, b, c, d, e, f, g)
		} else {
			let e = src[position++]
			let f = src[position++]
			let g = src[position++]
			let h = src[position++]
			if ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {
				position -= 8
				return
			}
			if (length < 10) {
				if (length === 8)
					return fromCharCode(a, b, c, d, e, f, g, h)
				else {
					let i = src[position++]
					if ((i & 0x80) > 0) {
						position -= 9
						return
					}
					return fromCharCode(a, b, c, d, e, f, g, h, i)
				}
			} else if (length < 12) {
				let i = src[position++]
				let j = src[position++]
				if ((i & 0x80) > 0 || (j & 0x80) > 0) {
					position -= 10
					return
				}
				if (length < 11)
					return fromCharCode(a, b, c, d, e, f, g, h, i, j)
				let k = src[position++]
				if ((k & 0x80) > 0) {
					position -= 11
					return
				}
				return fromCharCode(a, b, c, d, e, f, g, h, i, j, k)
			} else {
				let i = src[position++]
				let j = src[position++]
				let k = src[position++]
				let l = src[position++]
				if ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {
					position -= 12
					return
				}
				if (length < 14) {
					if (length === 12)
						return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)
					else {
						let m = src[position++]
						if ((m & 0x80) > 0) {
							position -= 13
							return
						}
						return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)
					}
				} else {
					let m = src[position++]
					let n = src[position++]
					if ((m & 0x80) > 0 || (n & 0x80) > 0) {
						position -= 14
						return
					}
					if (length < 15)
						return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)
					let o = src[position++]
					if ((o & 0x80) > 0) {
						position -= 15
						return
					}
					return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
				}
			}
		}
	}
}

function readOnlyJSString() {
	let token = src[position++]
	let length
	if (token < 0xc0) {
		// fixstr
		length = token - 0xa0
	} else {
		switch(token) {
			case 0xd9:
			// str 8
				length = src[position++]
				break
			case 0xda:
			// str 16
				length = dataView.getUint16(position)
				position += 2
				break
			case 0xdb:
			// str 32
				length = dataView.getUint32(position)
				position += 4
				break
			default:
				throw new Error('Expected string')
		}
	}
	return readStringJS(length)
}


function readBin(length) {
	return currentUnpackr.copyBuffers ?
		// specifically use the copying slice (not the node one)
		Uint8Array.prototype.slice.call(src, position, position += length) :
		src.subarray(position, position += length)
}
function readExt(length) {
	let type = src[position++]
	if (currentExtensions[type]) {
		let end
		return currentExtensions[type](src.subarray(position, end = (position += length)), (readPosition) => {
			position = readPosition;
			try {
				return read();
			} finally {
				position = end;
			}
		})
	}
	else
		throw new Error('Unknown extension type ' + type)
}

var keyCache = new Array(4096)
function readKey() {
	let length = src[position++]
	if (length >= 0xa0 && length < 0xc0) {
		// fixstr, potentially use key cache
		length = length - 0xa0
		if (srcStringEnd >= position) // if it has been extracted, must use it (and faster anyway)
			return srcString.slice(position - srcStringStart, (position += length) - srcStringStart)
		else if (!(srcStringEnd == 0 && srcEnd < 180))
			return readFixedString(length)
	} else { // not cacheable, go back and do a standard read
		position--
		return asSafeString(read())
	}
	let key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff
	let entry = keyCache[key]
	let checkPosition = position
	let end = position + length - 3
	let chunk
	let i = 0
	if (entry && entry.bytes == length) {
		while (checkPosition < end) {
			chunk = dataView.getUint32(checkPosition)
			if (chunk != entry[i++]) {
				checkPosition = 0x70000000
				break
			}
			checkPosition += 4
		}
		end += 3
		while (checkPosition < end) {
			chunk = src[checkPosition++]
			if (chunk != entry[i++]) {
				checkPosition = 0x70000000
				break
			}
		}
		if (checkPosition === end) {
			position = checkPosition
			return entry.string
		}
		end -= 3
		checkPosition = position
	}
	entry = []
	keyCache[key] = entry
	entry.bytes = length
	while (checkPosition < end) {
		chunk = dataView.getUint32(checkPosition)
		entry.push(chunk)
		checkPosition += 4
	}
	end += 3
	while (checkPosition < end) {
		chunk = src[checkPosition++]
		entry.push(chunk)
	}
	// for small blocks, avoiding the overhead of the extract call is helpful
	let string = length < 16 ? shortStringInJS(length) : longStringInJS(length)
	if (string != null)
		return entry.string = string
	return entry.string = readFixedString(length)
}

function asSafeString(property) {
	// protect against expensive (DoS) string conversions
	if (typeof property === 'string') return property;
	if (typeof property === 'number' || typeof property === 'boolean' || typeof property === 'bigint') return property.toString();
	if (property == null) return property + '';
	if (currentUnpackr.allowArraysInMapKeys && Array.isArray(property) && property.flat().every(item => ['string', 'number', 'boolean', 'bigint'].includes(typeof item))) {
		return property.flat().toString();
	}
	throw new Error(`Invalid property type for record: ${typeof property}`);
}
// the registration of the record definition extension (as "r")
const recordDefinition = (id, highByte) => {
	let structure = read().map(asSafeString) // ensure that all keys are strings and
	// that the array is mutable
	let firstByte = id
	if (highByte !== undefined) {
		id = id < 32 ? -((highByte << 5) + id) : ((highByte << 5) + id)
		structure.highByte = highByte
	}
	let existingStructure = currentStructures[id]
	// If it is a shared structure, we need to restore any changes after reading.
	// Also in sequential mode, we may get incomplete reads and thus errors, and we need to restore
	// to the state prior to an incomplete read in order to properly resume.
	if (existingStructure && (existingStructure.isShared || sequentialMode)) {
		(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure
	}
	currentStructures[id] = structure
	structure.read = createStructureReader(structure, firstByte)
	return structure.read()
}
currentExtensions[0] = () => {} // notepack defines extension 0 to mean undefined, so use that as the default here
currentExtensions[0].noBuffer = true

currentExtensions[0x42] = (data) => {
	// decode bigint
	let length = data.length;
	let value = BigInt(data[0] & 0x80 ? data[0] - 0x100 : data[0]);
	for (let i = 1; i < length; i++) {
		value <<= BigInt(8);
		value += BigInt(data[i]);
	}
	return value;
}

let errors = { Error, TypeError, ReferenceError };
currentExtensions[0x65] = () => {
	let data = read()
	return (errors[data[0]] || Error)(data[1], { cause: data[2] })
}

currentExtensions[0x69] = (data) => {
	// id extension (for structured clones)
	if (currentUnpackr.structuredClone === false) throw new Error('Structured clone extension is disabled')
	let id = dataView.getUint32(position - 4)
	if (!referenceMap)
		referenceMap = new Map()
	let token = src[position]
	let target
	// TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read
	// ahead past references to record structure definitions
	if (token >= 0x90 && token < 0xa0 || token == 0xdc || token == 0xdd)
		target = []
	else
		target = {}

	let refEntry = { target } // a placeholder object
	referenceMap.set(id, refEntry)
	let targetProperties = read() // read the next value as the target object to id
	if (refEntry.used) // there is a cycle, so we have to assign properties to original target
		return Object.assign(target, targetProperties)
	refEntry.target = targetProperties // the placeholder wasn't used, replace with the deserialized one
	return targetProperties // no cycle, can just use the returned read object
}

currentExtensions[0x70] = (data) => {
	// pointer extension (for structured clones)
	if (currentUnpackr.structuredClone === false) throw new Error('Structured clone extension is disabled')
	let id = dataView.getUint32(position - 4)
	let refEntry = referenceMap.get(id)
	refEntry.used = true
	return refEntry.target
}

currentExtensions[0x73] = () => new Set(read())

const typedArrays = ['Int8','Uint8','Uint8Clamped','Int16','Uint16','Int32','Uint32','Float32','Float64','BigInt64','BigUint64'].map(type => type + 'Array')

let glbl = typeof globalThis === 'object' ? globalThis : window;
currentExtensions[0x74] = (data) => {
	let typeCode = data[0]
	let typedArrayName = typedArrays[typeCode]
	if (!typedArrayName) {
		if (typeCode === 16) {
			let ab = new ArrayBuffer(data.length - 1)
			let u8 = new Uint8Array(ab)
			u8.set(data.subarray(1))
			return ab;
		}
		throw new Error('Could not find typed array for code ' + typeCode)
	}
	// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned
	return new glbl[typedArrayName](Uint8Array.prototype.slice.call(data, 1).buffer)
}
currentExtensions[0x78] = () => {
	let data = read()
	return new RegExp(data[0], data[1])
}
const TEMP_BUNDLE = []
currentExtensions[0x62] = (data) => {
	let dataSize = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]
	let dataPosition = position
	position += dataSize - data.length
	bundledStrings = TEMP_BUNDLE
	bundledStrings = [readOnlyJSString(), readOnlyJSString()]
	bundledStrings.position0 = 0
	bundledStrings.position1 = 0
	bundledStrings.postBundlePosition = position
	position = dataPosition
	return read()
}

currentExtensions[0xff] = (data) => {
	// 32-bit date extension
	if (data.length == 4)
		return new Date((data[0] * 0x1000000 + (data[1] << 16) + (data[2] << 8) + data[3]) * 1000)
	else if (data.length == 8)
		return new Date(
			((data[0] << 22) + (data[1] << 14) + (data[2] << 6) + (data[3] >> 2)) / 1000000 +
			((data[3] & 0x3) * 0x100000000 + data[4] * 0x1000000 + (data[5] << 16) + (data[6] << 8) + data[7]) * 1000)
	else if (data.length == 12)// TODO: Implement support for negative
		return new Date(
			((data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]) / 1000000 +
			(((data[4] & 0x80) ? -0x1000000000000 : 0) + data[6] * 0x10000000000 + data[7] * 0x100000000 + data[8] * 0x1000000 + (data[9] << 16) + (data[10] << 8) + data[11]) * 1000)
	else
		return new Date('invalid')
} // notepack defines extension 0 to mean undefined, so use that as the default here
// registration of bulk record definition?
// currentExtensions[0x52] = () =>

function saveState(callback) {
	if (onSaveState)
		onSaveState();
	let savedSrcEnd = srcEnd
	let savedPosition = position
	let savedStringPosition = stringPosition
	let savedSrcStringStart = srcStringStart
	let savedSrcStringEnd = srcStringEnd
	let savedSrcString = srcString
	let savedStrings = strings
	let savedReferenceMap = referenceMap
	let savedBundledStrings = bundledStrings

	// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)
	let savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed
	let savedStructures = currentStructures
	let savedStructuresContents = currentStructures.slice(0, currentStructures.length)
	let savedPackr = currentUnpackr
	let savedSequentialMode = sequentialMode
	let value = callback()
	srcEnd = savedSrcEnd
	position = savedPosition
	stringPosition = savedStringPosition
	srcStringStart = savedSrcStringStart
	srcStringEnd = savedSrcStringEnd
	srcString = savedSrcString
	strings = savedStrings
	referenceMap = savedReferenceMap
	bundledStrings = savedBundledStrings
	src = savedSrc
	sequentialMode = savedSequentialMode
	currentStructures = savedStructures
	currentStructures.splice(0, currentStructures.length, ...savedStructuresContents)
	currentUnpackr = savedPackr
	dataView = new DataView(src.buffer, src.byteOffset, src.byteLength)
	return value
}
function clearSource() {
	src = null
	referenceMap = null
	currentStructures = null
}

function addExtension(extension) {
	if (extension.unpack)
		currentExtensions[extension.type] = extension.unpack
	else
		currentExtensions[extension.type] = extension
}

const mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding
for (let i = 0; i < 256; i++) {
	mult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103))
}
const Decoder = Unpackr
var defaultUnpackr = new Unpackr({ useRecords: false })
const unpack = defaultUnpackr.unpack
const unpackMultiple = defaultUnpackr.unpackMultiple
const decode = defaultUnpackr.unpack
const FLOAT32_OPTIONS = {
	NEVER: 0,
	ALWAYS: 1,
	DECIMAL_ROUND: 3,
	DECIMAL_FIT: 4
}
let f32Array = new Float32Array(1)
let u8Array = new Uint8Array(f32Array.buffer, 0, 4)
function roundFloat32(float32Number) {
	f32Array[0] = float32Number
	let multiplier = mult10[((u8Array[3] & 0x7f) << 1) | (u8Array[2] >> 7)]
	return ((multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5)) >> 0) / multiplier
}
function setReadStruct(updatedReadStruct, loadedStructs, saveState) {
	readStruct = updatedReadStruct;
	onLoadedStructures = loadedStructs;
	onSaveState = saveState;
}


}),

});
/************************************************************************/
// The module cache
var __webpack_module_cache__ = {};

// The require function
function __webpack_require__(moduleId) {

// Check if module is in cache
var cachedModule = __webpack_module_cache__[moduleId];
if (cachedModule !== undefined) {
return cachedModule.exports;
}
// Create a new module (and put it into the cache)
var module = (__webpack_module_cache__[moduleId] = {
exports: {}
});
// Execute the module function
__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);

// Return the exports of the module
return module.exports;

}

/************************************************************************/
// webpack/runtime/compat_get_default_export
(() => {
// getDefaultExport function for compatibility with non-ESM modules
__webpack_require__.n = (module) => {
	var getter = module && module.__esModule ?
		() => (module['default']) :
		() => (module);
	__webpack_require__.d(getter, { a: getter });
	return getter;
};

})();
// webpack/runtime/define_property_getters
(() => {
__webpack_require__.d = (exports, definition) => {
	for(var key in definition) {
        if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
            Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
        }
    }
};
})();
// webpack/runtime/global
(() => {
__webpack_require__.g = (() => {
	if (typeof globalThis === 'object') return globalThis;
	try {
		return this || new Function('return this')();
	} catch (e) {
		if (typeof window === 'object') return window;
	}
})();
})();
// webpack/runtime/has_own_property
(() => {
__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
})();
// webpack/runtime/make_namespace_object
(() => {
// define __esModule on exports
__webpack_require__.r = (exports) => {
	if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
		Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
	}
	Object.defineProperty(exports, '__esModule', { value: true });
};
})();
// webpack/runtime/rspack_version
(() => {
__webpack_require__.rv = () => ("1.3.8")
})();
// webpack/runtime/rspack_unique_id
(() => {
__webpack_require__.ruid = "bundler=rspack@1.3.8";

})();
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";

/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* ESM import */var _colyseus_msgpackr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @colyseus/msgpackr */ "./node_modules/.pnpm/@colyseus+msgpackr@1.11.2/node_modules/@colyseus/msgpackr/index.js");
/* ESM import */var _colyseus_schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @colyseus/schema */ "./node_modules/.pnpm/@colyseus+schema@3.0.35/node_modules/@colyseus/schema/build/umd/index.js");
/* ESM import */var _colyseus_schema__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_colyseus_schema__WEBPACK_IMPORTED_MODULE_1__);
/* ESM import */var _schemas_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schemas.ts */ "./src/schemas.ts");
/* ESM import */var _enums_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./enums.ts */ "./src/enums.ts");
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/.pnpm/console-browserify@1.2.0/node_modules/console-browserify/index.js */ "./node_modules/.pnpm/console-browserify@1.2.0/node_modules/console-browserify/index.js");
function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _assert_this_initialized(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _call_super(_this, derived, args) {
    derived = _get_prototype_of(derived);
    return _possible_constructor_return(_this, _is_native_reflect_construct() ? Reflect.construct(derived, args || [], _get_prototype_of(_this).constructor) : derived.apply(_this, args));
}
function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
    } else {
        _get = function get(target, property, receiver) {
            var base = _super_prop_base(target, property);
            if (!base) return;
            var desc = Object.getOwnPropertyDescriptor(base, property);
            if (desc.get) {
                return desc.get.call(receiver || target);
            }
            return desc.value;
        };
    }
    return _get(target, property, receiver || target);
}
function _get_prototype_of(o) {
    _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of(o);
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of(subClass, superClass);
}
function _iterable_to_array(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _possible_constructor_return(self, call) {
    if (call && (_type_of(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized(self);
}
function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of(o, p);
}
function _super_prop_base(object, property) {
    while(!Object.prototype.hasOwnProperty.call(object, property)){
        object = _get_prototype_of(object);
        if (object === null) break;
    }
    return object;
}
function _to_consumable_array(arr) {
    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _type_of(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}
function _is_native_reflect_construct() {
    try {
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct = function() {
        return !!result;
    })();
}




var filteredMessages = [
    "Ping",
    "Pong",
    "PositionUpdate"
];
// @ts-ignore
var origWS = unsafeWindow.WebSocket;
var state = new _schemas_ts__WEBPACK_IMPORTED_MODULE_2__.MyRoomState();
var decoder = new _colyseus_schema__WEBPACK_IMPORTED_MODULE_1__.Decoder(state);
window.state = state;
// @ts-ignore
unsafeWindow.decoder = decoder;
function processPacket(buffer, source) {
    var it = {
        offset: 1
    };
    var code = buffer[0];
    if (code === _enums_ts__WEBPACK_IMPORTED_MODULE_3__.Protocol.JOIN_ROOM) {
        return [
            code,
            "joining!"
        ];
    } else if (code === _enums_ts__WEBPACK_IMPORTED_MODULE_3__.Protocol.ROOM_DATA) {
        var type = _colyseus_schema__WEBPACK_IMPORTED_MODULE_1__.decode.stringCheck(buffer, it) ? _colyseus_schema__WEBPACK_IMPORTED_MODULE_1__.decode.string(buffer, it) : _colyseus_schema__WEBPACK_IMPORTED_MODULE_1__.decode.number(buffer, it);
        var message = buffer.byteLength > it.offset ? (0,_colyseus_msgpackr__WEBPACK_IMPORTED_MODULE_0__.unpack)(buffer, {
            start: it.offset
        }) : undefined;
        var _CustomMessageType_type;
        if (filteredMessages.indexOf(_enums_ts__WEBPACK_IMPORTED_MODULE_3__.CustomMessageType[type]) === -1) console.log(source === "r" ? "recv" : "send", (_CustomMessageType_type = _enums_ts__WEBPACK_IMPORTED_MODULE_3__.CustomMessageType[type]) !== null && _CustomMessageType_type !== void 0 ? _CustomMessageType_type : type, message !== null && message !== void 0 ? message : "empty");
        return [
            code,
            _enums_ts__WEBPACK_IMPORTED_MODULE_3__.CustomMessageType[type],
            message
        ];
    } else if (code === _enums_ts__WEBPACK_IMPORTED_MODULE_3__.Protocol.ROOM_STATE) {
        return decoder.decode(buffer, it);
    } else if (code === _enums_ts__WEBPACK_IMPORTED_MODULE_3__.Protocol.ROOM_STATE_PATCH) {
        return decoder.decode(buffer, it);
    } else if (code === _enums_ts__WEBPACK_IMPORTED_MODULE_3__.Protocol.LEAVE_ROOM) {
        return [
            code,
            "Leaving room!"
        ];
    } else {
        return [
            code,
            "?"
        ];
    }
}
function encodeRoomData(type, message) {
    var it = {
        offset: 1
    };
    var packr = new _colyseus_msgpackr__WEBPACK_IMPORTED_MODULE_0__.Packr();
    packr.encode(undefined);
    packr.buffer[0] = _enums_ts__WEBPACK_IMPORTED_MODULE_3__.Protocol.ROOM_DATA;
    if (typeof type === "string") {
        _colyseus_schema__WEBPACK_IMPORTED_MODULE_1__.encode.string(packr.buffer, type, it);
    } else {
        _colyseus_schema__WEBPACK_IMPORTED_MODULE_1__.encode.number(packr.buffer, type, it);
    }
    packr.position = 0;
    return message !== undefined ? packr.pack(message, 2048 + it.offset) // 2048 = RESERVE_START_SPACE
     : packr.buffer.subarray(0, it.offset);
}
// @ts-ignore
unsafeWindow.sendCustom = function(type, message) {
    var // @ts-ignore
    _unsafeWindow_currentSocket;
    var buf = encodeRoomData(type, message);
    (_unsafeWindow_currentSocket = unsafeWindow.currentSocket) === null || _unsafeWindow_currentSocket === void 0 ? void 0 : _unsafeWindow_currentSocket.send(buf);
};
var HookedWS = /*#__PURE__*/ function(origWS) {
    "use strict";
    _inherits(HookedWS, origWS);
    function HookedWS() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _class_call_check(this, HookedWS);
        var _this;
        console.log("connecting to ".concat(args[0]));
        _this = _call_super(this, HookedWS, _to_consumable_array(args));
        // @ts-ignore
        unsafeWindow.currentSocket = _this;
        // @ts-ignore
        _this.send = function(packet) {
            var buffer = new Uint8Array(packet);
            try {
                var resp = processPacket(buffer, "s");
            } catch (e) {}
            return _get((_assert_this_initialized(_this), _get_prototype_of(HookedWS.prototype)), "send", _this).call(_this, packet);
        };
        // @ts-ignore
        _this.addEventListener("message", function(evt) {
            var buffer = new Uint8Array(evt.data);
            try {
                processPacket(buffer, "r");
            } catch (e) {}
        });
        return _this;
    }
    return HookedWS;
}(origWS);
// @ts-ignore
unsafeWindow.WebSocket = HookedWS;

})();

})()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AY29seXNldXMrc2NoZW1hQDMuMC4zNS9ub2RlX21vZHVsZXMvQGNvbHlzZXVzL3NjaGVtYS9idWlsZC91bWQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2Fzc2VydEAyLjEuMC9ub2RlX21vZHVsZXMvYXNzZXJ0L2J1aWxkL2Fzc2VydC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vYXNzZXJ0QDIuMS4wL25vZGVfbW9kdWxlcy9hc3NlcnQvYnVpbGQvaW50ZXJuYWwvYXNzZXJ0L2Fzc2VydGlvbl9lcnJvci5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vYXNzZXJ0QDIuMS4wL25vZGVfbW9kdWxlcy9hc3NlcnQvYnVpbGQvaW50ZXJuYWwvZXJyb3JzLmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy8ucG5wbS9hc3NlcnRAMi4xLjAvbm9kZV9tb2R1bGVzL2Fzc2VydC9idWlsZC9pbnRlcm5hbC91dGlsL2NvbXBhcmlzb25zLmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy8ucG5wbS9iYXNlNjQtanNAMS41LjEvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vYnVmZmVyQDYuMC4zL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2NhbGwtYmluZC1hcHBseS1oZWxwZXJzQDEuMC4yL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQtYXBwbHktaGVscGVycy9hY3R1YWxBcHBseS5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vY2FsbC1iaW5kLWFwcGx5LWhlbHBlcnNAMS4wLjIvbm9kZV9tb2R1bGVzL2NhbGwtYmluZC1hcHBseS1oZWxwZXJzL2FwcGx5QmluZC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vY2FsbC1iaW5kLWFwcGx5LWhlbHBlcnNAMS4wLjIvbm9kZV9tb2R1bGVzL2NhbGwtYmluZC1hcHBseS1oZWxwZXJzL2Z1bmN0aW9uQXBwbHkuanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2NhbGwtYmluZC1hcHBseS1oZWxwZXJzQDEuMC4yL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQtYXBwbHktaGVscGVycy9mdW5jdGlvbkNhbGwuanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2NhbGwtYmluZC1hcHBseS1oZWxwZXJzQDEuMC4yL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQtYXBwbHktaGVscGVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vY2FsbC1iaW5kLWFwcGx5LWhlbHBlcnNAMS4wLjIvbm9kZV9tb2R1bGVzL2NhbGwtYmluZC1hcHBseS1oZWxwZXJzL3JlZmxlY3RBcHBseS5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vY2FsbC1iaW5kQDEuMC44L25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvY2FsbEJvdW5kLmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy8ucG5wbS9jYWxsLWJpbmRAMS4wLjgvbm9kZV9tb2R1bGVzL2NhbGwtYmluZC9pbmRleC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vY2FsbC1ib3VuZEAxLjAuNC9ub2RlX21vZHVsZXMvY2FsbC1ib3VuZC9pbmRleC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vY29uc29sZS1icm93c2VyaWZ5QDEuMi4wL25vZGVfbW9kdWxlcy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2RlZmluZS1kYXRhLXByb3BlcnR5QDEuMS40L25vZGVfbW9kdWxlcy9kZWZpbmUtZGF0YS1wcm9wZXJ0eS9pbmRleC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vZGVmaW5lLXByb3BlcnRpZXNAMS4yLjEvbm9kZV9tb2R1bGVzL2RlZmluZS1wcm9wZXJ0aWVzL2luZGV4LmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy8ucG5wbS9kdW5kZXItcHJvdG9AMS4wLjEvbm9kZV9tb2R1bGVzL2R1bmRlci1wcm90by9nZXQuanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2VzLWRlZmluZS1wcm9wZXJ0eUAxLjAuMS9ub2RlX21vZHVsZXMvZXMtZGVmaW5lLXByb3BlcnR5L2luZGV4LmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy8ucG5wbS9lcy1lcnJvcnNAMS4zLjAvbm9kZV9tb2R1bGVzL2VzLWVycm9ycy9ldmFsLmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy8ucG5wbS9lcy1lcnJvcnNAMS4zLjAvbm9kZV9tb2R1bGVzL2VzLWVycm9ycy9pbmRleC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vZXMtZXJyb3JzQDEuMy4wL25vZGVfbW9kdWxlcy9lcy1lcnJvcnMvcmFuZ2UuanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2VzLWVycm9yc0AxLjMuMC9ub2RlX21vZHVsZXMvZXMtZXJyb3JzL3JlZi5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vZXMtZXJyb3JzQDEuMy4wL25vZGVfbW9kdWxlcy9lcy1lcnJvcnMvc3ludGF4LmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy8ucG5wbS9lcy1lcnJvcnNAMS4zLjAvbm9kZV9tb2R1bGVzL2VzLWVycm9ycy90eXBlLmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy8ucG5wbS9lcy1lcnJvcnNAMS4zLjAvbm9kZV9tb2R1bGVzL2VzLWVycm9ycy91cmkuanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2VzLW9iamVjdC1hdG9tc0AxLjEuMS9ub2RlX21vZHVsZXMvZXMtb2JqZWN0LWF0b21zL2luZGV4LmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy8ucG5wbS9mb3ItZWFjaEAwLjMuNS9ub2RlX21vZHVsZXMvZm9yLWVhY2gvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2Z1bmN0aW9uLWJpbmRAMS4xLjIvbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW1wbGVtZW50YXRpb24uanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2Z1bmN0aW9uLWJpbmRAMS4xLjIvbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2dldC1pbnRyaW5zaWNAMS4zLjAvbm9kZV9tb2R1bGVzL2dldC1pbnRyaW5zaWMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2dldC1wcm90b0AxLjAuMS9ub2RlX21vZHVsZXMvZ2V0LXByb3RvL09iamVjdC5nZXRQcm90b3R5cGVPZi5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vZ2V0LXByb3RvQDEuMC4xL25vZGVfbW9kdWxlcy9nZXQtcHJvdG8vUmVmbGVjdC5nZXRQcm90b3R5cGVPZi5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vZ2V0LXByb3RvQDEuMC4xL25vZGVfbW9kdWxlcy9nZXQtcHJvdG8vaW5kZXguanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2dvcGRAMS4yLjAvbm9kZV9tb2R1bGVzL2dvcGQvZ09QRC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vZ29wZEAxLjIuMC9ub2RlX21vZHVsZXMvZ29wZC9pbmRleC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vaGFzLXByb3BlcnR5LWRlc2NyaXB0b3JzQDEuMC4yL25vZGVfbW9kdWxlcy9oYXMtcHJvcGVydHktZGVzY3JpcHRvcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2hhcy1zeW1ib2xzQDEuMS4wL25vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9pbmRleC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vaGFzLXN5bWJvbHNAMS4xLjAvbm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL3NoYW1zLmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy8ucG5wbS9oYXMtdG9zdHJpbmd0YWdAMS4wLjIvbm9kZV9tb2R1bGVzL2hhcy10b3N0cmluZ3RhZy9zaGFtcy5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vaGFzb3duQDIuMC4yL25vZGVfbW9kdWxlcy9oYXNvd24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2llZWU3NTRAMS4yLjEvbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2luaGVyaXRzQDIuMC40L25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy8ucG5wbS9pcy1hcmd1bWVudHNAMS4yLjAvbm9kZV9tb2R1bGVzL2lzLWFyZ3VtZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vaXMtY2FsbGFibGVAMS4yLjcvbm9kZV9tb2R1bGVzL2lzLWNhbGxhYmxlL2luZGV4LmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy8ucG5wbS9pcy1nZW5lcmF0b3ItZnVuY3Rpb25AMS4xLjAvbm9kZV9tb2R1bGVzL2lzLWdlbmVyYXRvci1mdW5jdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vaXMtbmFuQDEuMy4yL25vZGVfbW9kdWxlcy9pcy1uYW4vaW1wbGVtZW50YXRpb24uanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2lzLW5hbkAxLjMuMi9ub2RlX21vZHVsZXMvaXMtbmFuL2luZGV4LmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy8ucG5wbS9pcy1uYW5AMS4zLjIvbm9kZV9tb2R1bGVzL2lzLW5hbi9wb2x5ZmlsbC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vaXMtbmFuQDEuMy4yL25vZGVfbW9kdWxlcy9pcy1uYW4vc2hpbS5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vaXMtcmVnZXhAMS4yLjEvbm9kZV9tb2R1bGVzL2lzLXJlZ2V4L2luZGV4LmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy8ucG5wbS9pcy10eXBlZC1hcnJheUAxLjEuMTUvbm9kZV9tb2R1bGVzL2lzLXR5cGVkLWFycmF5L2luZGV4LmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy8ucG5wbS9tYXRoLWludHJpbnNpY3NAMS4xLjAvbm9kZV9tb2R1bGVzL21hdGgtaW50cmluc2ljcy9hYnMuanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21hdGgtaW50cmluc2ljc0AxLjEuMC9ub2RlX21vZHVsZXMvbWF0aC1pbnRyaW5zaWNzL2Zsb29yLmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy8ucG5wbS9tYXRoLWludHJpbnNpY3NAMS4xLjAvbm9kZV9tb2R1bGVzL21hdGgtaW50cmluc2ljcy9pc05hTi5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vbWF0aC1pbnRyaW5zaWNzQDEuMS4wL25vZGVfbW9kdWxlcy9tYXRoLWludHJpbnNpY3MvbWF4LmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy8ucG5wbS9tYXRoLWludHJpbnNpY3NAMS4xLjAvbm9kZV9tb2R1bGVzL21hdGgtaW50cmluc2ljcy9taW4uanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21hdGgtaW50cmluc2ljc0AxLjEuMC9ub2RlX21vZHVsZXMvbWF0aC1pbnRyaW5zaWNzL3Bvdy5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vbWF0aC1pbnRyaW5zaWNzQDEuMS4wL25vZGVfbW9kdWxlcy9tYXRoLWludHJpbnNpY3Mvcm91bmQuanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21hdGgtaW50cmluc2ljc0AxLjEuMC9ub2RlX21vZHVsZXMvbWF0aC1pbnRyaW5zaWNzL3NpZ24uanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL29iamVjdC1pc0AxLjEuNi9ub2RlX21vZHVsZXMvb2JqZWN0LWlzL2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy8ucG5wbS9vYmplY3QtaXNAMS4xLjYvbm9kZV9tb2R1bGVzL29iamVjdC1pcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vb2JqZWN0LWlzQDEuMS42L25vZGVfbW9kdWxlcy9vYmplY3QtaXMvcG9seWZpbGwuanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL29iamVjdC1pc0AxLjEuNi9ub2RlX21vZHVsZXMvb2JqZWN0LWlzL3NoaW0uanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL29iamVjdC1rZXlzQDEuMS4xL25vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pbXBsZW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vb2JqZWN0LWtleXNAMS4xLjEvbm9kZV9tb2R1bGVzL29iamVjdC1rZXlzL2luZGV4LmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy8ucG5wbS9vYmplY3Qta2V5c0AxLjEuMS9ub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL29iamVjdC5hc3NpZ25ANC4xLjcvbm9kZV9tb2R1bGVzL29iamVjdC5hc3NpZ24vaW1wbGVtZW50YXRpb24uanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL29iamVjdC5hc3NpZ25ANC4xLjcvbm9kZV9tb2R1bGVzL29iamVjdC5hc3NpZ24vcG9seWZpbGwuanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3Bvc3NpYmxlLXR5cGVkLWFycmF5LW5hbWVzQDEuMS4wL25vZGVfbW9kdWxlcy9wb3NzaWJsZS10eXBlZC1hcnJheS1uYW1lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vcHJvY2Vzc0AwLjExLjEwL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3NhZmUtcmVnZXgtdGVzdEAxLjEuMC9ub2RlX21vZHVsZXMvc2FmZS1yZWdleC10ZXN0L2luZGV4LmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy8ucG5wbS9zZXQtZnVuY3Rpb24tbGVuZ3RoQDEuMi4yL25vZGVfbW9kdWxlcy9zZXQtZnVuY3Rpb24tbGVuZ3RoL2luZGV4LmpzIiwid2VicGFjazovL3BveGVsdG9vbC8uL25vZGVfbW9kdWxlcy8ucG5wbS91dGlsQDAuMTIuNS9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vdXRpbEAwLjEyLjUvbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC90eXBlcy5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vdXRpbEAwLjEyLjUvbm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vd2hpY2gtdHlwZWQtYXJyYXlAMS4xLjE5L25vZGVfbW9kdWxlcy93aGljaC10eXBlZC1hcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9zcmMvZW51bXMudHMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vc3JjL3NjaGVtYXMudHMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2F2YWlsYWJsZS10eXBlZC1hcnJheXNAMS4wLjcvbm9kZV9tb2R1bGVzL2F2YWlsYWJsZS10eXBlZC1hcnJheXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bjb2x5c2V1cyttc2dwYWNrckAxLjExLjIvbm9kZV9tb2R1bGVzL0Bjb2x5c2V1cy9tc2dwYWNrci9pbmRleC5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vQGNvbHlzZXVzK21zZ3BhY2tyQDEuMTEuMi9ub2RlX21vZHVsZXMvQGNvbHlzZXVzL21zZ3BhY2tyL2l0ZXJhdG9ycy5qcyIsIndlYnBhY2s6Ly9wb3hlbHRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vQGNvbHlzZXVzK21zZ3BhY2tyQDEuMTEuMi9ub2RlX21vZHVsZXMvQGNvbHlzZXVzL21zZ3BhY2tyL3BhY2suanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bjb2x5c2V1cyttc2dwYWNrckAxLjExLjIvbm9kZV9tb2R1bGVzL0Bjb2x5c2V1cy9tc2dwYWNrci91bnBhY2suanMiLCJ3ZWJwYWNrOi8vcG94ZWx0b29sLy4vc3JjL2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gICAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuc2NoZW1hID0ge30pKTtcbn0pKHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBTV0lUQ0hfVE9fU1RSVUNUVVJFID0gMjU1OyAvLyAoZGVjb2RpbmcgY29sbGlkZXMgd2l0aCBERUxFVEVfQU5EX0FERCArIGZpZWxkSW5kZXggPSA2MylcbiAgICBjb25zdCBUWVBFX0lEID0gMjEzO1xuICAgIC8qKlxuICAgICAqIEVuY29kaW5nIFNjaGVtYSBmaWVsZCBvcGVyYXRpb25zLlxuICAgICAqL1xuICAgIGV4cG9ydHMuT1BFUkFUSU9OID0gdm9pZCAwO1xuICAgIChmdW5jdGlvbiAoT1BFUkFUSU9OKSB7XG4gICAgICAgIE9QRVJBVElPTltPUEVSQVRJT05bXCJBRERcIl0gPSAxMjhdID0gXCJBRERcIjtcbiAgICAgICAgT1BFUkFUSU9OW09QRVJBVElPTltcIlJFUExBQ0VcIl0gPSAwXSA9IFwiUkVQTEFDRVwiO1xuICAgICAgICBPUEVSQVRJT05bT1BFUkFUSU9OW1wiREVMRVRFXCJdID0gNjRdID0gXCJERUxFVEVcIjtcbiAgICAgICAgT1BFUkFUSU9OW09QRVJBVElPTltcIkRFTEVURV9BTkRfTU9WRVwiXSA9IDk2XSA9IFwiREVMRVRFX0FORF9NT1ZFXCI7XG4gICAgICAgIE9QRVJBVElPTltPUEVSQVRJT05bXCJNT1ZFX0FORF9BRERcIl0gPSAxNjBdID0gXCJNT1ZFX0FORF9BRERcIjtcbiAgICAgICAgT1BFUkFUSU9OW09QRVJBVElPTltcIkRFTEVURV9BTkRfQUREXCJdID0gMTkyXSA9IFwiREVMRVRFX0FORF9BRERcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbGxlY3Rpb24gb3BlcmF0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgT1BFUkFUSU9OW09QRVJBVElPTltcIkNMRUFSXCJdID0gMTBdID0gXCJDTEVBUlwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogQXJyYXlTY2hlbWEgb3BlcmF0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgT1BFUkFUSU9OW09QRVJBVElPTltcIlJFVkVSU0VcIl0gPSAxNV0gPSBcIlJFVkVSU0VcIjtcbiAgICAgICAgT1BFUkFUSU9OW09QRVJBVElPTltcIk1PVkVcIl0gPSAzMl0gPSBcIk1PVkVcIjtcbiAgICAgICAgT1BFUkFUSU9OW09QRVJBVElPTltcIkRFTEVURV9CWV9SRUZJRFwiXSA9IDMzXSA9IFwiREVMRVRFX0JZX1JFRklEXCI7XG4gICAgICAgIE9QRVJBVElPTltPUEVSQVRJT05bXCJBRERfQllfUkVGSURcIl0gPSAxMjldID0gXCJBRERfQllfUkVGSURcIjtcbiAgICB9KShleHBvcnRzLk9QRVJBVElPTiB8fCAoZXhwb3J0cy5PUEVSQVRJT04gPSB7fSkpO1xuXG4gICAgU3ltYm9sLm1ldGFkYXRhID8/PSBTeW1ib2wuZm9yKFwiU3ltYm9sLm1ldGFkYXRhXCIpO1xuXG4gICAgY29uc3QgJHRyYWNrID0gU3ltYm9sKFwiJHRyYWNrXCIpO1xuICAgIGNvbnN0ICRlbmNvZGVyID0gU3ltYm9sKFwiJGVuY29kZXJcIik7XG4gICAgY29uc3QgJGRlY29kZXIgPSBTeW1ib2woXCIkZGVjb2RlclwiKTtcbiAgICBjb25zdCAkZmlsdGVyID0gU3ltYm9sKFwiJGZpbHRlclwiKTtcbiAgICBjb25zdCAkZ2V0QnlJbmRleCA9IFN5bWJvbChcIiRnZXRCeUluZGV4XCIpO1xuICAgIGNvbnN0ICRkZWxldGVCeUluZGV4ID0gU3ltYm9sKFwiJGRlbGV0ZUJ5SW5kZXhcIik7XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBob2xkIENoYW5nZVRyZWUgaW5zdGFuY2VzIHdoaXRpbiB0aGUgc3RydWN0dXJlc1xuICAgICAqL1xuICAgIGNvbnN0ICRjaGFuZ2VzID0gU3ltYm9sKCckY2hhbmdlcycpO1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgdHlwZSBvZiB0aGUgY2hpbGQgZWxlbWVudHMgb2YgYSBjb2xsZWN0aW9uXG4gICAgICogKE1hcFNjaGVtYSwgQXJyYXlTY2hlbWEsIGV0Yy4pXG4gICAgICovXG4gICAgY29uc3QgJGNoaWxkVHlwZSA9IFN5bWJvbCgnJGNoaWxkVHlwZScpO1xuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsIFwiZGlzY2FyZFwiIG1ldGhvZCBmb3IgY3VzdG9tIHR5cGVzIChBcnJheVNjaGVtYSlcbiAgICAgKiAoRGlzY2FyZHMgY2hhbmdlcyBmb3IgbmV4dCBzZXJpYWxpemF0aW9uKVxuICAgICAqL1xuICAgIGNvbnN0ICRvbkVuY29kZUVuZCA9IFN5bWJvbCgnJG9uRW5jb2RlRW5kJyk7XG4gICAgLyoqXG4gICAgICogV2hlbiBkZWNvZGluZywgdGhpcyBtZXRob2QgaXMgY2FsbGVkIGFmdGVyIHRoZSBpbnN0YW5jZSBpcyBmdWxseSBkZWNvZGVkXG4gICAgICovXG4gICAgY29uc3QgJG9uRGVjb2RlRW5kID0gU3ltYm9sKFwiJG9uRGVjb2RlRW5kXCIpO1xuICAgIC8qKlxuICAgICAqIE1ldGFkYXRhXG4gICAgICovXG4gICAgY29uc3QgJGRlc2NyaXB0b3JzID0gU3ltYm9sKFwiJGRlc2NyaXB0b3JzXCIpO1xuICAgIGNvbnN0ICRudW1GaWVsZHMgPSBcIiRfX251bUZpZWxkc1wiO1xuICAgIGNvbnN0ICRyZWZUeXBlRmllbGRJbmRleGVzID0gXCIkX19yZWZUeXBlRmllbGRJbmRleGVzXCI7XG4gICAgY29uc3QgJHZpZXdGaWVsZEluZGV4ZXMgPSBcIiRfX3ZpZXdGaWVsZEluZGV4ZXNcIjtcbiAgICBjb25zdCAkZmllbGRJbmRleGVzQnlWaWV3VGFnID0gXCIkX19maWVsZEluZGV4ZXNCeVZpZXdUYWdcIjtcblxuICAgIC8qKlxuICAgICAqIENvcHlyaWdodCAoYykgMjAxOCBFbmRlbCBEcmV5ZXJcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMTQgSW9uIERyaXZlIFNvZnR3YXJlIEx0ZC5cbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgKlxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgICAqIFNPRlRXQVJFXG4gICAgICovXG4gICAgLyoqXG4gICAgICogbXNncGFjayBpbXBsZW1lbnRhdGlvbiBoaWdobHkgYmFzZWQgb24gbm90ZXBhY2suaW9cbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vZGFycmFjaGVxdWVzbmUvbm90ZXBhY2tcbiAgICAgKi9cbiAgICBsZXQgdGV4dEVuY29kZXI7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRyeSB7XG4gICAgICAgIHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7IH1cbiAgICBjb25zdCBfY29udm9CdWZmZXIkMSA9IG5ldyBBcnJheUJ1ZmZlcig4KTtcbiAgICBjb25zdCBfaW50MzIkMSA9IG5ldyBJbnQzMkFycmF5KF9jb252b0J1ZmZlciQxKTtcbiAgICBjb25zdCBfZmxvYXQzMiQxID0gbmV3IEZsb2F0MzJBcnJheShfY29udm9CdWZmZXIkMSk7XG4gICAgY29uc3QgX2Zsb2F0NjQkMSA9IG5ldyBGbG9hdDY0QXJyYXkoX2NvbnZvQnVmZmVyJDEpO1xuICAgIGNvbnN0IF9pbnQ2NCQxID0gbmV3IEJpZ0ludDY0QXJyYXkoX2NvbnZvQnVmZmVyJDEpO1xuICAgIGNvbnN0IGhhc0J1ZmZlckJ5dGVMZW5ndGggPSAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgQnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgIGNvbnN0IHV0ZjhMZW5ndGggPSAoaGFzQnVmZmVyQnl0ZUxlbmd0aClcbiAgICAgICAgPyBCdWZmZXIuYnl0ZUxlbmd0aCAvLyBub2RlXG4gICAgICAgIDogZnVuY3Rpb24gKHN0ciwgXykge1xuICAgICAgICAgICAgdmFyIGMgPSAwLCBsZW5ndGggPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdHIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGggKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCArPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjIDwgMHhkODAwIHx8IGMgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCArPSAzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGggKz0gNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICB9O1xuICAgIGZ1bmN0aW9uIHV0ZjhXcml0ZSh2aWV3LCBzdHIsIGl0KSB7XG4gICAgICAgIHZhciBjID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdHIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgICAgICB2aWV3W2l0Lm9mZnNldCsrXSA9IGM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgICAgICB2aWV3W2l0Lm9mZnNldF0gPSAweGMwIHwgKGMgPj4gNik7XG4gICAgICAgICAgICAgICAgdmlld1tpdC5vZmZzZXQgKyAxXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgICAgICAgICAgICAgIGl0Lm9mZnNldCArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA8IDB4ZDgwMCB8fCBjID49IDB4ZTAwMCkge1xuICAgICAgICAgICAgICAgIHZpZXdbaXQub2Zmc2V0XSA9IDB4ZTAgfCAoYyA+PiAxMik7XG4gICAgICAgICAgICAgICAgdmlld1tpdC5vZmZzZXQgKyAxXSA9IDB4ODAgfCAoYyA+PiA2ICYgMHgzZik7XG4gICAgICAgICAgICAgICAgdmlld1tpdC5vZmZzZXQgKyAyXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgICAgICAgICAgICAgIGl0Lm9mZnNldCArPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKCgoYyAmIDB4M2ZmKSA8PCAxMCkgfCAoc3RyLmNoYXJDb2RlQXQoaSkgJiAweDNmZikpO1xuICAgICAgICAgICAgICAgIHZpZXdbaXQub2Zmc2V0XSA9IDB4ZjAgfCAoYyA+PiAxOCk7XG4gICAgICAgICAgICAgICAgdmlld1tpdC5vZmZzZXQgKyAxXSA9IDB4ODAgfCAoYyA+PiAxMiAmIDB4M2YpO1xuICAgICAgICAgICAgICAgIHZpZXdbaXQub2Zmc2V0ICsgMl0gPSAweDgwIHwgKGMgPj4gNiAmIDB4M2YpO1xuICAgICAgICAgICAgICAgIHZpZXdbaXQub2Zmc2V0ICsgM10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICAgICAgICAgICAgICBpdC5vZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpbnQ4JDEoYnl0ZXMsIHZhbHVlLCBpdCkge1xuICAgICAgICBieXRlc1tpdC5vZmZzZXQrK10gPSB2YWx1ZSAmIDI1NTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdWludDgkMShieXRlcywgdmFsdWUsIGl0KSB7XG4gICAgICAgIGJ5dGVzW2l0Lm9mZnNldCsrXSA9IHZhbHVlICYgMjU1O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnQxNiQxKGJ5dGVzLCB2YWx1ZSwgaXQpIHtcbiAgICAgICAgYnl0ZXNbaXQub2Zmc2V0KytdID0gdmFsdWUgJiAyNTU7XG4gICAgICAgIGJ5dGVzW2l0Lm9mZnNldCsrXSA9ICh2YWx1ZSA+PiA4KSAmIDI1NTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdWludDE2JDEoYnl0ZXMsIHZhbHVlLCBpdCkge1xuICAgICAgICBieXRlc1tpdC5vZmZzZXQrK10gPSB2YWx1ZSAmIDI1NTtcbiAgICAgICAgYnl0ZXNbaXQub2Zmc2V0KytdID0gKHZhbHVlID4+IDgpICYgMjU1O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnQzMiQxKGJ5dGVzLCB2YWx1ZSwgaXQpIHtcbiAgICAgICAgYnl0ZXNbaXQub2Zmc2V0KytdID0gdmFsdWUgJiAyNTU7XG4gICAgICAgIGJ5dGVzW2l0Lm9mZnNldCsrXSA9ICh2YWx1ZSA+PiA4KSAmIDI1NTtcbiAgICAgICAgYnl0ZXNbaXQub2Zmc2V0KytdID0gKHZhbHVlID4+IDE2KSAmIDI1NTtcbiAgICAgICAgYnl0ZXNbaXQub2Zmc2V0KytdID0gKHZhbHVlID4+IDI0KSAmIDI1NTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdWludDMyJDEoYnl0ZXMsIHZhbHVlLCBpdCkge1xuICAgICAgICBjb25zdCBiNCA9IHZhbHVlID4+IDI0O1xuICAgICAgICBjb25zdCBiMyA9IHZhbHVlID4+IDE2O1xuICAgICAgICBjb25zdCBiMiA9IHZhbHVlID4+IDg7XG4gICAgICAgIGNvbnN0IGIxID0gdmFsdWU7XG4gICAgICAgIGJ5dGVzW2l0Lm9mZnNldCsrXSA9IGIxICYgMjU1O1xuICAgICAgICBieXRlc1tpdC5vZmZzZXQrK10gPSBiMiAmIDI1NTtcbiAgICAgICAgYnl0ZXNbaXQub2Zmc2V0KytdID0gYjMgJiAyNTU7XG4gICAgICAgIGJ5dGVzW2l0Lm9mZnNldCsrXSA9IGI0ICYgMjU1O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnQ2NCQxKGJ5dGVzLCB2YWx1ZSwgaXQpIHtcbiAgICAgICAgY29uc3QgaGlnaCA9IE1hdGguZmxvb3IodmFsdWUgLyBNYXRoLnBvdygyLCAzMikpO1xuICAgICAgICBjb25zdCBsb3cgPSB2YWx1ZSA+Pj4gMDtcbiAgICAgICAgdWludDMyJDEoYnl0ZXMsIGxvdywgaXQpO1xuICAgICAgICB1aW50MzIkMShieXRlcywgaGlnaCwgaXQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1aW50NjQkMShieXRlcywgdmFsdWUsIGl0KSB7XG4gICAgICAgIGNvbnN0IGhpZ2ggPSAodmFsdWUgLyBNYXRoLnBvdygyLCAzMikpID4+IDA7XG4gICAgICAgIGNvbnN0IGxvdyA9IHZhbHVlID4+PiAwO1xuICAgICAgICB1aW50MzIkMShieXRlcywgbG93LCBpdCk7XG4gICAgICAgIHVpbnQzMiQxKGJ5dGVzLCBoaWdoLCBpdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJpZ2ludDY0JDEoYnl0ZXMsIHZhbHVlLCBpdCkge1xuICAgICAgICBfaW50NjQkMVswXSA9IEJpZ0ludC5hc0ludE4oNjQsIHZhbHVlKTtcbiAgICAgICAgaW50MzIkMShieXRlcywgX2ludDMyJDFbMF0sIGl0KTtcbiAgICAgICAgaW50MzIkMShieXRlcywgX2ludDMyJDFbMV0sIGl0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmlndWludDY0JDEoYnl0ZXMsIHZhbHVlLCBpdCkge1xuICAgICAgICBfaW50NjQkMVswXSA9IEJpZ0ludC5hc0ludE4oNjQsIHZhbHVlKTtcbiAgICAgICAgaW50MzIkMShieXRlcywgX2ludDMyJDFbMF0sIGl0KTtcbiAgICAgICAgaW50MzIkMShieXRlcywgX2ludDMyJDFbMV0sIGl0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmxvYXQzMiQxKGJ5dGVzLCB2YWx1ZSwgaXQpIHtcbiAgICAgICAgX2Zsb2F0MzIkMVswXSA9IHZhbHVlO1xuICAgICAgICBpbnQzMiQxKGJ5dGVzLCBfaW50MzIkMVswXSwgaXQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbG9hdDY0JDEoYnl0ZXMsIHZhbHVlLCBpdCkge1xuICAgICAgICBfZmxvYXQ2NCQxWzBdID0gdmFsdWU7XG4gICAgICAgIGludDMyJDEoYnl0ZXMsIF9pbnQzMiQxWzAgXSwgaXQpO1xuICAgICAgICBpbnQzMiQxKGJ5dGVzLCBfaW50MzIkMVsxIF0sIGl0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm9vbGVhbiQxKGJ5dGVzLCB2YWx1ZSwgaXQpIHtcbiAgICAgICAgYnl0ZXNbaXQub2Zmc2V0KytdID0gdmFsdWUgPyAxIDogMDsgLy8gdWludDhcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RyaW5nJDEoYnl0ZXMsIHZhbHVlLCBpdCkge1xuICAgICAgICAvLyBlbmNvZGUgYG51bGxgIHN0cmluZ3MgYXMgZW1wdHkuXG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGVuZ3RoID0gdXRmOExlbmd0aCh2YWx1ZSwgXCJ1dGY4XCIpO1xuICAgICAgICBsZXQgc2l6ZSA9IDA7XG4gICAgICAgIC8vIGZpeHN0clxuICAgICAgICBpZiAobGVuZ3RoIDwgMHgyMCkge1xuICAgICAgICAgICAgYnl0ZXNbaXQub2Zmc2V0KytdID0gbGVuZ3RoIHwgMHhhMDtcbiAgICAgICAgICAgIHNpemUgPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0ciA4XG4gICAgICAgIGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwKSB7XG4gICAgICAgICAgICBieXRlc1tpdC5vZmZzZXQrK10gPSAweGQ5O1xuICAgICAgICAgICAgYnl0ZXNbaXQub2Zmc2V0KytdID0gbGVuZ3RoICUgMjU1O1xuICAgICAgICAgICAgc2l6ZSA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RyIDE2XG4gICAgICAgIGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgIGJ5dGVzW2l0Lm9mZnNldCsrXSA9IDB4ZGE7XG4gICAgICAgICAgICB1aW50MTYkMShieXRlcywgbGVuZ3RoLCBpdCk7XG4gICAgICAgICAgICBzaXplID0gMztcbiAgICAgICAgfVxuICAgICAgICAvLyBzdHIgMzJcbiAgICAgICAgZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMDAwMDApIHtcbiAgICAgICAgICAgIGJ5dGVzW2l0Lm9mZnNldCsrXSA9IDB4ZGI7XG4gICAgICAgICAgICB1aW50MzIkMShieXRlcywgbGVuZ3RoLCBpdCk7XG4gICAgICAgICAgICBzaXplID0gNTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3RyaW5nIHRvbyBsb25nJyk7XG4gICAgICAgIH1cbiAgICAgICAgdXRmOFdyaXRlKGJ5dGVzLCB2YWx1ZSwgaXQpO1xuICAgICAgICByZXR1cm4gc2l6ZSArIGxlbmd0aDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbnVtYmVyJDEoYnl0ZXMsIHZhbHVlLCBpdCkge1xuICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyJDEoYnl0ZXMsIDAsIGl0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyJDEoYnl0ZXMsICh2YWx1ZSA+IDApID8gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgOiAtTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsIGl0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPT0gKHZhbHVlIHwgMCkpIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh2YWx1ZSkgPD0gMy40MDI4MjM1ZSszOCkgeyAvLyByYW5nZSBjaGVja1xuICAgICAgICAgICAgICAgIF9mbG9hdDMyJDFbMF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoTWF0aC5hYnMoX2Zsb2F0MzIkMVswXSkgLSBNYXRoLmFicyh2YWx1ZSkpIDwgMWUtNCkgeyAvLyBwcmVjaXNpb24gY2hlY2s7IGFkanVzdCAxZS1uIChuID0gcHJlY2lzaW9uKSB0byBpbi0vZGVjcmVhc2UgYWNjZXB0YWJsZSBwcmVjaXNpb24gbG9zc1xuICAgICAgICAgICAgICAgICAgICAvLyBub3cgd2Uga25vdyB2YWx1ZSBpcyBpbiByYW5nZSBmb3IgZjMyIGFuZCBoYXMgYWNjZXB0YWJsZSBwcmVjaXNpb24gZm9yIGYzMlxuICAgICAgICAgICAgICAgICAgICBieXRlc1tpdC5vZmZzZXQrK10gPSAweGNhO1xuICAgICAgICAgICAgICAgICAgICBmbG9hdDMyJDEoYnl0ZXMsIHZhbHVlLCBpdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ5dGVzW2l0Lm9mZnNldCsrXSA9IDB4Y2I7XG4gICAgICAgICAgICBmbG9hdDY0JDEoYnl0ZXMsIHZhbHVlLCBpdCk7XG4gICAgICAgICAgICByZXR1cm4gOTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPj0gMCkge1xuICAgICAgICAgICAgLy8gcG9zaXRpdmUgZml4bnVtXG4gICAgICAgICAgICBpZiAodmFsdWUgPCAweDgwKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXNbaXQub2Zmc2V0KytdID0gdmFsdWUgJiAyNTU7IC8vIHVpbnQ4XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB1aW50IDhcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDB4MTAwKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXNbaXQub2Zmc2V0KytdID0gMHhjYztcbiAgICAgICAgICAgICAgICBieXRlc1tpdC5vZmZzZXQrK10gPSB2YWx1ZSAmIDI1NTsgLy8gdWludDhcbiAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVpbnQgMTZcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgICAgICBieXRlc1tpdC5vZmZzZXQrK10gPSAweGNkO1xuICAgICAgICAgICAgICAgIHVpbnQxNiQxKGJ5dGVzLCB2YWx1ZSwgaXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdWludCAzMlxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMHgxMDAwMDAwMDApIHtcbiAgICAgICAgICAgICAgICBieXRlc1tpdC5vZmZzZXQrK10gPSAweGNlO1xuICAgICAgICAgICAgICAgIHVpbnQzMiQxKGJ5dGVzLCB2YWx1ZSwgaXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdWludCA2NFxuICAgICAgICAgICAgYnl0ZXNbaXQub2Zmc2V0KytdID0gMHhjZjtcbiAgICAgICAgICAgIHVpbnQ2NCQxKGJ5dGVzLCB2YWx1ZSwgaXQpO1xuICAgICAgICAgICAgcmV0dXJuIDk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBuZWdhdGl2ZSBmaXhudW1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA+PSAtMzIpIHtcbiAgICAgICAgICAgICAgICBieXRlc1tpdC5vZmZzZXQrK10gPSAweGUwIHwgKHZhbHVlICsgMHgyMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpbnQgOFxuICAgICAgICAgICAgaWYgKHZhbHVlID49IC0xMjgpIHtcbiAgICAgICAgICAgICAgICBieXRlc1tpdC5vZmZzZXQrK10gPSAweGQwO1xuICAgICAgICAgICAgICAgIGludDgkMShieXRlcywgdmFsdWUsIGl0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGludCAxNlxuICAgICAgICAgICAgaWYgKHZhbHVlID49IC0zMjc2OCkge1xuICAgICAgICAgICAgICAgIGJ5dGVzW2l0Lm9mZnNldCsrXSA9IDB4ZDE7XG4gICAgICAgICAgICAgICAgaW50MTYkMShieXRlcywgdmFsdWUsIGl0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGludCAzMlxuICAgICAgICAgICAgaWYgKHZhbHVlID49IC0yMTQ3NDgzNjQ4KSB7XG4gICAgICAgICAgICAgICAgYnl0ZXNbaXQub2Zmc2V0KytdID0gMHhkMjtcbiAgICAgICAgICAgICAgICBpbnQzMiQxKGJ5dGVzLCB2YWx1ZSwgaXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaW50IDY0XG4gICAgICAgICAgICBieXRlc1tpdC5vZmZzZXQrK10gPSAweGQzO1xuICAgICAgICAgICAgaW50NjQkMShieXRlcywgdmFsdWUsIGl0KTtcbiAgICAgICAgICAgIHJldHVybiA5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVuY29kZSA9IHtcbiAgICAgICAgaW50ODogaW50OCQxLFxuICAgICAgICB1aW50ODogdWludDgkMSxcbiAgICAgICAgaW50MTY6IGludDE2JDEsXG4gICAgICAgIHVpbnQxNjogdWludDE2JDEsXG4gICAgICAgIGludDMyOiBpbnQzMiQxLFxuICAgICAgICB1aW50MzI6IHVpbnQzMiQxLFxuICAgICAgICBpbnQ2NDogaW50NjQkMSxcbiAgICAgICAgdWludDY0OiB1aW50NjQkMSxcbiAgICAgICAgYmlnaW50NjQ6IGJpZ2ludDY0JDEsXG4gICAgICAgIGJpZ3VpbnQ2NDogYmlndWludDY0JDEsXG4gICAgICAgIGZsb2F0MzI6IGZsb2F0MzIkMSxcbiAgICAgICAgZmxvYXQ2NDogZmxvYXQ2NCQxLFxuICAgICAgICBib29sZWFuOiBib29sZWFuJDEsXG4gICAgICAgIHN0cmluZzogc3RyaW5nJDEsXG4gICAgICAgIG51bWJlcjogbnVtYmVyJDEsXG4gICAgICAgIHV0ZjhXcml0ZSxcbiAgICAgICAgdXRmOExlbmd0aCxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDE4IEVuZGVsIERyZXllclxuICAgICAqIENvcHlyaWdodCAoYykgMjAxNCBJb24gRHJpdmUgU29mdHdhcmUgTHRkLlxuICAgICAqXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gICAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICpcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAgICAgKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAqXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgICogU09GVFdBUkVcbiAgICAgKi9cbiAgICAvLyBmb3JjZSBsaXR0bGUgZW5kaWFuIHRvIGZhY2lsaXRhdGUgZGVjb2Rpbmcgb24gbXVsdGlwbGUgaW1wbGVtZW50YXRpb25zXG4gICAgY29uc3QgX2NvbnZvQnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDgpO1xuICAgIGNvbnN0IF9pbnQzMiA9IG5ldyBJbnQzMkFycmF5KF9jb252b0J1ZmZlcik7XG4gICAgY29uc3QgX2Zsb2F0MzIgPSBuZXcgRmxvYXQzMkFycmF5KF9jb252b0J1ZmZlcik7XG4gICAgY29uc3QgX2Zsb2F0NjQgPSBuZXcgRmxvYXQ2NEFycmF5KF9jb252b0J1ZmZlcik7XG4gICAgY29uc3QgX3VpbnQ2NCA9IG5ldyBCaWdVaW50NjRBcnJheShfY29udm9CdWZmZXIpO1xuICAgIGNvbnN0IF9pbnQ2NCA9IG5ldyBCaWdJbnQ2NEFycmF5KF9jb252b0J1ZmZlcik7XG4gICAgZnVuY3Rpb24gdXRmOFJlYWQoYnl0ZXMsIGl0LCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHN0cmluZyA9ICcnLCBjaHIgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gaXQub2Zmc2V0LCBlbmQgPSBpdC5vZmZzZXQgKyBsZW5ndGg7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJ5dGUgPSBieXRlc1tpXTtcbiAgICAgICAgICAgIGlmICgoYnl0ZSAmIDB4ODApID09PSAweDAwKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGJ5dGUgJiAweGUwKSA9PT0gMHhjMCkge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYnl0ZSAmIDB4MWYpIDw8IDYpIHxcbiAgICAgICAgICAgICAgICAgICAgKGJ5dGVzWysraV0gJiAweDNmKSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGJ5dGUgJiAweGYwKSA9PT0gMHhlMCkge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYnl0ZSAmIDB4MGYpIDw8IDEyKSB8XG4gICAgICAgICAgICAgICAgICAgICgoYnl0ZXNbKytpXSAmIDB4M2YpIDw8IDYpIHxcbiAgICAgICAgICAgICAgICAgICAgKChieXRlc1srK2ldICYgMHgzZikgPDwgMCkpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChieXRlICYgMHhmOCkgPT09IDB4ZjApIHtcbiAgICAgICAgICAgICAgICBjaHIgPSAoKGJ5dGUgJiAweDA3KSA8PCAxOCkgfFxuICAgICAgICAgICAgICAgICAgICAoKGJ5dGVzWysraV0gJiAweDNmKSA8PCAxMikgfFxuICAgICAgICAgICAgICAgICAgICAoKGJ5dGVzWysraV0gJiAweDNmKSA8PCA2KSB8XG4gICAgICAgICAgICAgICAgICAgICgoYnl0ZXNbKytpXSAmIDB4M2YpIDw8IDApO1xuICAgICAgICAgICAgICAgIGlmIChjaHIgPj0gMHgwMTAwMDApIHsgLy8gc3Vycm9nYXRlIHBhaXJcbiAgICAgICAgICAgICAgICAgICAgY2hyIC09IDB4MDEwMDAwO1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoY2hyID4+PiAxMCkgKyAweEQ4MDAsIChjaHIgJiAweDNGRikgKyAweERDMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGJ5dGUgJyArIGJ5dGUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgIC8vIChkbyBub3QgdGhyb3cgZXJyb3IgdG8gYXZvaWQgc2VydmVyL2NsaWVudCBmcm9tIGNyYXNoaW5nIGR1ZSB0byBoYWNrIGF0dGVtcHMpXG4gICAgICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSAnICsgYnl0ZS50b1N0cmluZygxNikpO1xuICAgICAgICB9XG4gICAgICAgIGl0Lm9mZnNldCArPSBsZW5ndGg7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludDgoYnl0ZXMsIGl0KSB7XG4gICAgICAgIHJldHVybiB1aW50OChieXRlcywgaXQpIDw8IDI0ID4+IDI0O1xuICAgIH1cbiAgICBmdW5jdGlvbiB1aW50OChieXRlcywgaXQpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzW2l0Lm9mZnNldCsrXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW50MTYoYnl0ZXMsIGl0KSB7XG4gICAgICAgIHJldHVybiB1aW50MTYoYnl0ZXMsIGl0KSA8PCAxNiA+PiAxNjtcbiAgICB9XG4gICAgZnVuY3Rpb24gdWludDE2KGJ5dGVzLCBpdCkge1xuICAgICAgICByZXR1cm4gYnl0ZXNbaXQub2Zmc2V0KytdIHwgYnl0ZXNbaXQub2Zmc2V0KytdIDw8IDg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludDMyKGJ5dGVzLCBpdCkge1xuICAgICAgICByZXR1cm4gYnl0ZXNbaXQub2Zmc2V0KytdIHwgYnl0ZXNbaXQub2Zmc2V0KytdIDw8IDggfCBieXRlc1tpdC5vZmZzZXQrK10gPDwgMTYgfCBieXRlc1tpdC5vZmZzZXQrK10gPDwgMjQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVpbnQzMihieXRlcywgaXQpIHtcbiAgICAgICAgcmV0dXJuIGludDMyKGJ5dGVzLCBpdCkgPj4+IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsb2F0MzIoYnl0ZXMsIGl0KSB7XG4gICAgICAgIF9pbnQzMlswXSA9IGludDMyKGJ5dGVzLCBpdCk7XG4gICAgICAgIHJldHVybiBfZmxvYXQzMlswXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmxvYXQ2NChieXRlcywgaXQpIHtcbiAgICAgICAgX2ludDMyWzAgXSA9IGludDMyKGJ5dGVzLCBpdCk7XG4gICAgICAgIF9pbnQzMlsxIF0gPSBpbnQzMihieXRlcywgaXQpO1xuICAgICAgICByZXR1cm4gX2Zsb2F0NjRbMF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludDY0KGJ5dGVzLCBpdCkge1xuICAgICAgICBjb25zdCBsb3cgPSB1aW50MzIoYnl0ZXMsIGl0KTtcbiAgICAgICAgY29uc3QgaGlnaCA9IGludDMyKGJ5dGVzLCBpdCkgKiBNYXRoLnBvdygyLCAzMik7XG4gICAgICAgIHJldHVybiBoaWdoICsgbG93O1xuICAgIH1cbiAgICBmdW5jdGlvbiB1aW50NjQoYnl0ZXMsIGl0KSB7XG4gICAgICAgIGNvbnN0IGxvdyA9IHVpbnQzMihieXRlcywgaXQpO1xuICAgICAgICBjb25zdCBoaWdoID0gdWludDMyKGJ5dGVzLCBpdCkgKiBNYXRoLnBvdygyLCAzMik7XG4gICAgICAgIHJldHVybiBoaWdoICsgbG93O1xuICAgIH1cbiAgICBmdW5jdGlvbiBiaWdpbnQ2NChieXRlcywgaXQpIHtcbiAgICAgICAgX2ludDMyWzBdID0gaW50MzIoYnl0ZXMsIGl0KTtcbiAgICAgICAgX2ludDMyWzFdID0gaW50MzIoYnl0ZXMsIGl0KTtcbiAgICAgICAgcmV0dXJuIF9pbnQ2NFswXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmlndWludDY0KGJ5dGVzLCBpdCkge1xuICAgICAgICBfaW50MzJbMF0gPSBpbnQzMihieXRlcywgaXQpO1xuICAgICAgICBfaW50MzJbMV0gPSBpbnQzMihieXRlcywgaXQpO1xuICAgICAgICByZXR1cm4gX3VpbnQ2NFswXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm9vbGVhbihieXRlcywgaXQpIHtcbiAgICAgICAgcmV0dXJuIHVpbnQ4KGJ5dGVzLCBpdCkgPiAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdHJpbmcoYnl0ZXMsIGl0KSB7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IGJ5dGVzW2l0Lm9mZnNldCsrXTtcbiAgICAgICAgbGV0IGxlbmd0aDtcbiAgICAgICAgaWYgKHByZWZpeCA8IDB4YzApIHtcbiAgICAgICAgICAgIC8vIGZpeHN0clxuICAgICAgICAgICAgbGVuZ3RoID0gcHJlZml4ICYgMHgxZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmVmaXggPT09IDB4ZDkpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IHVpbnQ4KGJ5dGVzLCBpdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJlZml4ID09PSAweGRhKSB7XG4gICAgICAgICAgICBsZW5ndGggPSB1aW50MTYoYnl0ZXMsIGl0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmVmaXggPT09IDB4ZGIpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IHVpbnQzMihieXRlcywgaXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGY4UmVhZChieXRlcywgaXQsIGxlbmd0aCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG51bWJlcihieXRlcywgaXQpIHtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gYnl0ZXNbaXQub2Zmc2V0KytdO1xuICAgICAgICBpZiAocHJlZml4IDwgMHg4MCkge1xuICAgICAgICAgICAgLy8gcG9zaXRpdmUgZml4aW50XG4gICAgICAgICAgICByZXR1cm4gcHJlZml4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZWZpeCA9PT0gMHhjYSkge1xuICAgICAgICAgICAgLy8gZmxvYXQgMzJcbiAgICAgICAgICAgIHJldHVybiBmbG9hdDMyKGJ5dGVzLCBpdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJlZml4ID09PSAweGNiKSB7XG4gICAgICAgICAgICAvLyBmbG9hdCA2NFxuICAgICAgICAgICAgcmV0dXJuIGZsb2F0NjQoYnl0ZXMsIGl0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmVmaXggPT09IDB4Y2MpIHtcbiAgICAgICAgICAgIC8vIHVpbnQgOFxuICAgICAgICAgICAgcmV0dXJuIHVpbnQ4KGJ5dGVzLCBpdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJlZml4ID09PSAweGNkKSB7XG4gICAgICAgICAgICAvLyB1aW50IDE2XG4gICAgICAgICAgICByZXR1cm4gdWludDE2KGJ5dGVzLCBpdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJlZml4ID09PSAweGNlKSB7XG4gICAgICAgICAgICAvLyB1aW50IDMyXG4gICAgICAgICAgICByZXR1cm4gdWludDMyKGJ5dGVzLCBpdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJlZml4ID09PSAweGNmKSB7XG4gICAgICAgICAgICAvLyB1aW50IDY0XG4gICAgICAgICAgICByZXR1cm4gdWludDY0KGJ5dGVzLCBpdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJlZml4ID09PSAweGQwKSB7XG4gICAgICAgICAgICAvLyBpbnQgOFxuICAgICAgICAgICAgcmV0dXJuIGludDgoYnl0ZXMsIGl0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmVmaXggPT09IDB4ZDEpIHtcbiAgICAgICAgICAgIC8vIGludCAxNlxuICAgICAgICAgICAgcmV0dXJuIGludDE2KGJ5dGVzLCBpdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJlZml4ID09PSAweGQyKSB7XG4gICAgICAgICAgICAvLyBpbnQgMzJcbiAgICAgICAgICAgIHJldHVybiBpbnQzMihieXRlcywgaXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZWZpeCA9PT0gMHhkMykge1xuICAgICAgICAgICAgLy8gaW50IDY0XG4gICAgICAgICAgICByZXR1cm4gaW50NjQoYnl0ZXMsIGl0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmVmaXggPiAweGRmKSB7XG4gICAgICAgICAgICAvLyBuZWdhdGl2ZSBmaXhpbnRcbiAgICAgICAgICAgIHJldHVybiAoMHhmZiAtIHByZWZpeCArIDEpICogLTE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RyaW5nQ2hlY2soYnl0ZXMsIGl0KSB7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IGJ5dGVzW2l0Lm9mZnNldF07XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgIC8vIGZpeHN0clxuICAgICAgICAocHJlZml4IDwgMHhjMCAmJiBwcmVmaXggPiAweGEwKSB8fFxuICAgICAgICAgICAgLy8gc3RyIDhcbiAgICAgICAgICAgIHByZWZpeCA9PT0gMHhkOSB8fFxuICAgICAgICAgICAgLy8gc3RyIDE2XG4gICAgICAgICAgICBwcmVmaXggPT09IDB4ZGEgfHxcbiAgICAgICAgICAgIC8vIHN0ciAzMlxuICAgICAgICAgICAgcHJlZml4ID09PSAweGRiKTtcbiAgICB9XG4gICAgY29uc3QgZGVjb2RlID0ge1xuICAgICAgICB1dGY4UmVhZCxcbiAgICAgICAgaW50OCxcbiAgICAgICAgdWludDgsXG4gICAgICAgIGludDE2LFxuICAgICAgICB1aW50MTYsXG4gICAgICAgIGludDMyLFxuICAgICAgICB1aW50MzIsXG4gICAgICAgIGZsb2F0MzIsXG4gICAgICAgIGZsb2F0NjQsXG4gICAgICAgIGludDY0LFxuICAgICAgICB1aW50NjQsXG4gICAgICAgIGJpZ2ludDY0LFxuICAgICAgICBiaWd1aW50NjQsXG4gICAgICAgIGJvb2xlYW4sXG4gICAgICAgIHN0cmluZyxcbiAgICAgICAgbnVtYmVyLFxuICAgICAgICBzdHJpbmdDaGVjayxcbiAgICB9O1xuXG4gICAgY29uc3QgcmVnaXN0ZXJlZFR5cGVzID0ge307XG4gICAgY29uc3QgaWRlbnRpZmllcnMgPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJUeXBlKGlkZW50aWZpZXIsIGRlZmluaXRpb24pIHtcbiAgICAgICAgaWYgKGRlZmluaXRpb24uY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXJzLnNldChkZWZpbml0aW9uLmNvbnN0cnVjdG9yLCBpZGVudGlmaWVyKTtcbiAgICAgICAgICAgIHJlZ2lzdGVyZWRUeXBlc1tpZGVudGlmaWVyXSA9IGRlZmluaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZmluaXRpb24uZW5jb2RlKSB7XG4gICAgICAgICAgICBlbmNvZGVbaWRlbnRpZmllcl0gPSBkZWZpbml0aW9uLmVuY29kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmaW5pdGlvbi5kZWNvZGUpIHtcbiAgICAgICAgICAgIGRlY29kZVtpZGVudGlmaWVyXSA9IGRlZmluaXRpb24uZGVjb2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFR5cGUoaWRlbnRpZmllcikge1xuICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZFR5cGVzW2lkZW50aWZpZXJdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZpbmVDdXN0b21UeXBlcyh0eXBlcykge1xuICAgICAgICBmb3IgKGNvbnN0IGlkZW50aWZpZXIgaW4gdHlwZXMpIHtcbiAgICAgICAgICAgIHJlZ2lzdGVyVHlwZShpZGVudGlmaWVyLCB0eXBlc1tpZGVudGlmaWVyXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0KSA9PiB0eXBlKHQpO1xuICAgIH1cblxuICAgIGNsYXNzIFR5cGVDb250ZXh0IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvciBpbmhlcml0YW5jZSBzdXBwb3J0XG4gICAgICAgICAqIEtlZXBzIHRyYWNrIG9mIHdoaWNoIGNsYXNzZXMgZXh0ZW5kcyB3aGljaC4gKHBhcmVudCAtPiBjaGlsZHJlbilcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyB7IHRoaXMuaW5oZXJpdGVkVHlwZXMgPSBuZXcgTWFwKCk7IH1cbiAgICAgICAgc3RhdGljIHsgdGhpcy5jYWNoZWRDb250ZXh0cyA9IG5ldyBNYXAoKTsgfVxuICAgICAgICBzdGF0aWMgcmVnaXN0ZXIodGFyZ2V0KSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgIT09IFNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGxldCBpbmhlcml0cyA9IFR5cGVDb250ZXh0LmluaGVyaXRlZFR5cGVzLmdldChwYXJlbnQpO1xuICAgICAgICAgICAgICAgIGlmICghaW5oZXJpdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5oZXJpdHMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIFR5cGVDb250ZXh0LmluaGVyaXRlZFR5cGVzLnNldChwYXJlbnQsIGluaGVyaXRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5oZXJpdHMuYWRkKHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGNhY2hlKHJvb3RDbGFzcykge1xuICAgICAgICAgICAgbGV0IGNvbnRleHQgPSBUeXBlQ29udGV4dC5jYWNoZWRDb250ZXh0cy5nZXQocm9vdENsYXNzKTtcbiAgICAgICAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBuZXcgVHlwZUNvbnRleHQocm9vdENsYXNzKTtcbiAgICAgICAgICAgICAgICBUeXBlQ29udGV4dC5jYWNoZWRDb250ZXh0cy5zZXQocm9vdENsYXNzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0cnVjdG9yKHJvb3RDbGFzcykge1xuICAgICAgICAgICAgdGhpcy50eXBlcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5zY2hlbWFzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5oYXNGaWx0ZXJzID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnBhcmVudEZpbHRlcmVkID0ge307XG4gICAgICAgICAgICBpZiAocm9vdENsYXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNjb3ZlclR5cGVzKHJvb3RDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaGFzKHNjaGVtYSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NoZW1hcy5oYXMoc2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQodHlwZWlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlc1t0eXBlaWRdO1xuICAgICAgICB9XG4gICAgICAgIGFkZChzY2hlbWEsIHR5cGVpZCA9IHRoaXMuc2NoZW1hcy5zaXplKSB7XG4gICAgICAgICAgICAvLyBza2lwIGlmIGFscmVhZHkgcmVnaXN0ZXJlZFxuICAgICAgICAgICAgaWYgKHRoaXMuc2NoZW1hcy5oYXMoc2NoZW1hKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHlwZXNbdHlwZWlkXSA9IHNjaGVtYTtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBXb3JrYXJvdW5kIHRvIGFsbG93IHVzaW5nIGFuIGVtcHR5IFNjaGVtYSAod2l0aCBubyBgQHR5cGUoKWAgZmllbGRzKVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGlmIChzY2hlbWFbU3ltYm9sLm1ldGFkYXRhXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgTWV0YWRhdGEuaW5pdGlhbGl6ZShzY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zY2hlbWFzLnNldChzY2hlbWEsIHR5cGVpZCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRUeXBlSWQoa2xhc3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjaGVtYXMuZ2V0KGtsYXNzKTtcbiAgICAgICAgfVxuICAgICAgICBkaXNjb3ZlclR5cGVzKGtsYXNzLCBwYXJlbnRUeXBlLCBwYXJlbnRJbmRleCwgcGFyZW50SGFzVmlld1RhZykge1xuICAgICAgICAgICAgaWYgKHBhcmVudEhhc1ZpZXdUYWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdGVyRmlsdGVyZWRCeVBhcmVudChrbGFzcywgcGFyZW50VHlwZSwgcGFyZW50SW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2tpcCBpZiBhbHJlYWR5IHJlZ2lzdGVyZWRcbiAgICAgICAgICAgIGlmICghdGhpcy5hZGQoa2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWRkIGNsYXNzZXMgaW5oZXJpdGVkIGZyb20gdGhpcyBiYXNlIGNsYXNzXG4gICAgICAgICAgICBUeXBlQ29udGV4dC5pbmhlcml0ZWRUeXBlcy5nZXQoa2xhc3MpPy5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzY292ZXJUeXBlcyhjaGlsZCwgcGFyZW50VHlwZSwgcGFyZW50SW5kZXgsIHBhcmVudEhhc1ZpZXdUYWcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBhZGQgcGFyZW50IGNsYXNzZXNcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBrbGFzcztcbiAgICAgICAgICAgIHdoaWxlICgocGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHBhcmVudCkpICYmXG4gICAgICAgICAgICAgICAgcGFyZW50ICE9PSBTY2hlbWEgJiYgLy8gc3RvcCBhdCByb290IChTY2hlbWEpXG4gICAgICAgICAgICAgICAgcGFyZW50ICE9PSBGdW5jdGlvbi5wcm90b3R5cGUgLy8gc3RvcCBhdCByb290IChub24tU2NoZW1hKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNjb3ZlclR5cGVzKHBhcmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IChrbGFzc1tTeW1ib2wubWV0YWRhdGFdID8/PSB7fSk7XG4gICAgICAgICAgICAvLyBpZiBhbnkgc2NoZW1hL2ZpZWxkIGhhcyBmaWx0ZXJzLCBtYXJrIFwiY29udGV4dFwiIGFzIGhhdmluZyBmaWx0ZXJzLlxuICAgICAgICAgICAgaWYgKG1ldGFkYXRhWyR2aWV3RmllbGRJbmRleGVzXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzRmlsdGVycyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkSW5kZXggaW4gbWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGZpZWxkSW5kZXg7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRUeXBlID0gbWV0YWRhdGFbaW5kZXhdLnR5cGU7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRIYXNWaWV3VGFnID0gKG1ldGFkYXRhW2luZGV4XS50YWcgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoZmllbGRUeXBlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gZmllbGRUeXBlWzBdO1xuICAgICAgICAgICAgICAgICAgICAvLyBza2lwIHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb3ZlclR5cGVzKHR5cGUsIGtsYXNzLCBpbmRleCwgcGFyZW50SGFzVmlld1RhZyB8fCBmaWVsZEhhc1ZpZXdUYWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGZpZWxkVHlwZSkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2NvdmVyVHlwZXMoZmllbGRUeXBlLCBrbGFzcywgaW5kZXgsIHBhcmVudEhhc1ZpZXdUYWcgfHwgZmllbGRIYXNWaWV3VGFnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBPYmplY3QudmFsdWVzKGZpZWxkVHlwZSlbMF07XG4gICAgICAgICAgICAgICAgICAgIC8vIHNraXAgcHJpbWl0aXZlIHR5cGVzXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHR5cGUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2NvdmVyVHlwZXModHlwZSwga2xhc3MsIGluZGV4LCBwYXJlbnRIYXNWaWV3VGFnIHx8IGZpZWxkSGFzVmlld1RhZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBLZWVwIHRyYWNrIG9mIHdoaWNoIGNsYXNzZXMgaGF2ZSBmaWx0ZXJzIGFwcGxpZWQuXG4gICAgICAgICAqIEZvcm1hdDogYCR7dHlwZWlkfS0ke3BhcmVudFR5cGVpZH0tJHtwYXJlbnRJbmRleH1gXG4gICAgICAgICAqL1xuICAgICAgICByZWdpc3RlckZpbHRlcmVkQnlQYXJlbnQoc2NoZW1hLCBwYXJlbnRUeXBlLCBwYXJlbnRJbmRleCkge1xuICAgICAgICAgICAgY29uc3QgdHlwZWlkID0gdGhpcy5zY2hlbWFzLmdldChzY2hlbWEpID8/IHRoaXMuc2NoZW1hcy5zaXplO1xuICAgICAgICAgICAgbGV0IGtleSA9IGAke3R5cGVpZH1gO1xuICAgICAgICAgICAgaWYgKHBhcmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICBrZXkgKz0gYC0ke3RoaXMuc2NoZW1hcy5nZXQocGFyZW50VHlwZSl9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleSArPSBgLSR7cGFyZW50SW5kZXh9YDtcbiAgICAgICAgICAgIHRoaXMucGFyZW50RmlsdGVyZWRba2V5XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50RmlsdGVyZWQgPSBcIlwiO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5wYXJlbnRGaWx0ZXJlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBrZXkuc3BsaXQoXCItXCIpLm1hcChOdW1iZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkSW5kZXggPSBrZXlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHBhcmVudEZpbHRlcmVkICs9IGBcXG5cXHRcXHRgO1xuICAgICAgICAgICAgICAgIHBhcmVudEZpbHRlcmVkICs9IGAke2tleX06ICR7a2V5cy5yZXZlcnNlKCkubWFwKChpZCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtsYXNzID0gdGhpcy50eXBlc1tpZF07XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBrbGFzc1tTeW1ib2wubWV0YWRhdGFdO1xuICAgICAgICAgICAgICAgIGxldCB0eHQgPSBrbGFzcy5uYW1lO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHR4dCArPSBgWyR7bWV0YWRhdGFbZmllbGRJbmRleF0ubmFtZX1dYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3R4dH1gO1xuICAgICAgICAgICAgfSkuam9pbihcIiAtPiBcIil9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBgVHlwZUNvbnRleHQgLT5cXG5gICtcbiAgICAgICAgICAgICAgICBgXFx0U2NoZW1hIHR5cGVzOiAke3RoaXMuc2NoZW1hcy5zaXplfVxcbmAgK1xuICAgICAgICAgICAgICAgIGBcXHRoYXNGaWx0ZXJzOiAke3RoaXMuaGFzRmlsdGVyc31cXG5gICtcbiAgICAgICAgICAgICAgICBgXFx0cGFyZW50RmlsdGVyZWQ6JHtwYXJlbnRGaWx0ZXJlZH1gO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Tm9ybWFsaXplZFR5cGUodHlwZSkge1xuICAgICAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkodHlwZSkpXG4gICAgICAgICAgICA/IHsgYXJyYXk6IHR5cGVbMF0gfVxuICAgICAgICAgICAgOiAodHlwZW9mICh0eXBlWyd0eXBlJ10pICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgICAgID8gdHlwZVsndHlwZSddXG4gICAgICAgICAgICAgICAgOiB0eXBlO1xuICAgIH1cbiAgICBjb25zdCBNZXRhZGF0YSA9IHtcbiAgICAgICAgYWRkRmllbGQobWV0YWRhdGEsIGluZGV4LCBuYW1lLCB0eXBlLCBkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiA2NCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgZGVmaW5lIGZpZWxkICcke25hbWV9Jy5cXG5TY2hlbWEgaW5zdGFuY2VzIG1heSBvbmx5IGhhdmUgdXAgdG8gNjQgZmllbGRzLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWV0YWRhdGFbaW5kZXhdID0gT2JqZWN0LmFzc2lnbihtZXRhZGF0YVtpbmRleF0gfHwge30sIC8vIGF2b2lkIG92ZXJ3cml0aW5nIHByZXZpb3VzIGZpZWxkIG1ldGFkYXRhIChAb3duZWQgLyBAZGVwcmVjYXRlZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBnZXROb3JtYWxpemVkVHlwZSh0eXBlKSxcbiAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBjcmVhdGUgXCJkZXNjcmlwdG9yc1wiIG1hcFxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1ldGFkYXRhLCAkZGVzY3JpcHRvcnMsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbWV0YWRhdGFbJGRlc2NyaXB0b3JzXSB8fCB7fSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIGVuY29kZXJcbiAgICAgICAgICAgICAgICBtZXRhZGF0YVskZGVzY3JpcHRvcnNdW25hbWVdID0gZGVzY3JpcHRvcjtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YVskZGVzY3JpcHRvcnNdW2BfJHtuYW1lfWBdID0ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIGRlY29kZXJcbiAgICAgICAgICAgICAgICBtZXRhZGF0YVskZGVzY3JpcHRvcnNdW25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtYXAgLTEgYXMgbGFzdCBmaWVsZCBpbmRleFxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1ldGFkYXRhLCAkbnVtRmllbGRzLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGluZGV4LFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBtYXAgZmllbGQgbmFtZSA9PiBpbmRleCAobm9uIGVudW1lcmFibGUpXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWV0YWRhdGEsIG5hbWUsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogaW5kZXgsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBpZiBjaGlsZCBSZWYvY29tcGxleCB0eXBlLCBhZGQgdG8gLTRcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKG1ldGFkYXRhW2luZGV4XS50eXBlKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YVskcmVmVHlwZUZpZWxkSW5kZXhlc10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWV0YWRhdGEsICRyZWZUeXBlRmllbGRJbmRleGVzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1ldGFkYXRhWyRyZWZUeXBlRmllbGRJbmRleGVzXS5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0VGFnKG1ldGFkYXRhLCBmaWVsZE5hbWUsIHRhZykge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBtZXRhZGF0YVtmaWVsZE5hbWVdO1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSBtZXRhZGF0YVtpbmRleF07XG4gICAgICAgICAgICAvLyBhZGQgJ3RhZycgdG8gdGhlIGZpZWxkXG4gICAgICAgICAgICBmaWVsZC50YWcgPSB0YWc7XG4gICAgICAgICAgICBpZiAoIW1ldGFkYXRhWyR2aWV3RmllbGRJbmRleGVzXSkge1xuICAgICAgICAgICAgICAgIC8vIC0yOiBhbGwgZmllbGQgaW5kZXhlcyB3aXRoIFwidmlld1wiIHRhZ1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXRhZGF0YSwgJHZpZXdGaWVsZEluZGV4ZXMsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFtdLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gLTM6IGZpZWxkIGluZGV4ZXMgYnkgXCJ2aWV3XCIgdGFnXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1ldGFkYXRhLCAkZmllbGRJbmRleGVzQnlWaWV3VGFnLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWV0YWRhdGFbJHZpZXdGaWVsZEluZGV4ZXNdLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgaWYgKCFtZXRhZGF0YVskZmllbGRJbmRleGVzQnlWaWV3VGFnXVt0YWddKSB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGFbJGZpZWxkSW5kZXhlc0J5Vmlld1RhZ11bdGFnXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWV0YWRhdGFbJGZpZWxkSW5kZXhlc0J5Vmlld1RhZ11bdGFnXS5wdXNoKGluZGV4KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0RmllbGRzKHRhcmdldCwgZmllbGRzKSB7XG4gICAgICAgICAgICAvLyBmb3IgaW5oZXJpdGFuY2Ugc3VwcG9ydFxuICAgICAgICAgICAgY29uc3QgY29uc3RydWN0b3IgPSB0YXJnZXQucHJvdG90eXBlLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgVHlwZUNvbnRleHQucmVnaXN0ZXIoY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50Q2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50TWV0YWRhdGEgPSBwYXJlbnRDbGFzcyAmJiBwYXJlbnRDbGFzc1tTeW1ib2wubWV0YWRhdGFdO1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBNZXRhZGF0YS5pbml0aWFsaXplKGNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIC8vIFVzZSBTY2hlbWEncyBtZXRob2RzIGlmIG5vdCBkZWZpbmVkIGluIHRoZSBjbGFzc1xuICAgICAgICAgICAgaWYgKCFjb25zdHJ1Y3RvclskdHJhY2tdKSB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3JbJHRyYWNrXSA9IFNjaGVtYVskdHJhY2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb25zdHJ1Y3RvclskZW5jb2Rlcl0pIHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvclskZW5jb2Rlcl0gPSBTY2hlbWFbJGVuY29kZXJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb25zdHJ1Y3RvclskZGVjb2Rlcl0pIHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvclskZGVjb2Rlcl0gPSBTY2hlbWFbJGRlY29kZXJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb25zdHJ1Y3Rvci5wcm90b3R5cGUudG9KU09OKSB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3IucHJvdG90eXBlLnRvSlNPTiA9IFNjaGVtYS5wcm90b3R5cGUudG9KU09OO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGRldGVjdCBpbmRleCBmb3IgdGhpcyBmaWVsZCwgY29uc2lkZXJpbmcgaW5oZXJpdGFuY2VcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBsZXQgZmllbGRJbmRleCA9IG1ldGFkYXRhWyRudW1GaWVsZHNdIC8vIGN1cnJlbnQgc3RydWN0dXJlIGFscmVhZHkgaGFzIGZpZWxkcyBkZWZpbmVkXG4gICAgICAgICAgICAgICAgPz8gKHBhcmVudE1ldGFkYXRhICYmIHBhcmVudE1ldGFkYXRhWyRudW1GaWVsZHNdKSAvLyBwYXJlbnQgc3RydWN0dXJlIGhhcyBmaWVsZHMgZGVmaW5lZFxuICAgICAgICAgICAgICAgID8/IC0xOyAvLyBubyBmaWVsZHMgZGVmaW5lZFxuICAgICAgICAgICAgZmllbGRJbmRleCsrO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBpbiBmaWVsZHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gZmllbGRzW2ZpZWxkXTtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogdGhpcyBjb2RlIGlzIGR1cGxpY2F0ZWQgZnJvbSBAdHlwZSgpIGFubm90YXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCBjb21wbGV4VHlwZUtsYXNzID0gKEFycmF5LmlzQXJyYXkodHlwZSkpXG4gICAgICAgICAgICAgICAgICAgID8gZ2V0VHlwZShcImFycmF5XCIpXG4gICAgICAgICAgICAgICAgICAgIDogKHR5cGVvZiAoT2JqZWN0LmtleXModHlwZSlbMF0pID09PSBcInN0cmluZ1wiKSAmJiBnZXRUeXBlKE9iamVjdC5rZXlzKHR5cGUpWzBdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZFR5cGUgPSAoY29tcGxleFR5cGVLbGFzcylcbiAgICAgICAgICAgICAgICAgICAgPyBPYmplY3QudmFsdWVzKHR5cGUpWzBdXG4gICAgICAgICAgICAgICAgICAgIDogZ2V0Tm9ybWFsaXplZFR5cGUodHlwZSk7XG4gICAgICAgICAgICAgICAgTWV0YWRhdGEuYWRkRmllbGQobWV0YWRhdGEsIGZpZWxkSW5kZXgsIGZpZWxkLCB0eXBlLCBnZXRQcm9wZXJ0eURlc2NyaXB0b3IoYF8ke2ZpZWxkfWAsIGZpZWxkSW5kZXgsIGNoaWxkVHlwZSwgY29tcGxleFR5cGVLbGFzcykpO1xuICAgICAgICAgICAgICAgIGZpZWxkSW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGlzRGVwcmVjYXRlZChtZXRhZGF0YSwgZmllbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YVtmaWVsZF0uZGVwcmVjYXRlZCA9PT0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdChrbGFzcykge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFVzZWQgb25seSB0byBpbml0aWFsaXplIGFuIGVtcHR5IFNjaGVtYSAoRW5jb2RlciNjb25zdHJ1Y3RvcilcbiAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZS9yZWZhY3RvciB0aGlzLi4uXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB7fTtcbiAgICAgICAgICAgIGtsYXNzW1N5bWJvbC5tZXRhZGF0YV0gPSBtZXRhZGF0YTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXRhZGF0YSwgJG51bUZpZWxkcywge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBpbml0aWFsaXplKGNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRDbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRNZXRhZGF0YSA9IHBhcmVudENsYXNzW1N5bWJvbC5tZXRhZGF0YV07XG4gICAgICAgICAgICBsZXQgbWV0YWRhdGEgPSBjb25zdHJ1Y3RvcltTeW1ib2wubWV0YWRhdGFdID8/IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgaW5oZXJpdGVkIGNsYXNzZXMgaGF2ZSB0aGVpciBvd24gbWV0YWRhdGEgb2JqZWN0LlxuICAgICAgICAgICAgaWYgKHBhcmVudENsYXNzICE9PSBTY2hlbWEgJiYgbWV0YWRhdGEgPT09IHBhcmVudE1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBhc3NpZ24gcGFyZW50IG1ldGFkYXRhIHRvIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG1ldGFkYXRhLCBwYXJlbnRNZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIC8vICRudW1GaWVsZHNcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1ldGFkYXRhLCAkbnVtRmllbGRzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcGFyZW50TWV0YWRhdGFbJG51bUZpZWxkc10sXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gJHZpZXdGaWVsZEluZGV4ZXMgLyAkZmllbGRJbmRleGVzQnlWaWV3VGFnXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRNZXRhZGF0YVskdmlld0ZpZWxkSW5kZXhlc10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1ldGFkYXRhLCAkdmlld0ZpZWxkSW5kZXhlcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBbLi4ucGFyZW50TWV0YWRhdGFbJHZpZXdGaWVsZEluZGV4ZXNdXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXRhZGF0YSwgJGZpZWxkSW5kZXhlc0J5Vmlld1RhZywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7IC4uLnBhcmVudE1ldGFkYXRhWyRmaWVsZEluZGV4ZXNCeVZpZXdUYWddIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gJHJlZlR5cGVGaWVsZEluZGV4ZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudE1ldGFkYXRhWyRyZWZUeXBlRmllbGRJbmRleGVzXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWV0YWRhdGEsICRyZWZUeXBlRmllbGRJbmRleGVzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFsuLi5wYXJlbnRNZXRhZGF0YVskcmVmVHlwZUZpZWxkSW5kZXhlc11dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vICRkZXNjcmlwdG9yc1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWV0YWRhdGEsICRkZXNjcmlwdG9ycywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHsgLi4ucGFyZW50TWV0YWRhdGFbJGRlc2NyaXB0b3JzXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3RydWN0b3JbU3ltYm9sLm1ldGFkYXRhXSA9IG1ldGFkYXRhO1xuICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgICAgICB9LFxuICAgICAgICBpc1ZhbGlkSW5zdGFuY2Uoa2xhc3MpIHtcbiAgICAgICAgICAgIHJldHVybiAoa2xhc3MuY29uc3RydWN0b3JbU3ltYm9sLm1ldGFkYXRhXSAmJlxuICAgICAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChrbGFzcy5jb25zdHJ1Y3RvcltTeW1ib2wubWV0YWRhdGFdLCAkbnVtRmllbGRzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEZpZWxkcyhrbGFzcykge1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBrbGFzc1tTeW1ib2wubWV0YWRhdGFdO1xuICAgICAgICAgICAgY29uc3QgZmllbGRzID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBtZXRhZGF0YVskbnVtRmllbGRzXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZmllbGRzW21ldGFkYXRhW2ldLm5hbWVdID0gbWV0YWRhdGFbaV0udHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWVsZHM7XG4gICAgICAgIH0sXG4gICAgICAgIGhhc1ZpZXdUYWdBdEluZGV4KG1ldGFkYXRhLCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhPy5bJHZpZXdGaWVsZEluZGV4ZXNdPy5pbmNsdWRlcyhpbmRleCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlQ2hhbmdlU2V0KCkge1xuICAgICAgICByZXR1cm4geyBpbmRleGVzOiB7fSwgb3BlcmF0aW9uczogW10gfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0T3BlcmF0aW9uQXRJbmRleChjaGFuZ2VTZXQsIGluZGV4KSB7XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvbnNJbmRleCA9IGNoYW5nZVNldC5pbmRleGVzW2luZGV4XTtcbiAgICAgICAgaWYgKG9wZXJhdGlvbnNJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjaGFuZ2VTZXQuaW5kZXhlc1tpbmRleF0gPSBjaGFuZ2VTZXQub3BlcmF0aW9ucy5wdXNoKGluZGV4KSAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFuZ2VTZXQub3BlcmF0aW9uc1tvcGVyYXRpb25zSW5kZXhdID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVsZXRlT3BlcmF0aW9uQXRJbmRleChjaGFuZ2VTZXQsIGluZGV4KSB7XG4gICAgICAgIGxldCBvcGVyYXRpb25zSW5kZXggPSBjaGFuZ2VTZXQuaW5kZXhlc1tpbmRleF07XG4gICAgICAgIGlmIChvcGVyYXRpb25zSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGlmIGluZGV4IGlzIG5vdCBmb3VuZCwgd2UgbmVlZCB0byBmaW5kIHRoZSBsYXN0IG9wZXJhdGlvblxuICAgICAgICAgICAgLy8gRklYTUU6IHRoaXMgaXMgbm90IHZlcnkgZWZmaWNpZW50XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gPiBTZWUgXCJzaG91bGQgYWxsb3cgY29uc2VjdXRpdmUgc3BsaWNlcyAoc2FtZSBwbGFjZSlcIiB0ZXN0c1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIG9wZXJhdGlvbnNJbmRleCA9IE9iamVjdC52YWx1ZXMoY2hhbmdlU2V0LmluZGV4ZXMpLmF0KC0xKTtcbiAgICAgICAgICAgIGluZGV4ID0gT2JqZWN0LmVudHJpZXMoY2hhbmdlU2V0LmluZGV4ZXMpLmZpbmQoKFtfLCB2YWx1ZV0pID0+IHZhbHVlID09PSBvcGVyYXRpb25zSW5kZXgpPy5bMF07XG4gICAgICAgIH1cbiAgICAgICAgY2hhbmdlU2V0Lm9wZXJhdGlvbnNbb3BlcmF0aW9uc0luZGV4XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZGVsZXRlIGNoYW5nZVNldC5pbmRleGVzW2luZGV4XTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5xdWV1ZUNoYW5nZVRyZWUocm9vdCwgY2hhbmdlVHJlZSwgY2hhbmdlU2V0LCBxdWV1ZVJvb3RJbmRleCA9IGNoYW5nZVRyZWVbY2hhbmdlU2V0XS5xdWV1ZVJvb3RJbmRleCkge1xuICAgICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgICAgIC8vIHNraXBcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyb290W2NoYW5nZVNldF1bcXVldWVSb290SW5kZXhdICE9PSBjaGFuZ2VUcmVlKSB7XG4gICAgICAgICAgICBjaGFuZ2VUcmVlW2NoYW5nZVNldF0ucXVldWVSb290SW5kZXggPSByb290W2NoYW5nZVNldF0ucHVzaChjaGFuZ2VUcmVlKSAtIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xhc3MgQ2hhbmdlVHJlZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHJlZikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGV0aGVyIHRoaXMgc3RydWN0dXJlIGlzIHBhcmVudCBvZiBhIGZpbHRlcmVkIHN0cnVjdHVyZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pc0ZpbHRlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmluZGV4ZWRPcGVyYXRpb25zID0ge307XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVE9ETzpcbiAgICAgICAgICAgIC8vICAgdHJ5IHN0b3JpbmcgdGhlIGluZGV4ICsgb3BlcmF0aW9uIHBlciBpdGVtLlxuICAgICAgICAgICAgLy8gICBleGFtcGxlOiAxMDI0ICYgMTAyNSA9PiBBREQsIDEwMjYgPT4gREVMRVRFXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gPT4gaHR0cHM6Ly9jaGF0Z3B0LmNvbS9zaGFyZS82NzEwN2QwYy1iYzIwLTgwMDQtODU4My04M2IxN2RkN2MxOTZcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICB0aGlzLmNoYW5nZXMgPSB7IGluZGV4ZXM6IHt9LCBvcGVyYXRpb25zOiBbXSB9O1xuICAgICAgICAgICAgdGhpcy5hbGxDaGFuZ2VzID0geyBpbmRleGVzOiB7fSwgb3BlcmF0aW9uczogW10gfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSXMgdGhpcyBhIG5ldyBpbnN0YW5jZT8gVXNlZCBvbiBBcnJheVNjaGVtYSB0byBkZXRlcm1pbmUgT1BFUkFUSU9OLk1PVkVfQU5EX0FERCBvcGVyYXRpb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaXNOZXcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5yZWYgPSByZWY7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gRG9lcyB0aGlzIHN0cnVjdHVyZSBoYXZlIFwiZmlsdGVyc1wiIGRlY2xhcmVkP1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gcmVmLmNvbnN0cnVjdG9yW1N5bWJvbC5tZXRhZGF0YV07XG4gICAgICAgICAgICBpZiAobWV0YWRhdGE/Llskdmlld0ZpZWxkSW5kZXhlc10pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFsbEZpbHRlcmVkQ2hhbmdlcyA9IHsgaW5kZXhlczoge30sIG9wZXJhdGlvbnM6IFtdIH07XG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJlZENoYW5nZXMgPSB7IGluZGV4ZXM6IHt9LCBvcGVyYXRpb25zOiBbXSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldFJvb3Qocm9vdCkge1xuICAgICAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tJc0ZpbHRlcmVkKHRoaXMucGFyZW50LCB0aGlzLnBhcmVudEluZGV4KTtcbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNldCByb290IG9uIGNoaWxkIHN0cnVjdHVyZXNcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gdGhpcy5yZWYuY29uc3RydWN0b3JbU3ltYm9sLm1ldGFkYXRhXTtcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhWyRyZWZUeXBlRmllbGRJbmRleGVzXT8uZm9yRWFjaCgoaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSBtZXRhZGF0YVtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5yZWZbZmllbGQubmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPy5bJGNoYW5nZXNdLnNldFJvb3Qocm9vdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnJlZlskY2hpbGRUeXBlXSAmJiB0eXBlb2YgKHRoaXMucmVmWyRjaGlsZFR5cGVdKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIC8vIE1hcFNjaGVtYSAvIEFycmF5U2NoZW1hLCBldGMuXG4gICAgICAgICAgICAgICAgdGhpcy5yZWYuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVskY2hhbmdlc10uc2V0Um9vdChyb290KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRQYXJlbnQocGFyZW50LCByb290LCBwYXJlbnRJbmRleCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLnBhcmVudEluZGV4ID0gcGFyZW50SW5kZXg7XG4gICAgICAgICAgICAvLyBhdm9pZCBzZXR0aW5nIHBhcmVudHMgd2l0aCBlbXB0eSBgcm9vdGBcbiAgICAgICAgICAgIGlmICghcm9vdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNraXAgaWYgcGFyZW50IGlzIGFscmVhZHkgc2V0XG4gICAgICAgICAgICBpZiAocm9vdCAhPT0gdGhpcy5yb290KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrSXNGaWx0ZXJlZChwYXJlbnQsIHBhcmVudEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvb3QuYWRkKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXNzaWduIHNhbWUgcGFyZW50IG9uIGNoaWxkIHN0cnVjdHVyZXNcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gdGhpcy5yZWYuY29uc3RydWN0b3JbU3ltYm9sLm1ldGFkYXRhXTtcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhWyRyZWZUeXBlRmllbGRJbmRleGVzXT8uZm9yRWFjaCgoaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSBtZXRhZGF0YVtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5yZWZbZmllbGQubmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPy5bJGNoYW5nZXNdLnNldFBhcmVudCh0aGlzLnJlZiwgcm9vdCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5yZWZbJGNoaWxkVHlwZV0gJiYgdHlwZW9mICh0aGlzLnJlZlskY2hpbGRUeXBlXSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBNYXBTY2hlbWEgLyBBcnJheVNjaGVtYSwgZXRjLlxuICAgICAgICAgICAgICAgIHRoaXMucmVmLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVbJGNoYW5nZXNdLnNldFBhcmVudCh0aGlzLnJlZiwgcm9vdCwgdGhpcy5pbmRleGVzW2tleV0gPz8ga2V5KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3JFYWNoQ2hpbGQoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBhc3NpZ24gc2FtZSBwYXJlbnQgb24gY2hpbGQgc3RydWN0dXJlc1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gdGhpcy5yZWYuY29uc3RydWN0b3JbU3ltYm9sLm1ldGFkYXRhXTtcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhWyRyZWZUeXBlRmllbGRJbmRleGVzXT8uZm9yRWFjaCgoaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSBtZXRhZGF0YVtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5yZWZbZmllbGQubmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodmFsdWVbJGNoYW5nZXNdLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucmVmWyRjaGlsZFR5cGVdICYmIHR5cGVvZiAodGhpcy5yZWZbJGNoaWxkVHlwZV0pICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gTWFwU2NoZW1hIC8gQXJyYXlTY2hlbWEsIGV0Yy5cbiAgICAgICAgICAgICAgICB0aGlzLnJlZi5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHZhbHVlWyRjaGFuZ2VzXSwgdGhpcy5pbmRleGVzW2tleV0gPz8ga2V5KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvcGVyYXRpb24ob3ApIHtcbiAgICAgICAgICAgIC8vIG9wZXJhdGlvbnMgd2l0aG91dCBpbmRleCB1c2UgbmVnYXRpdmUgdmFsdWVzIHRvIHJlcHJlc2VudCB0aGVtXG4gICAgICAgICAgICAvLyB0aGlzIGlzIGNoZWNrZWQgZHVyaW5nIC5lbmNvZGUoKSB0aW1lLlxuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyZWRDaGFuZ2VzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcmVkQ2hhbmdlcy5vcGVyYXRpb25zLnB1c2goLW9wKTtcbiAgICAgICAgICAgICAgICBlbnF1ZXVlQ2hhbmdlVHJlZSh0aGlzLnJvb3QsIHRoaXMsICdmaWx0ZXJlZENoYW5nZXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlcy5vcGVyYXRpb25zLnB1c2goLW9wKTtcbiAgICAgICAgICAgICAgICBlbnF1ZXVlQ2hhbmdlVHJlZSh0aGlzLnJvb3QsIHRoaXMsICdjaGFuZ2VzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hhbmdlKGluZGV4LCBvcGVyYXRpb24gPSBleHBvcnRzLk9QRVJBVElPTi5BREQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gdGhpcy5yZWYuY29uc3RydWN0b3JbU3ltYm9sLm1ldGFkYXRhXTtcbiAgICAgICAgICAgIGNvbnN0IGlzRmlsdGVyZWQgPSB0aGlzLmlzRmlsdGVyZWQgfHwgKG1ldGFkYXRhPy5baW5kZXhdPy50YWcgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VTZXQgPSAoaXNGaWx0ZXJlZClcbiAgICAgICAgICAgICAgICA/IHRoaXMuZmlsdGVyZWRDaGFuZ2VzXG4gICAgICAgICAgICAgICAgOiB0aGlzLmNoYW5nZXM7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c09wZXJhdGlvbiA9IHRoaXMuaW5kZXhlZE9wZXJhdGlvbnNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKCFwcmV2aW91c09wZXJhdGlvbiB8fCBwcmV2aW91c09wZXJhdGlvbiA9PT0gZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3AgPSAoIXByZXZpb3VzT3BlcmF0aW9uKVxuICAgICAgICAgICAgICAgICAgICA/IG9wZXJhdGlvblxuICAgICAgICAgICAgICAgICAgICA6IChwcmV2aW91c09wZXJhdGlvbiA9PT0gZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEVfQU5EX0FERFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBvcGVyYXRpb247XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBhcmUgREVMRVRFIG9wZXJhdGlvbnMgYmVpbmcgZW5jb2RlZCBhcyBBREQgaGVyZSA/P1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleGVkT3BlcmF0aW9uc1tpbmRleF0gPSBvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE9wZXJhdGlvbkF0SW5kZXgoY2hhbmdlU2V0LCBpbmRleCk7XG4gICAgICAgICAgICBpZiAoaXNGaWx0ZXJlZCkge1xuICAgICAgICAgICAgICAgIHNldE9wZXJhdGlvbkF0SW5kZXgodGhpcy5hbGxGaWx0ZXJlZENoYW5nZXMsIGluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICAgICAgICAgICAgICAgIGVucXVldWVDaGFuZ2VUcmVlKHRoaXMucm9vdCwgdGhpcywgJ2ZpbHRlcmVkQ2hhbmdlcycpO1xuICAgICAgICAgICAgICAgICAgICBlbnF1ZXVlQ2hhbmdlVHJlZSh0aGlzLnJvb3QsIHRoaXMsICdhbGxGaWx0ZXJlZENoYW5nZXMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRPcGVyYXRpb25BdEluZGV4KHRoaXMuYWxsQ2hhbmdlcywgaW5kZXgpO1xuICAgICAgICAgICAgICAgIGVucXVldWVDaGFuZ2VUcmVlKHRoaXMucm9vdCwgdGhpcywgJ2NoYW5nZXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzaGlmdENoYW5nZUluZGV4ZXMoc2hpZnRJbmRleCkge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFVzZWQgb25seSBkdXJpbmc6XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gLSBBcnJheVNjaGVtYSN1bnNoaWZ0KClcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VTZXQgPSAodGhpcy5pc0ZpbHRlcmVkKVxuICAgICAgICAgICAgICAgID8gdGhpcy5maWx0ZXJlZENoYW5nZXNcbiAgICAgICAgICAgICAgICA6IHRoaXMuY2hhbmdlcztcbiAgICAgICAgICAgIGNvbnN0IG5ld0luZGV4ZWRPcGVyYXRpb25zID0ge307XG4gICAgICAgICAgICBjb25zdCBuZXdJbmRleGVzID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGluZGV4IGluIHRoaXMuaW5kZXhlZE9wZXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBuZXdJbmRleGVkT3BlcmF0aW9uc1tOdW1iZXIoaW5kZXgpICsgc2hpZnRJbmRleF0gPSB0aGlzLmluZGV4ZWRPcGVyYXRpb25zW2luZGV4XTtcbiAgICAgICAgICAgICAgICBuZXdJbmRleGVzW051bWJlcihpbmRleCkgKyBzaGlmdEluZGV4XSA9IGNoYW5nZVNldC5pbmRleGVzW2luZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW5kZXhlZE9wZXJhdGlvbnMgPSBuZXdJbmRleGVkT3BlcmF0aW9ucztcbiAgICAgICAgICAgIGNoYW5nZVNldC5pbmRleGVzID0gbmV3SW5kZXhlcztcbiAgICAgICAgICAgIGNoYW5nZVNldC5vcGVyYXRpb25zID0gY2hhbmdlU2V0Lm9wZXJhdGlvbnMubWFwKChpbmRleCkgPT4gaW5kZXggKyBzaGlmdEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBzaGlmdEFsbENoYW5nZUluZGV4ZXMoc2hpZnRJbmRleCwgc3RhcnRJbmRleCA9IDApIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBVc2VkIG9ubHkgZHVyaW5nOlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIC0gQXJyYXlTY2hlbWEjc3BsaWNlKClcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJlZENoYW5nZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NoaWZ0QWxsQ2hhbmdlSW5kZXhlcyhzaGlmdEluZGV4LCBzdGFydEluZGV4LCB0aGlzLmFsbEZpbHRlcmVkQ2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hpZnRBbGxDaGFuZ2VJbmRleGVzKHNoaWZ0SW5kZXgsIHN0YXJ0SW5kZXgsIHRoaXMuYWxsQ2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaGlmdEFsbENoYW5nZUluZGV4ZXMoc2hpZnRJbmRleCwgc3RhcnRJbmRleCwgdGhpcy5hbGxDaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfc2hpZnRBbGxDaGFuZ2VJbmRleGVzKHNoaWZ0SW5kZXgsIHN0YXJ0SW5kZXggPSAwLCBjaGFuZ2VTZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0luZGV4ZXMgPSB7fTtcbiAgICAgICAgICAgIGxldCBuZXdLZXkgPSAwO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY2hhbmdlU2V0LmluZGV4ZXMpIHtcbiAgICAgICAgICAgICAgICBuZXdJbmRleGVzW25ld0tleSsrXSA9IGNoYW5nZVNldC5pbmRleGVzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFuZ2VTZXQuaW5kZXhlcyA9IG5ld0luZGV4ZXM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYW5nZVNldC5vcGVyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjaGFuZ2VTZXQub3BlcmF0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiBzdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZVNldC5vcGVyYXRpb25zW2ldID0gaW5kZXggKyBzaGlmdEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbmRleGVkT3BlcmF0aW9uKGluZGV4LCBvcGVyYXRpb24sIGFsbENoYW5nZXNJbmRleCA9IGluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ZWRPcGVyYXRpb25zW2luZGV4XSA9IG9wZXJhdGlvbjtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcmVkQ2hhbmdlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2V0T3BlcmF0aW9uQXRJbmRleCh0aGlzLmFsbEZpbHRlcmVkQ2hhbmdlcywgYWxsQ2hhbmdlc0luZGV4KTtcbiAgICAgICAgICAgICAgICBzZXRPcGVyYXRpb25BdEluZGV4KHRoaXMuZmlsdGVyZWRDaGFuZ2VzLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgZW5xdWV1ZUNoYW5nZVRyZWUodGhpcy5yb290LCB0aGlzLCAnZmlsdGVyZWRDaGFuZ2VzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRPcGVyYXRpb25BdEluZGV4KHRoaXMuYWxsQ2hhbmdlcywgYWxsQ2hhbmdlc0luZGV4KTtcbiAgICAgICAgICAgICAgICBzZXRPcGVyYXRpb25BdEluZGV4KHRoaXMuY2hhbmdlcywgaW5kZXgpO1xuICAgICAgICAgICAgICAgIGVucXVldWVDaGFuZ2VUcmVlKHRoaXMucm9vdCwgdGhpcywgJ2NoYW5nZXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZXRUeXBlKGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoTWV0YWRhdGEuaXNWYWxpZEluc3RhbmNlKHRoaXMucmVmKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gdGhpcy5yZWYuY29uc3RydWN0b3JbU3ltYm9sLm1ldGFkYXRhXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWV0YWRhdGFbaW5kZXhdLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgY2hpbGQgdHlwZSBmcm9tIHBhcmVudCBzdHJ1Y3R1cmUuXG4gICAgICAgICAgICAgICAgLy8gLSBbXCJzdHJpbmdcIl0gPT4gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgIC8vIC0geyBtYXA6IFwic3RyaW5nXCIgfSA9PiBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgLy8gLSB7IHNldDogXCJzdHJpbmdcIiB9ID0+IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZlskY2hpbGRUeXBlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZXRDaGFuZ2UoaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4ZWRPcGVyYXRpb25zW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICAvL1xuICAgICAgICAvLyB1c2VkIGR1cmluZyBgLmVuY29kZSgpYFxuICAgICAgICAvL1xuICAgICAgICBnZXRWYWx1ZShpbmRleCwgaXNFbmNvZGVBbGwgPSBmYWxzZSkge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGBpc0VuY29kZUFsbGAgcGFyYW0gaXMgb25seSB1c2VkIGJ5IEFycmF5U2NoZW1hXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmWyRnZXRCeUluZGV4XShpbmRleCwgaXNFbmNvZGVBbGwpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZShpbmRleCwgb3BlcmF0aW9uLCBhbGxDaGFuZ2VzSW5kZXggPSBpbmRleCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBjb2x5c2V1cy9zY2hlbWEgJHt0aGlzLnJlZi5jb25zdHJ1Y3Rvci5uYW1lfTogdHJ5aW5nIHRvIGRlbGV0ZSBub24tZXhpc3RpbmcgaW5kZXggJyR7aW5kZXh9J2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZVNldCA9ICh0aGlzLmZpbHRlcmVkQ2hhbmdlcyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgID8gdGhpcy5maWx0ZXJlZENoYW5nZXNcbiAgICAgICAgICAgICAgICA6IHRoaXMuY2hhbmdlcztcbiAgICAgICAgICAgIHRoaXMuaW5kZXhlZE9wZXJhdGlvbnNbaW5kZXhdID0gb3BlcmF0aW9uID8/IGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURTtcbiAgICAgICAgICAgIHNldE9wZXJhdGlvbkF0SW5kZXgoY2hhbmdlU2V0LCBpbmRleCk7XG4gICAgICAgICAgICBkZWxldGVPcGVyYXRpb25BdEluZGV4KHRoaXMuYWxsQ2hhbmdlcywgYWxsQ2hhbmdlc0luZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSB0aGlzLmdldFZhbHVlKGluZGV4KTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBgcm9vdGAgcmVmZXJlbmNlXG4gICAgICAgICAgICBpZiAocHJldmlvdXNWYWx1ZSAmJiBwcmV2aW91c1ZhbHVlWyRjaGFuZ2VzXSkge1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IHRoaXMucm9vdCBpcyBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBUaGlzIG1ldGhvZCBpcyBiZWluZyBjYWxsZWQgYXQgZGVjb2RpbmcgdGltZSB3aGVuIGEgREVMRVRFIG9wZXJhdGlvbiBpcyBmb3VuZC5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIC0gVGhpcyBpcyBkdWUgdG8gdXNpbmcgdGhlIGNvbmNyZXRlIFNjaGVtYSBjbGFzcyBhdCBkZWNvZGluZyB0aW1lLlxuICAgICAgICAgICAgICAgIC8vIC0gXCJSZWZsZWN0ZWRcIiBzdHJ1Y3R1cmVzIGRvIG5vdCBoYXZlIHRoaXMgcHJvYmxlbS5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIChUaGUgcHJvcGVydHkgZGVzY3JpcHRvcnMgc2hvdWxkIE5PVCBiZSB1c2VkIGF0IGRlY29kaW5nIHRpbWUuIG9ubHkgYXQgZW5jb2RpbmcgdGltZS4pXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICB0aGlzLnJvb3Q/LnJlbW92ZShwcmV2aW91c1ZhbHVlWyRjaGFuZ2VzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gRklYTUU6IHRoaXMgaXMgbG9va2luZyBhIHVnbHkgYW5kIHJlcGVhdGVkXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyZWRDaGFuZ2VzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGVPcGVyYXRpb25BdEluZGV4KHRoaXMuYWxsRmlsdGVyZWRDaGFuZ2VzLCBhbGxDaGFuZ2VzSW5kZXgpO1xuICAgICAgICAgICAgICAgIGVucXVldWVDaGFuZ2VUcmVlKHRoaXMucm9vdCwgdGhpcywgJ2ZpbHRlcmVkQ2hhbmdlcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5xdWV1ZUNoYW5nZVRyZWUodGhpcy5yb290LCB0aGlzLCAnY2hhbmdlcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZW5kRW5jb2RlKGNoYW5nZVNldE5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhlZE9wZXJhdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIC8vIGNsZWFyIGNoYW5nZXNldFxuICAgICAgICAgICAgdGhpc1tjaGFuZ2VTZXROYW1lXS5pbmRleGVzID0ge307XG4gICAgICAgICAgICB0aGlzW2NoYW5nZVNldE5hbWVdLm9wZXJhdGlvbnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXNbY2hhbmdlU2V0TmFtZV0ucXVldWVSb290SW5kZXggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAvLyBBcnJheVNjaGVtYSBhbmQgTWFwU2NoZW1hIGhhdmUgYSBjdXN0b20gXCJlbmNvZGUgZW5kXCIgbWV0aG9kXG4gICAgICAgICAgICB0aGlzLnJlZlskb25FbmNvZGVFbmRdPy4oKTtcbiAgICAgICAgICAgIC8vIE5vdCBhIG5ldyBpbnN0YW5jZSBhbnltb3JlXG4gICAgICAgICAgICB0aGlzLmlzTmV3ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZGlzY2FyZChkaXNjYXJkQWxsID0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyA+IE1hcFNjaGVtYTpcbiAgICAgICAgICAgIC8vICAgICAgUmVtb3ZlIGNhY2hlZCBrZXkgdG8gZW5zdXJlIEFERCBvcGVyYXRpb25zIGlzIHVuc2VkIGluc3RlYWQgb2ZcbiAgICAgICAgICAgIC8vICAgICAgUkVQTEFDRSBpbiBjYXNlIHNhbWUga2V5IGlzIHVzZWQgb24gbmV4dCBwYXRjaGVzLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHRoaXMucmVmWyRvbkVuY29kZUVuZF0/LigpO1xuICAgICAgICAgICAgdGhpcy5pbmRleGVkT3BlcmF0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VzLmluZGV4ZXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlcy5vcGVyYXRpb25zLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZXMucXVldWVSb290SW5kZXggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJlZENoYW5nZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyZWRDaGFuZ2VzLmluZGV4ZXMgPSB7fTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcmVkQ2hhbmdlcy5vcGVyYXRpb25zLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJlZENoYW5nZXMucXVldWVSb290SW5kZXggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlzY2FyZEFsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWxsQ2hhbmdlcy5pbmRleGVzID0ge307XG4gICAgICAgICAgICAgICAgdGhpcy5hbGxDaGFuZ2VzLm9wZXJhdGlvbnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hbGxGaWx0ZXJlZENoYW5nZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFsbEZpbHRlcmVkQ2hhbmdlcy5pbmRleGVzID0ge307XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxsRmlsdGVyZWRDaGFuZ2VzLm9wZXJhdGlvbnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGNoaWxkcmVuIHJlZmVyZW5jZXNcbiAgICAgICAgICAgICAgICB0aGlzLmZvckVhY2hDaGlsZCgoY2hhbmdlVHJlZSwgXykgPT4gdGhpcy5yb290Py5yZW1vdmUoY2hhbmdlVHJlZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWN1cnNpdmVseSBkaXNjYXJkIGFsbCBjaGFuZ2VzIGZyb20gdGhpcywgYW5kIGNoaWxkIHN0cnVjdHVyZXMuXG4gICAgICAgICAqL1xuICAgICAgICBkaXNjYXJkQWxsKCkge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuaW5kZXhlZE9wZXJhdGlvbnMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGtleXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoTnVtYmVyKGtleXNbaV0pKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWVbJGNoYW5nZXNdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlWyRjaGFuZ2VzXS5kaXNjYXJkQWxsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kaXNjYXJkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlUmVmSWQoKSB7XG4gICAgICAgICAgICAvLyBza2lwIGlmIHJlZklkIGlzIGFscmVhZHkgc2V0LlxuICAgICAgICAgICAgaWYgKHRoaXMucmVmSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVmSWQgPSB0aGlzLnJvb3QuZ2V0TmV4dFVuaXF1ZUlkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGNoYW5nZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gKE9iamVjdC5lbnRyaWVzKHRoaXMuaW5kZXhlZE9wZXJhdGlvbnMpLmxlbmd0aCA+IDApO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrSXNGaWx0ZXJlZChwYXJlbnQsIHBhcmVudEluZGV4KSB7XG4gICAgICAgICAgICBjb25zdCBpc05ld0NoYW5nZVRyZWUgPSB0aGlzLnJvb3QuYWRkKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMucm9vdC50eXBlcy5oYXNGaWx0ZXJzKSB7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBBdCBTY2hlbWEgaW5pdGlhbGl6YXRpb24sIHRoZSBcInJvb3RcIiBzdHJ1Y3R1cmUgbWlnaHQgbm90IGJlIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIC8vIHlldCwgYXMgaXQgb25seSBkb2VzIG9uY2UgdGhlIFwiRW5jb2RlclwiIGhhcyBiZWVuIHNldCB1cC5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFNvIHRoZSBcInBhcmVudFwiIG1heSBiZSBhbHJlYWR5IHNldCB3aXRob3V0IGEgXCJyb290XCIuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja0ZpbHRlcmVkQnlQYXJlbnQocGFyZW50LCBwYXJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyZWRDaGFuZ2VzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5xdWV1ZUNoYW5nZVRyZWUodGhpcy5yb290LCB0aGlzLCAnZmlsdGVyZWRDaGFuZ2VzJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05ld0NoYW5nZVRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucm9vdC5hbGxGaWx0ZXJlZENoYW5nZXMucHVzaCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5pc0ZpbHRlcmVkKSB7XG4gICAgICAgICAgICAgICAgZW5xdWV1ZUNoYW5nZVRyZWUodGhpcy5yb290LCB0aGlzLCAnY2hhbmdlcycpO1xuICAgICAgICAgICAgICAgIGlmIChpc05ld0NoYW5nZVRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290LmFsbENoYW5nZXMucHVzaCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX2NoZWNrRmlsdGVyZWRCeVBhcmVudChwYXJlbnQsIHBhcmVudEluZGV4KSB7XG4gICAgICAgICAgICAvLyBza2lwIGlmIHBhcmVudCBpcyBub3Qgc2V0XG4gICAgICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBBcnJheVNjaGVtYSB8IE1hcFNjaGVtYSAtIGdldCB0aGUgY2hpbGQgdHlwZVxuICAgICAgICAgICAgLy8gKGlmIHJlZlR5cGUgaXMgdHlwZW9mIHN0cmluZywgdGhlIHBhcmVudEZpbHRlcmVkW2tleV0gYmVsb3cgd2lsbCBhbHdheXMgYmUgaW52YWxpZClcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBjb25zdCByZWZUeXBlID0gTWV0YWRhdGEuaXNWYWxpZEluc3RhbmNlKHRoaXMucmVmKVxuICAgICAgICAgICAgICAgID8gdGhpcy5yZWYuY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICA6IHRoaXMucmVmWyRjaGlsZFR5cGVdO1xuICAgICAgICAgICAgbGV0IHBhcmVudENoYW5nZVRyZWU7XG4gICAgICAgICAgICBsZXQgcGFyZW50SXNDb2xsZWN0aW9uID0gIU1ldGFkYXRhLmlzVmFsaWRJbnN0YW5jZShwYXJlbnQpO1xuICAgICAgICAgICAgaWYgKHBhcmVudElzQ29sbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIHBhcmVudENoYW5nZVRyZWUgPSBwYXJlbnRbJGNoYW5nZXNdO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudENoYW5nZVRyZWUucGFyZW50O1xuICAgICAgICAgICAgICAgIHBhcmVudEluZGV4ID0gcGFyZW50Q2hhbmdlVHJlZS5wYXJlbnRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudENoYW5nZVRyZWUgPSBwYXJlbnRbJGNoYW5nZXNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFyZW50Q29uc3RydWN0b3IgPSBwYXJlbnQuY29uc3RydWN0b3I7XG4gICAgICAgICAgICBsZXQga2V5ID0gYCR7dGhpcy5yb290LnR5cGVzLmdldFR5cGVJZChyZWZUeXBlKX1gO1xuICAgICAgICAgICAgaWYgKHBhcmVudENvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAga2V5ICs9IGAtJHt0aGlzLnJvb3QudHlwZXMuc2NoZW1hcy5nZXQocGFyZW50Q29uc3RydWN0b3IpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZXkgKz0gYC0ke3BhcmVudEluZGV4fWA7XG4gICAgICAgICAgICBjb25zdCBmaWVsZEhhc1ZpZXdUYWcgPSBNZXRhZGF0YS5oYXNWaWV3VGFnQXRJbmRleChwYXJlbnRDb25zdHJ1Y3Rvcj8uW1N5bWJvbC5tZXRhZGF0YV0sIHBhcmVudEluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuaXNGaWx0ZXJlZCA9IHBhcmVudFskY2hhbmdlc10uaXNGaWx0ZXJlZCAvLyBpbiBjYXNlIHBhcmVudCBpcyBhbHJlYWR5IGZpbHRlcmVkXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5yb290LnR5cGVzLnBhcmVudEZpbHRlcmVkW2tleV1cbiAgICAgICAgICAgICAgICB8fCBmaWVsZEhhc1ZpZXdUYWc7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gXCJpc0ZpbHRlcmVkXCIgbWF5IG5vdCBiZSBpbWVkaWFsZWx5IGF2YWlsYWJsZSBkdXJpbmcgYGNoYW5nZSgpYCBkdWUgdG8gdGhlIGluc3RhbmNlIG5vdCBiZWluZyBhdHRhY2hlZCB0byB0aGUgcm9vdCB5ZXQuXG4gICAgICAgICAgICAvLyB3aGVuIGl0J3MgYXZhaWxhYmxlLCB3ZSBuZWVkIHRvIGVucXVldWUgdGhlIFwiY2hhbmdlc1wiIGNoYW5nZXNldCBpbnRvIHRoZSBcImZpbHRlcmVkQ2hhbmdlc1wiIGNoYW5nZXNldC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBpZiAodGhpcy5pc0ZpbHRlcmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1Zpc2liaWxpdHlTaGFyZWRXaXRoUGFyZW50ID0gKHBhcmVudENoYW5nZVRyZWUuaXNGaWx0ZXJlZCAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgKHJlZlR5cGUpICE9PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgICAgICFmaWVsZEhhc1ZpZXdUYWcgJiZcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50SXNDb2xsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZmlsdGVyZWRDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyZWRDaGFuZ2VzID0gY3JlYXRlQ2hhbmdlU2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxsRmlsdGVyZWRDaGFuZ2VzID0gY3JlYXRlQ2hhbmdlU2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5nZXMub3BlcmF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlcy5vcGVyYXRpb25zLmZvckVhY2goKGluZGV4KSA9PiBzZXRPcGVyYXRpb25BdEluZGV4KHRoaXMuZmlsdGVyZWRDaGFuZ2VzLCBpbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFsbENoYW5nZXMub3BlcmF0aW9ucy5mb3JFYWNoKChpbmRleCkgPT4gc2V0T3BlcmF0aW9uQXRJbmRleCh0aGlzLmFsbEZpbHRlcmVkQ2hhbmdlcywgaW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VzID0gY3JlYXRlQ2hhbmdlU2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxsQ2hhbmdlcyA9IGNyZWF0ZUNoYW5nZVNldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuY29kZVZhbHVlKGVuY29kZXIsIGJ5dGVzLCB0eXBlLCB2YWx1ZSwgb3BlcmF0aW9uLCBpdCkge1xuICAgICAgICBpZiAodHlwZW9mICh0eXBlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZW5jb2RlW3R5cGVdPy4oYnl0ZXMsIHZhbHVlLCBpdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZVtTeW1ib2wubWV0YWRhdGFdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBFbmNvZGUgcmVmSWQgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAgICAgICAgICAvLyBUaGUgYWN0dWFsIGluc3RhbmNlIGlzIGdvaW5nIHRvIGJlIGVuY29kZWQgb24gbmV4dCBgY2hhbmdlVHJlZWAgaXRlcmF0aW9uLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGVuY29kZS5udW1iZXIoYnl0ZXMsIHZhbHVlWyRjaGFuZ2VzXS5yZWZJZCwgaXQpO1xuICAgICAgICAgICAgLy8gVHJ5IHRvIGVuY29kZSBpbmhlcml0ZWQgVFlQRV9JRCBpZiBpdCdzIGFuIEFERCBvcGVyYXRpb24uXG4gICAgICAgICAgICBpZiAoKG9wZXJhdGlvbiAmIGV4cG9ydHMuT1BFUkFUSU9OLkFERCkgPT09IGV4cG9ydHMuT1BFUkFUSU9OLkFERCkge1xuICAgICAgICAgICAgICAgIGVuY29kZXIudHJ5RW5jb2RlVHlwZUlkKGJ5dGVzLCB0eXBlLCB2YWx1ZS5jb25zdHJ1Y3RvciwgaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEVuY29kZSByZWZJZCBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICAgICAgICAgIC8vIFRoZSBhY3R1YWwgaW5zdGFuY2UgaXMgZ29pbmcgdG8gYmUgZW5jb2RlZCBvbiBuZXh0IGBjaGFuZ2VUcmVlYCBpdGVyYXRpb24uXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgZW5jb2RlLm51bWJlcihieXRlcywgdmFsdWVbJGNoYW5nZXNdLnJlZklkLCBpdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgU2NoZW1hIGluc3RhbmNlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0IGVuY29kZVNjaGVtYU9wZXJhdGlvbiA9IGZ1bmN0aW9uIChlbmNvZGVyLCBieXRlcywgY2hhbmdlVHJlZSwgaW5kZXgsIG9wZXJhdGlvbiwgaXQsIF8sIF9fLCBtZXRhZGF0YSkge1xuICAgICAgICAvLyBcImNvbXByZXNzXCIgZmllbGQgaW5kZXggKyBvcGVyYXRpb25cbiAgICAgICAgYnl0ZXNbaXQub2Zmc2V0KytdID0gKGluZGV4IHwgb3BlcmF0aW9uKSAmIDI1NTtcbiAgICAgICAgLy8gRG8gbm90IGVuY29kZSB2YWx1ZSBmb3IgREVMRVRFIG9wZXJhdGlvbnNcbiAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVmID0gY2hhbmdlVHJlZS5yZWY7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gbWV0YWRhdGFbaW5kZXhdO1xuICAgICAgICAvLyBUT0RPOiBpbmxpbmUgdGhpcyBmdW5jdGlvbiBjYWxsIHNtYWxsIHBlcmZvcm1hbmNlIGdhaW5cbiAgICAgICAgZW5jb2RlVmFsdWUoZW5jb2RlciwgYnl0ZXMsIG1ldGFkYXRhW2luZGV4XS50eXBlLCByZWZbZmllbGQubmFtZV0sIG9wZXJhdGlvbiwgaXQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgY29sbGVjdGlvbnMgKE1hcFNjaGVtYSwgQ29sbGVjdGlvblNjaGVtYSwgU2V0U2NoZW1hKVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3QgZW5jb2RlS2V5VmFsdWVPcGVyYXRpb24gPSBmdW5jdGlvbiAoZW5jb2RlciwgYnl0ZXMsIGNoYW5nZVRyZWUsIGluZGV4LCBvcGVyYXRpb24sIGl0KSB7XG4gICAgICAgIC8vIGVuY29kZSBvcGVyYXRpb25cbiAgICAgICAgYnl0ZXNbaXQub2Zmc2V0KytdID0gb3BlcmF0aW9uICYgMjU1O1xuICAgICAgICAvLyBjdXN0b20gb3BlcmF0aW9uc1xuICAgICAgICBpZiAob3BlcmF0aW9uID09PSBleHBvcnRzLk9QRVJBVElPTi5DTEVBUikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVuY29kZSBpbmRleFxuICAgICAgICBlbmNvZGUubnVtYmVyKGJ5dGVzLCBpbmRleCwgaXQpO1xuICAgICAgICAvLyBEbyBub3QgZW5jb2RlIHZhbHVlIGZvciBERUxFVEUgb3BlcmF0aW9uc1xuICAgICAgICBpZiAob3BlcmF0aW9uID09PSBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWYgPSBjaGFuZ2VUcmVlLnJlZjtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gZW5jb2RlIFwiYWxpYXNcIiBmb3IgZHluYW1pYyBmaWVsZHMgKG1hcHMpXG4gICAgICAgIC8vXG4gICAgICAgIGlmICgob3BlcmF0aW9uICYgZXhwb3J0cy5PUEVSQVRJT04uQUREKSA9PT0gZXhwb3J0cy5PUEVSQVRJT04uQUREKSB7IC8vIEFERCBvciBERUxFVEVfQU5EX0FERFxuICAgICAgICAgICAgaWYgKHR5cGVvZiAocmVmWydzZXQnXSkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gTWFwU2NoZW1hIGR5bmFtaWMga2V5XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBjb25zdCBkeW5hbWljSW5kZXggPSBjaGFuZ2VUcmVlLnJlZlsnJGluZGV4ZXMnXS5nZXQoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGVuY29kZS5zdHJpbmcoYnl0ZXMsIGR5bmFtaWNJbmRleCwgaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGUgPSByZWZbJGNoaWxkVHlwZV07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcmVmWyRnZXRCeUluZGV4XShpbmRleCk7XG4gICAgICAgIC8vIHRyeSB7IHRocm93IG5ldyBFcnJvcigpOyB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vICAgICAvLyBvbmx5IHByaW50IGlmIG5vdCBjb21pbmcgZnJvbSBSZWZsZWN0aW9uLnRzXG4gICAgICAgIC8vICAgICBpZiAoIWUuc3RhY2suaW5jbHVkZXMoXCJzcmMvUmVmbGVjdGlvbi50c1wiKSkge1xuICAgICAgICAvLyAgICAgICAgIGNvbnNvbGUubG9nKFwiZW5jb2RlS2V5VmFsdWVPcGVyYXRpb24gLT4gXCIsIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgcmVmOiBjaGFuZ2VUcmVlLnJlZi5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgICAvLyAgICAgICAgICAgICBmaWVsZCxcbiAgICAgICAgLy8gICAgICAgICAgICAgb3BlcmF0aW9uOiBPUEVSQVRJT05bb3BlcmF0aW9uXSxcbiAgICAgICAgLy8gICAgICAgICAgICAgdmFsdWU6IHZhbHVlPy50b0pTT04oKSxcbiAgICAgICAgLy8gICAgICAgICAgICAgaXRlbXM6IHJlZi50b0pTT04oKSxcbiAgICAgICAgLy8gICAgICAgICB9KTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBUT0RPOiBpbmxpbmUgdGhpcyBmdW5jdGlvbiBjYWxsIHNtYWxsIHBlcmZvcm1hbmNlIGdhaW5cbiAgICAgICAgZW5jb2RlVmFsdWUoZW5jb2RlciwgYnl0ZXMsIHR5cGUsIHZhbHVlLCBvcGVyYXRpb24sIGl0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGNvbGxlY3Rpb25zIChNYXBTY2hlbWEsIEFycmF5U2NoZW1hLCBldGMuKVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3QgZW5jb2RlQXJyYXkgPSBmdW5jdGlvbiAoZW5jb2RlciwgYnl0ZXMsIGNoYW5nZVRyZWUsIGZpZWxkLCBvcGVyYXRpb24sIGl0LCBpc0VuY29kZUFsbCwgaGFzVmlldykge1xuICAgICAgICBjb25zdCByZWYgPSBjaGFuZ2VUcmVlLnJlZjtcbiAgICAgICAgY29uc3QgdXNlT3BlcmF0aW9uQnlSZWZJZCA9IGhhc1ZpZXcgJiYgY2hhbmdlVHJlZS5pc0ZpbHRlcmVkICYmICh0eXBlb2YgKGNoYW5nZVRyZWUuZ2V0VHlwZShmaWVsZCkpICE9PSBcInN0cmluZ1wiKTtcbiAgICAgICAgbGV0IHJlZk9ySW5kZXg7XG4gICAgICAgIGlmICh1c2VPcGVyYXRpb25CeVJlZklkKSB7XG4gICAgICAgICAgICByZWZPckluZGV4ID0gcmVmWyd0bXBJdGVtcyddW2ZpZWxkXVskY2hhbmdlc10ucmVmSWQ7XG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uID09PSBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEUpIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24gPSBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEVfQllfUkVGSUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24gPT09IGV4cG9ydHMuT1BFUkFUSU9OLkFERCkge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9IGV4cG9ydHMuT1BFUkFUSU9OLkFERF9CWV9SRUZJRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlZk9ySW5kZXggPSBmaWVsZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbmNvZGUgb3BlcmF0aW9uXG4gICAgICAgIGJ5dGVzW2l0Lm9mZnNldCsrXSA9IG9wZXJhdGlvbiAmIDI1NTtcbiAgICAgICAgLy8gY3VzdG9tIG9wZXJhdGlvbnNcbiAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gZXhwb3J0cy5PUEVSQVRJT04uQ0xFQVIgfHxcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9PT0gZXhwb3J0cy5PUEVSQVRJT04uUkVWRVJTRSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVuY29kZSBpbmRleFxuICAgICAgICBlbmNvZGUubnVtYmVyKGJ5dGVzLCByZWZPckluZGV4LCBpdCk7XG4gICAgICAgIC8vIERvIG5vdCBlbmNvZGUgdmFsdWUgZm9yIERFTEVURSBvcGVyYXRpb25zXG4gICAgICAgIGlmIChvcGVyYXRpb24gPT09IGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURSB8fCBvcGVyYXRpb24gPT09IGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURV9CWV9SRUZJRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGUgPSBjaGFuZ2VUcmVlLmdldFR5cGUoZmllbGQpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGNoYW5nZVRyZWUuZ2V0VmFsdWUoZmllbGQsIGlzRW5jb2RlQWxsKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coeyB0eXBlLCBmaWVsZCwgdmFsdWUgfSk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiZW5jb2RlQXJyYXkgLT4gXCIsIHtcbiAgICAgICAgLy8gICAgIHJlZjogY2hhbmdlVHJlZS5yZWYuY29uc3RydWN0b3IubmFtZSxcbiAgICAgICAgLy8gICAgIGZpZWxkLFxuICAgICAgICAvLyAgICAgb3BlcmF0aW9uOiBPUEVSQVRJT05bb3BlcmF0aW9uXSxcbiAgICAgICAgLy8gICAgIHZhbHVlOiB2YWx1ZT8udG9KU09OKCksXG4gICAgICAgIC8vICAgICBpdGVtczogcmVmLnRvSlNPTigpLFxuICAgICAgICAvLyB9KTtcbiAgICAgICAgLy8gVE9ETzogaW5saW5lIHRoaXMgZnVuY3Rpb24gY2FsbCBzbWFsbCBwZXJmb3JtYW5jZSBnYWluXG4gICAgICAgIGVuY29kZVZhbHVlKGVuY29kZXIsIGJ5dGVzLCB0eXBlLCB2YWx1ZSwgb3BlcmF0aW9uLCBpdCk7XG4gICAgfTtcblxuICAgIGNvbnN0IERFRklOSVRJT05fTUlTTUFUQ0ggPSAtMTtcbiAgICBmdW5jdGlvbiBkZWNvZGVWYWx1ZShkZWNvZGVyLCBvcGVyYXRpb24sIHJlZiwgaW5kZXgsIHR5cGUsIGJ5dGVzLCBpdCwgYWxsQ2hhbmdlcykge1xuICAgICAgICBjb25zdCAkcm9vdCA9IGRlY29kZXIucm9vdDtcbiAgICAgICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IHJlZlskZ2V0QnlJbmRleF0oaW5kZXgpO1xuICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgIGlmICgob3BlcmF0aW9uICYgZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFKSA9PT0gZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFKSB7XG4gICAgICAgICAgICAvLyBGbGFnIGByZWZJZGAgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbi5cbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzUmVmSWQgPSAkcm9vdC5yZWZJZHMuZ2V0KHByZXZpb3VzVmFsdWUpO1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzUmVmSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICRyb290LnJlbW92ZVJlZihwcmV2aW91c1JlZklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBEZWxldGUgb3BlcmF0aW9uc1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24gIT09IGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURV9BTkRfQUREKSB7XG4gICAgICAgICAgICAgICAgcmVmWyRkZWxldGVCeUluZGV4XShpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3BlcmF0aW9uID09PSBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEUpIDtcbiAgICAgICAgZWxzZSBpZiAoU2NoZW1hLmlzKHR5cGUpKSB7XG4gICAgICAgICAgICBjb25zdCByZWZJZCA9IGRlY29kZS5udW1iZXIoYnl0ZXMsIGl0KTtcbiAgICAgICAgICAgIHZhbHVlID0gJHJvb3QucmVmcy5nZXQocmVmSWQpO1xuICAgICAgICAgICAgaWYgKChvcGVyYXRpb24gJiBleHBvcnRzLk9QRVJBVElPTi5BREQpID09PSBleHBvcnRzLk9QRVJBVElPTi5BREQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZFR5cGUgPSBkZWNvZGVyLmdldEluc3RhbmNlVHlwZShieXRlcywgaXQsIHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBkZWNvZGVyLmNyZWF0ZUluc3RhbmNlT2ZUeXBlKGNoaWxkVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICRyb290LmFkZFJlZihyZWZJZCwgdmFsdWUsICh2YWx1ZSAhPT0gcHJldmlvdXNWYWx1ZSB8fCAvLyBpbmNyZW1lbnQgcmVmIGNvdW50IGlmIHZhbHVlIGhhcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgIChvcGVyYXRpb24gPT09IGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURV9BTkRfQUREICYmIHZhbHVlID09PSBwcmV2aW91c1ZhbHVlKSAvLyBpbmNyZW1lbnQgcmVmIGNvdW50IGlmIHRoZSBzYW1lIGluc3RhbmNlIGlzIGJlaW5nIGFkZGVkIGFnYWluXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mICh0eXBlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHByaW1pdGl2ZSB2YWx1ZSAobnVtYmVyLCBzdHJpbmcsIGJvb2xlYW4sIGV0YylcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICB2YWx1ZSA9IGRlY29kZVt0eXBlXShieXRlcywgaXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdHlwZURlZiA9IGdldFR5cGUoT2JqZWN0LmtleXModHlwZSlbMF0pO1xuICAgICAgICAgICAgY29uc3QgcmVmSWQgPSBkZWNvZGUubnVtYmVyKGJ5dGVzLCBpdCk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZVJlZiA9ICgkcm9vdC5yZWZzLmhhcyhyZWZJZCkpXG4gICAgICAgICAgICAgICAgPyBwcmV2aW91c1ZhbHVlIHx8ICRyb290LnJlZnMuZ2V0KHJlZklkKVxuICAgICAgICAgICAgICAgIDogbmV3IHR5cGVEZWYuY29uc3RydWN0b3IoKTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVSZWYuY2xvbmUodHJ1ZSk7XG4gICAgICAgICAgICB2YWx1ZVskY2hpbGRUeXBlXSA9IE9iamVjdC52YWx1ZXModHlwZSlbMF07IC8vIGNhY2hlIGNoaWxkVHlwZSBmb3IgQXJyYXlTY2hlbWEgYW5kIE1hcFNjaGVtYVxuICAgICAgICAgICAgaWYgKHByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJldmlvdXNSZWZJZCA9ICRyb290LnJlZklkcy5nZXQocHJldmlvdXNWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzUmVmSWQgIT09IHVuZGVmaW5lZCAmJiByZWZJZCAhPT0gcHJldmlvdXNSZWZJZCkge1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBlbnF1ZXVlIG9uUmVtb3ZlIGlmIHN0cnVjdHVyZSBoYXMgYmVlbiByZXBsYWNlZC5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW50cmllcyA9IHByZXZpb3VzVmFsdWUuZW50cmllcygpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXRlcjtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChpdGVyID0gZW50cmllcy5uZXh0KCkpICYmICFpdGVyLmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IGl0ZXIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB2YWx1ZSBpcyBhIHNjaGVtYSwgcmVtb3ZlIGl0cyByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzUmVmSWQgPSAkcm9vdC5yZWZJZHMuZ2V0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdC5yZW1vdmVSZWYocHJldmlvdXNSZWZJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxDaGFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZjogcHJldmlvdXNWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZJZDogcHJldmlvdXNSZWZJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcDogZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1ZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHJvb3QuYWRkUmVmKHJlZklkLCB2YWx1ZSwgKHZhbHVlUmVmICE9PSBwcmV2aW91c1ZhbHVlIHx8XG4gICAgICAgICAgICAgICAgKG9wZXJhdGlvbiA9PT0gZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFX0FORF9BREQgJiYgdmFsdWVSZWYgPT09IHByZXZpb3VzVmFsdWUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsdWUsIHByZXZpb3VzVmFsdWUgfTtcbiAgICB9XG4gICAgY29uc3QgZGVjb2RlU2NoZW1hT3BlcmF0aW9uID0gZnVuY3Rpb24gKGRlY29kZXIsIGJ5dGVzLCBpdCwgcmVmLCBhbGxDaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0X2J5dGUgPSBieXRlc1tpdC5vZmZzZXQrK107XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gcmVmLmNvbnN0cnVjdG9yW1N5bWJvbC5tZXRhZGF0YV07XG4gICAgICAgIC8vIFwiY29tcHJlc3NlZFwiIGluZGV4ICsgb3BlcmF0aW9uXG4gICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IChmaXJzdF9ieXRlID4+IDYpIDw8IDY7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZmlyc3RfYnl0ZSAlIChvcGVyYXRpb24gfHwgMjU1KTtcbiAgICAgICAgLy8gc2tpcCBlYXJseSBpZiBmaWVsZCBpcyBub3QgZGVmaW5lZFxuICAgICAgICBjb25zdCBmaWVsZCA9IG1ldGFkYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGZpZWxkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkBjb2x5c2V1cy9zY2hlbWE6IGZpZWxkIG5vdCBkZWZpbmVkIGF0XCIsIHsgaW5kZXgsIHJlZjogcmVmLmNvbnN0cnVjdG9yLm5hbWUsIG1ldGFkYXRhIH0pO1xuICAgICAgICAgICAgcmV0dXJuIERFRklOSVRJT05fTUlTTUFUQ0g7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgcHJldmlvdXNWYWx1ZSB9ID0gZGVjb2RlVmFsdWUoZGVjb2Rlciwgb3BlcmF0aW9uLCByZWYsIGluZGV4LCBmaWVsZC50eXBlLCBieXRlcywgaXQsIGFsbENoYW5nZXMpO1xuICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVmW2ZpZWxkLm5hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIGNoYW5nZVxuICAgICAgICBpZiAocHJldmlvdXNWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGFsbENoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgcmVmLFxuICAgICAgICAgICAgICAgIHJlZklkOiBkZWNvZGVyLmN1cnJlbnRSZWZJZCxcbiAgICAgICAgICAgICAgICBvcDogb3BlcmF0aW9uLFxuICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZC5uYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZGVjb2RlS2V5VmFsdWVPcGVyYXRpb24gPSBmdW5jdGlvbiAoZGVjb2RlciwgYnl0ZXMsIGl0LCByZWYsIGFsbENoYW5nZXMpIHtcbiAgICAgICAgLy8gXCJ1bmNvbXByZXNzZWRcIiBpbmRleCArIG9wZXJhdGlvbiAoYXJyYXkvbWFwIGl0ZW1zKVxuICAgICAgICBjb25zdCBvcGVyYXRpb24gPSBieXRlc1tpdC5vZmZzZXQrK107XG4gICAgICAgIGlmIChvcGVyYXRpb24gPT09IGV4cG9ydHMuT1BFUkFUSU9OLkNMRUFSKSB7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gV2hlbiBkZWNvZGluZzpcbiAgICAgICAgICAgIC8vIC0gZW5xdWV1ZSBpdGVtcyBmb3IgREVMRVRFIGNhbGxiYWNrLlxuICAgICAgICAgICAgLy8gLSBmbGFnIGNoaWxkIGl0ZW1zIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24uXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgZGVjb2Rlci5yZW1vdmVDaGlsZFJlZnMocmVmLCBhbGxDaGFuZ2VzKTtcbiAgICAgICAgICAgIHJlZi5jbGVhcigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZGVjb2RlLm51bWJlcihieXRlcywgaXQpO1xuICAgICAgICBjb25zdCB0eXBlID0gcmVmWyRjaGlsZFR5cGVdO1xuICAgICAgICBsZXQgZHluYW1pY0luZGV4O1xuICAgICAgICBpZiAoKG9wZXJhdGlvbiAmIGV4cG9ydHMuT1BFUkFUSU9OLkFERCkgPT09IGV4cG9ydHMuT1BFUkFUSU9OLkFERCkgeyAvLyBBREQgb3IgREVMRVRFX0FORF9BRERcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHJlZlsnc2V0J10pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBkeW5hbWljSW5kZXggPSBkZWNvZGUuc3RyaW5nKGJ5dGVzLCBpdCk7IC8vIE1hcFNjaGVtYVxuICAgICAgICAgICAgICAgIHJlZlsnc2V0SW5kZXgnXShpbmRleCwgZHluYW1pY0luZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGR5bmFtaWNJbmRleCA9IGluZGV4OyAvLyBBcnJheVNjaGVtYVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZ2V0IGR5bmFtaWMgaW5kZXggZnJvbSBcInJlZlwiXG4gICAgICAgICAgICBkeW5hbWljSW5kZXggPSByZWZbJ2dldEluZGV4J10oaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIHByZXZpb3VzVmFsdWUgfSA9IGRlY29kZVZhbHVlKGRlY29kZXIsIG9wZXJhdGlvbiwgcmVmLCBpbmRleCwgdHlwZSwgYnl0ZXMsIGl0LCBhbGxDaGFuZ2VzKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHJlZlsnc2V0J10pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBNYXBTY2hlbWFcbiAgICAgICAgICAgICAgICByZWZbJyRpdGVtcyddLnNldChkeW5hbWljSW5kZXgsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiAocmVmWyckc2V0QXQnXSkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIC8vIEFycmF5U2NoZW1hXG4gICAgICAgICAgICAgICAgcmVmWyckc2V0QXQnXShpbmRleCwgdmFsdWUsIG9wZXJhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgKHJlZlsnYWRkJ10pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBDb2xsZWN0aW9uU2NoZW1hICYmIFNldFNjaGVtYVxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcmVmLmFkZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoaW5kZXgpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZlsnc2V0SW5kZXgnXShpbmRleCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgY2hhbmdlXG4gICAgICAgIGlmIChwcmV2aW91c1ZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgYWxsQ2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICByZWYsXG4gICAgICAgICAgICAgICAgcmVmSWQ6IGRlY29kZXIuY3VycmVudFJlZklkLFxuICAgICAgICAgICAgICAgIG9wOiBvcGVyYXRpb24sXG4gICAgICAgICAgICAgICAgZmllbGQ6IFwiXCIsIC8vIEZJWE1FOiByZW1vdmUgdGhpc1xuICAgICAgICAgICAgICAgIGR5bmFtaWNJbmRleCxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBwcmV2aW91c1ZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGRlY29kZUFycmF5ID0gZnVuY3Rpb24gKGRlY29kZXIsIGJ5dGVzLCBpdCwgcmVmLCBhbGxDaGFuZ2VzKSB7XG4gICAgICAgIC8vIFwidW5jb21wcmVzc2VkXCIgaW5kZXggKyBvcGVyYXRpb24gKGFycmF5L21hcCBpdGVtcylcbiAgICAgICAgbGV0IG9wZXJhdGlvbiA9IGJ5dGVzW2l0Lm9mZnNldCsrXTtcbiAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICBpZiAob3BlcmF0aW9uID09PSBleHBvcnRzLk9QRVJBVElPTi5DTEVBUikge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFdoZW4gZGVjb2Rpbmc6XG4gICAgICAgICAgICAvLyAtIGVucXVldWUgaXRlbXMgZm9yIERFTEVURSBjYWxsYmFjay5cbiAgICAgICAgICAgIC8vIC0gZmxhZyBjaGlsZCBpdGVtcyBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGRlY29kZXIucmVtb3ZlQ2hpbGRSZWZzKHJlZiwgYWxsQ2hhbmdlcyk7XG4gICAgICAgICAgICByZWYuY2xlYXIoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24gPT09IGV4cG9ydHMuT1BFUkFUSU9OLlJFVkVSU0UpIHtcbiAgICAgICAgICAgIHJlZi5yZXZlcnNlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uID09PSBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEVfQllfUkVGSUQpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlZmFjdG9yIGhlcmUsIHRyeSB0byBmb2xsb3cgc2FtZSBmbG93IGFzIGJlbG93XG4gICAgICAgICAgICBjb25zdCByZWZJZCA9IGRlY29kZS5udW1iZXIoYnl0ZXMsIGl0KTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSBkZWNvZGVyLnJvb3QucmVmcy5nZXQocmVmSWQpO1xuICAgICAgICAgICAgaW5kZXggPSByZWYuZmluZEluZGV4KCh2YWx1ZSkgPT4gdmFsdWUgPT09IHByZXZpb3VzVmFsdWUpO1xuICAgICAgICAgICAgcmVmWyRkZWxldGVCeUluZGV4XShpbmRleCk7XG4gICAgICAgICAgICBhbGxDaGFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIHJlZixcbiAgICAgICAgICAgICAgICByZWZJZDogZGVjb2Rlci5jdXJyZW50UmVmSWQsXG4gICAgICAgICAgICAgICAgb3A6IGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURSxcbiAgICAgICAgICAgICAgICBmaWVsZDogXCJcIiwgLy8gRklYTUU6IHJlbW92ZSB0aGlzXG4gICAgICAgICAgICAgICAgZHluYW1pY0luZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24gPT09IGV4cG9ydHMuT1BFUkFUSU9OLkFERF9CWV9SRUZJRCkge1xuICAgICAgICAgICAgY29uc3QgcmVmSWQgPSBkZWNvZGUubnVtYmVyKGJ5dGVzLCBpdCk7XG4gICAgICAgICAgICBjb25zdCBpdGVtQnlSZWZJZCA9IGRlY29kZXIucm9vdC5yZWZzLmdldChyZWZJZCk7XG4gICAgICAgICAgICAvLyBpZiBpdGVtIGFscmVhZHkgZXhpc3RzLCB1c2UgZXhpc3RpbmcgaW5kZXhcbiAgICAgICAgICAgIGlmIChpdGVtQnlSZWZJZCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gcmVmLmZpbmRJbmRleCgodmFsdWUpID0+IHZhbHVlID09PSBpdGVtQnlSZWZJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmYWxsYmFjayB0byB1c2UgbGFzdCBpbmRleFxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSB8fCBpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSByZWYubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5kZXggPSBkZWNvZGUubnVtYmVyKGJ5dGVzLCBpdCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZSA9IHJlZlskY2hpbGRUeXBlXTtcbiAgICAgICAgbGV0IGR5bmFtaWNJbmRleCA9IGluZGV4O1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBwcmV2aW91c1ZhbHVlIH0gPSBkZWNvZGVWYWx1ZShkZWNvZGVyLCBvcGVyYXRpb24sIHJlZiwgaW5kZXgsIHR5cGUsIGJ5dGVzLCBpdCwgYWxsQ2hhbmdlcyk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB2YWx1ZSAhPT0gcHJldmlvdXNWYWx1ZSAvLyBhdm9pZCBzZXR0aW5nIHNhbWUgdmFsdWUgdHdpY2UgKGlmIGluZGV4ID09PSAwIGl0IHdpbGwgcmVzdWx0IGluIGEgXCJ1bnNoaWZ0XCIgZm9yIEFycmF5U2NoZW1hKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIEFycmF5U2NoZW1hXG4gICAgICAgICAgICByZWZbJyRzZXRBdCddKGluZGV4LCB2YWx1ZSwgb3BlcmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgY2hhbmdlXG4gICAgICAgIGlmIChwcmV2aW91c1ZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgYWxsQ2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICByZWYsXG4gICAgICAgICAgICAgICAgcmVmSWQ6IGRlY29kZXIuY3VycmVudFJlZklkLFxuICAgICAgICAgICAgICAgIG9wOiBvcGVyYXRpb24sXG4gICAgICAgICAgICAgICAgZmllbGQ6IFwiXCIsIC8vIEZJWE1FOiByZW1vdmUgdGhpc1xuICAgICAgICAgICAgICAgIGR5bmFtaWNJbmRleCxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBwcmV2aW91c1ZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY2xhc3MgRW5jb2RlU2NoZW1hRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydFR5cGUodmFsdWUsIHR5cGUsIGtsYXNzLCBmaWVsZCkge1xuICAgICAgICBsZXQgdHlwZW9mVGFyZ2V0O1xuICAgICAgICBsZXQgYWxsb3dOdWxsID0gZmFsc2U7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgY2FzZSBcImludDhcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ1aW50OFwiOlxuICAgICAgICAgICAgY2FzZSBcImludDE2XCI6XG4gICAgICAgICAgICBjYXNlIFwidWludDE2XCI6XG4gICAgICAgICAgICBjYXNlIFwiaW50MzJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ1aW50MzJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJpbnQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcInVpbnQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcImZsb2F0MzJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmbG9hdDY0XCI6XG4gICAgICAgICAgICAgICAgdHlwZW9mVGFyZ2V0ID0gXCJudW1iZXJcIjtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGB0cnlpbmcgdG8gZW5jb2RlIFwiTmFOXCIgaW4gJHtrbGFzcy5jb25zdHJ1Y3Rvci5uYW1lfSMke2ZpZWxkfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJiaWdpbnQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcImJpZ3VpbnQ2NFwiOlxuICAgICAgICAgICAgICAgIHR5cGVvZlRhcmdldCA9IFwiYmlnaW50XCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgdHlwZW9mVGFyZ2V0ID0gXCJzdHJpbmdcIjtcbiAgICAgICAgICAgICAgICBhbGxvd051bGwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICAvLyBib29sZWFuIGlzIGFsd2F5cyBlbmNvZGVkIGFzIHRydWUvZmFsc2UgYmFzZWQgb24gdHJ1dGhpbmVzc1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gc2tpcCBhc3NlcnRpb24gZm9yIGN1c3RvbSB0eXBlc1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGFsbG93IGN1c3RvbSB0eXBlcyB0byBkZWZpbmUgdGhlaXIgb3duIGFzc2VydGlvbnNcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSB0eXBlb2ZUYXJnZXQgJiYgKCFhbGxvd051bGwgfHwgKGFsbG93TnVsbCAmJiB2YWx1ZSAhPT0gbnVsbCkpKSB7XG4gICAgICAgICAgICBsZXQgZm91bmRWYWx1ZSA9IGAnJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9JyR7KHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yICYmIGAgKCR7dmFsdWUuY29uc3RydWN0b3IubmFtZX0pYCkgfHwgJyd9YDtcbiAgICAgICAgICAgIHRocm93IG5ldyBFbmNvZGVTY2hlbWFFcnJvcihgYSAnJHt0eXBlb2ZUYXJnZXR9JyB3YXMgZXhwZWN0ZWQsIGJ1dCAke2ZvdW5kVmFsdWV9IHdhcyBwcm92aWRlZCBpbiAke2tsYXNzLmNvbnN0cnVjdG9yLm5hbWV9IyR7ZmllbGR9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzZXJ0SW5zdGFuY2VUeXBlKHZhbHVlLCB0eXBlLCBpbnN0YW5jZSwgZmllbGQpIHtcbiAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiB0eXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVuY29kZVNjaGVtYUVycm9yKGBhICcke3R5cGUubmFtZX0nIHdhcyBleHBlY3RlZCwgYnV0ICcke3ZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWV9JyB3YXMgcHJvdmlkZWQgaW4gJHtpbnN0YW5jZS5jb25zdHJ1Y3Rvci5uYW1lfSMke2ZpZWxkfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIF9hJDQsIF9iJDQ7XG4gICAgY29uc3QgREVGQVVMVF9TT1JUID0gKGEsIGIpID0+IHtcbiAgICAgICAgY29uc3QgQSA9IGEudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgQiA9IGIudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKEEgPCBCKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBlbHNlIGlmIChBID4gQilcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIGNsYXNzIEFycmF5U2NoZW1hIHtcbiAgICAgICAgc3RhdGljIHsgdGhpc1tfYSQ0XSA9IGVuY29kZUFycmF5OyB9XG4gICAgICAgIHN0YXRpYyB7IHRoaXNbX2IkNF0gPSBkZWNvZGVBcnJheTsgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lIGlmIGEgcHJvcGVydHkgbXVzdCBiZSBmaWx0ZXJlZC5cbiAgICAgICAgICogLSBJZiByZXR1cm5zIGZhbHNlLCB0aGUgcHJvcGVydHkgaXMgTk9UIGdvaW5nIHRvIGJlIGVuY29kZWQuXG4gICAgICAgICAqIC0gSWYgcmV0dXJucyB0cnVlLCB0aGUgcHJvcGVydHkgaXMgZ29pbmcgdG8gYmUgZW5jb2RlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogRW5jb2Rpbmcgd2l0aCBcImZpbHRlcnNcIiBoYXBwZW5zIGluIHR3byBzdGVwczpcbiAgICAgICAgICogLSBGaXJzdCwgdGhlIGVuY29kZXIgaXRlcmF0ZXMgb3ZlciBhbGwgXCJub3Qgb3duZWRcIiBwcm9wZXJ0aWVzIGFuZCBlbmNvZGVzIHRoZW0uXG4gICAgICAgICAqIC0gVGhlbiwgdGhlIGVuY29kZXIgaXRlcmF0ZXMgb3ZlciBhbGwgXCJvd25lZFwiIHByb3BlcnRpZXMgcGVyIGluc3RhbmNlIGFuZCBlbmNvZGVzIHRoZW0uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgWyhfYSQ0ID0gJGVuY29kZXIsIF9iJDQgPSAkZGVjb2RlciwgJGZpbHRlcildKHJlZiwgaW5kZXgsIHZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiAoIXZpZXcgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgKHJlZlskY2hpbGRUeXBlXSkgPT09IFwic3RyaW5nXCIgfHxcbiAgICAgICAgICAgICAgICB2aWV3LmlzQ2hhbmdlVHJlZVZpc2libGUocmVmWyd0bXBJdGVtcyddW2luZGV4XT8uWyRjaGFuZ2VzXSkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBpcyh0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgLy8gdHlwZSBmb3JtYXQ6IFtcInN0cmluZ1wiXVxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh0eXBlKSB8fFxuICAgICAgICAgICAgICAgIC8vIHR5cGUgZm9ybWF0OiB7IGFycmF5OiBcInN0cmluZ1wiIH1cbiAgICAgICAgICAgICAgICAodHlwZVsnYXJyYXknXSAhPT0gdW5kZWZpbmVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZyb20oaXRlcmFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlTY2hlbWEoLi4uQXJyYXkuZnJvbShpdGVyYWJsZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0cnVjdG9yKC4uLml0ZW1zKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zID0gW107XG4gICAgICAgICAgICB0aGlzLnRtcEl0ZW1zID0gW107XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZWRJbmRleGVzID0ge307XG4gICAgICAgICAgICB0aGlzLmlzTW92aW5nSXRlbXMgPSBmYWxzZTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAkY2hpbGRUeXBlLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KHRoaXMsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IChvYmosIHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocHJvcCkgIT09IFwic3ltYm9sXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBkOCBhY2N1c2VzIHRoaXMgYXMgbG93IHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAhaXNOYU4ocHJvcCkgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE3NTc4Ny84OTI2OThcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtc1twcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldChvYmosIHByb3ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IChvYmosIGtleSwgc2V0VmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoa2V5KSAhPT0gXCJzeW1ib2xcIiAmJiAhaXNOYU4oa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldFZhbHVlID09PSB1bmRlZmluZWQgfHwgc2V0VmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouJGRlbGV0ZUF0KGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0VmFsdWVbJGNoYW5nZXNdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydEluc3RhbmNlVHlwZShzZXRWYWx1ZSwgb2JqWyRjaGlsZFR5cGVdLCBvYmosIGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSBvYmouaXRlbXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvYmouaXNNb3ZpbmdJdGVtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLiRjaGFuZ2VBdChOdW1iZXIoa2V5KSwgc2V0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXRWYWx1ZVskY2hhbmdlc10uaXNOZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqWyRjaGFuZ2VzXS5pbmRleGVkT3BlcmF0aW9uKE51bWJlcihrZXkpLCBleHBvcnRzLk9QRVJBVElPTi5NT1ZFX0FORF9BREQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChvYmpbJGNoYW5nZXNdLmdldENoYW5nZShOdW1iZXIoa2V5KSkgJiBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEUpID09PSBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialskY2hhbmdlc10uaW5kZXhlZE9wZXJhdGlvbihOdW1iZXIoa2V5KSwgZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFX0FORF9NT1ZFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialskY2hhbmdlc10uaW5kZXhlZE9wZXJhdGlvbihOdW1iZXIoa2V5KSwgZXhwb3J0cy5PUEVSQVRJT04uTU9WRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzZXRWYWx1ZVskY2hhbmdlc10uaXNOZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpbJGNoYW5nZXNdLmluZGV4ZWRPcGVyYXRpb24oTnVtYmVyKGtleSksIGV4cG9ydHMuT1BFUkFUSU9OLkFERCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZVskY2hhbmdlc10uc2V0UGFyZW50KHRoaXMsIG9ialskY2hhbmdlc10ucm9vdCwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgcm9vdCByZWZlcmVuY2UgZnJvbSBwcmV2aW91cyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNWYWx1ZVskY2hhbmdlc10ucm9vdD8ucmVtb3ZlKHByZXZpb3VzVmFsdWVbJGNoYW5nZXNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLiRjaGFuZ2VBdChOdW1iZXIoa2V5KSwgc2V0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouaXRlbXNba2V5XSA9IHNldFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai50bXBJdGVtc1trZXldID0gc2V0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LnNldChvYmosIGtleSwgc2V0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkZWxldGVQcm9wZXJ0eTogKG9iaiwgcHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwcm9wKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLiRkZWxldGVBdChwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoYXM6IChvYmosIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChrZXkpICE9PSBcInN5bWJvbFwiICYmICFpc05hTihOdW1iZXIoa2V5KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyh0aGlzLml0ZW1zLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmhhcyhvYmosIGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzWyRjaGFuZ2VzXSA9IG5ldyBDaGFuZ2VUcmVlKHByb3h5KTtcbiAgICAgICAgICAgIHRoaXNbJGNoYW5nZXNdLmluZGV4ZXMgPSB7fTtcbiAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoKC4uLml0ZW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm94eTtcbiAgICAgICAgfVxuICAgICAgICBzZXQgbGVuZ3RoKG5ld0xlbmd0aCkge1xuICAgICAgICAgICAgaWYgKG5ld0xlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5ld0xlbmd0aCA8IHRoaXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGxpY2UobmV3TGVuZ3RoLCB0aGlzLmxlbmd0aCAtIG5ld0xlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJBcnJheVNjaGVtYTogY2FuJ3Qgc2V0IC5sZW5ndGggdG8gYSBoaWdoZXIgdmFsdWUgdGhhbiBpdHMgbGVuZ3RoLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHB1c2goLi4udmFsdWVzKSB7XG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gdGhpcy50bXBJdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VUcmVlID0gdGhpc1skY2hhbmdlc107XG4gICAgICAgICAgICAvLyB2YWx1ZXMuZm9yRWFjaCgodmFsdWUsIGkpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdmFsdWVzLmxlbmd0aDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKywgbGVuZ3RoKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBza2lwIG51bGwgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIgJiYgdGhpc1skY2hpbGRUeXBlXSkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnRJbnN0YW5jZVR5cGUodmFsdWUsIHRoaXNbJGNoaWxkVHlwZV0sIHRoaXMsIGkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBtb3ZlIHZhbHVlWyRjaGFuZ2VzXT8uc2V0UGFyZW50KCkgdG8gdGhpcyBibG9jay5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hhbmdlVHJlZS5pbmRleGVkT3BlcmF0aW9uKGxlbmd0aCwgZXhwb3J0cy5PUEVSQVRJT04uQURELCB0aGlzLml0ZW1zLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRtcEl0ZW1zLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gc2V0IHZhbHVlJ3MgcGFyZW50IGFmdGVyIHRoZSB2YWx1ZSBpcyBzZXRcbiAgICAgICAgICAgICAgICAvLyAodG8gYXZvaWQgZW5jb2RpbmcgXCJyZWZJZFwiIG9wZXJhdGlvbnMgYmVmb3JlIHBhcmVudCdzIFwiQUREXCIgb3BlcmF0aW9uKVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgdmFsdWVbJGNoYW5nZXNdPy5zZXRQYXJlbnQodGhpcywgY2hhbmdlVHJlZS5yb290LCBsZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gICAgIGxlbmd0aCsrO1xuICAgICAgICAgICAgLy8gfSk7XG4gICAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIHRoZSBsYXN0IGVsZW1lbnQgZnJvbSBhbiBhcnJheSBhbmQgcmV0dXJucyBpdC5cbiAgICAgICAgICovXG4gICAgICAgIHBvcCgpIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IC0xO1xuICAgICAgICAgICAgLy8gZmluZCBsYXN0IG5vbi11bmRlZmluZWQgaW5kZXhcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnRtcEl0ZW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgKHRoaXMudG1wSXRlbXNbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlbGV0ZWRJbmRleGVzW2ldICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzWyRjaGFuZ2VzXS5kZWxldGUoaW5kZXgsIHVuZGVmaW5lZCwgdGhpcy5pdGVtcy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlZEluZGV4ZXNbaW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGF0KGluZGV4KSB7XG4gICAgICAgICAgICAvLyBBbGxvdyBuZWdhdGl2ZSBpbmRleGluZyBmcm9tIHRoZSBlbmRcbiAgICAgICAgICAgIGlmIChpbmRleCA8IDApXG4gICAgICAgICAgICAgICAgaW5kZXggKz0gdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtc1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gZW5jb2Rpbmcgb25seVxuICAgICAgICAkY2hhbmdlQXQoaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJBcnJheVNjaGVtYSBpdGVtcyBjYW5ub3QgYmUgbnVsbCBub3IgdW5kZWZpbmVkOyBVc2UgYGRlbGV0ZUF0KGluZGV4KWAgaW5zdGVhZC5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2tpcCBpZiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUgYXMgY2FjaGVkLlxuICAgICAgICAgICAgaWYgKHRoaXMuaXRlbXNbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9ICh0aGlzLml0ZW1zW2luZGV4XSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgID8gdHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCJcbiAgICAgICAgICAgICAgICAgICAgPyBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEVfQU5EX0FERCAvLyBzY2hlbWEgY2hpbGRcbiAgICAgICAgICAgICAgICAgICAgOiBleHBvcnRzLk9QRVJBVElPTi5SRVBMQUNFIC8vIHByaW1pdGl2ZVxuICAgICAgICAgICAgICAgIDogZXhwb3J0cy5PUEVSQVRJT04uQUREO1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlVHJlZSA9IHRoaXNbJGNoYW5nZXNdO1xuICAgICAgICAgICAgY2hhbmdlVHJlZS5jaGFuZ2UoaW5kZXgsIG9wZXJhdGlvbik7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gc2V0IHZhbHVlJ3MgcGFyZW50IGFmdGVyIHRoZSB2YWx1ZSBpcyBzZXRcbiAgICAgICAgICAgIC8vICh0byBhdm9pZCBlbmNvZGluZyBcInJlZklkXCIgb3BlcmF0aW9ucyBiZWZvcmUgcGFyZW50J3MgXCJBRERcIiBvcGVyYXRpb24pXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgdmFsdWVbJGNoYW5nZXNdPy5zZXRQYXJlbnQodGhpcywgY2hhbmdlVHJlZS5yb290LCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZW5jb2Rpbmcgb25seVxuICAgICAgICAkZGVsZXRlQXQoaW5kZXgsIG9wZXJhdGlvbikge1xuICAgICAgICAgICAgdGhpc1skY2hhbmdlc10uZGVsZXRlKGluZGV4LCBvcGVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRlY29kaW5nIG9ubHlcbiAgICAgICAgJHNldEF0KGluZGV4LCB2YWx1ZSwgb3BlcmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IDAgJiZcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24gPT09IGV4cG9ydHMuT1BFUkFUSU9OLkFERCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXNbaW5kZXhdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgZGVjb2RpbmcgdW5zaGlmdFxuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXMudW5zaGlmdCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24gPT09IGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURV9BTkRfTU9WRSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW1zW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjbGVhcigpIHtcbiAgICAgICAgICAgIC8vIHNraXAgaWYgYWxyZWFkeSBjbGVhclxuICAgICAgICAgICAgaWYgKHRoaXMuaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGlzY2FyZCBwcmV2aW91cyBvcGVyYXRpb25zLlxuICAgICAgICAgICAgY29uc3QgY2hhbmdlVHJlZSA9IHRoaXNbJGNoYW5nZXNdO1xuICAgICAgICAgICAgLy8gZGlzY2FyZCBjaGlsZHJlblxuICAgICAgICAgICAgY2hhbmdlVHJlZS5mb3JFYWNoQ2hpbGQoKGNoYW5nZVRyZWUsIF8pID0+IHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VUcmVlLmRpc2NhcmQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBhZGQgdGVzdHMgd2l0aCBpbnN0YW5jZSBzaGFyaW5nICsgLmNsZWFyKClcbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogdGhpcy5yb290PyBpcyByZXF1aXJlZCBiZWNhdXNlIGl0IGlzIGJlaW5nIGNhbGxlZCBhdCBkZWNvZGluZyB0aW1lLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogZG8gbm90IHVzZSBbJGNoYW5nZXNdIGF0IGRlY29kaW5nIHRpbWUuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBjb25zdCByb290ID0gY2hhbmdlVHJlZS5yb290O1xuICAgICAgICAgICAgICAgIGlmIChyb290ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdC5yZW1vdmVDaGFuZ2VGcm9tQ2hhbmdlU2V0KFwiY2hhbmdlc1wiLCBjaGFuZ2VUcmVlKTtcbiAgICAgICAgICAgICAgICAgICAgcm9vdC5yZW1vdmVDaGFuZ2VGcm9tQ2hhbmdlU2V0KFwiYWxsQ2hhbmdlc1wiLCBjaGFuZ2VUcmVlKTtcbiAgICAgICAgICAgICAgICAgICAgcm9vdC5yZW1vdmVDaGFuZ2VGcm9tQ2hhbmdlU2V0KFwiYWxsRmlsdGVyZWRDaGFuZ2VzXCIsIGNoYW5nZVRyZWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2hhbmdlVHJlZS5kaXNjYXJkKHRydWUpO1xuICAgICAgICAgICAgY2hhbmdlVHJlZS5vcGVyYXRpb24oZXhwb3J0cy5PUEVSQVRJT04uQ0xFQVIpO1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy50bXBJdGVtcy5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21iaW5lcyB0d28gb3IgbW9yZSBhcnJheXMuXG4gICAgICAgICAqIEBwYXJhbSBpdGVtcyBBZGRpdGlvbmFsIGl0ZW1zIHRvIGFkZCB0byB0aGUgZW5kIG9mIGFycmF5MS5cbiAgICAgICAgICovXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29uY2F0KC4uLml0ZW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5U2NoZW1hKC4uLnRoaXMuaXRlbXMuY29uY2F0KC4uLml0ZW1zKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYWxsIHRoZSBlbGVtZW50cyBvZiBhbiBhcnJheSBzZXBhcmF0ZWQgYnkgdGhlIHNwZWNpZmllZCBzZXBhcmF0b3Igc3RyaW5nLlxuICAgICAgICAgKiBAcGFyYW0gc2VwYXJhdG9yIEEgc3RyaW5nIHVzZWQgdG8gc2VwYXJhdGUgb25lIGVsZW1lbnQgb2YgYW4gYXJyYXkgZnJvbSB0aGUgbmV4dCBpbiB0aGUgcmVzdWx0aW5nIFN0cmluZy4gSWYgb21pdHRlZCwgdGhlIGFycmF5IGVsZW1lbnRzIGFyZSBzZXBhcmF0ZWQgd2l0aCBhIGNvbW1hLlxuICAgICAgICAgKi9cbiAgICAgICAgam9pbihzZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmpvaW4oc2VwYXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV2ZXJzZXMgdGhlIGVsZW1lbnRzIGluIGFuIEFycmF5LlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXZlcnNlKCkge1xuICAgICAgICAgICAgdGhpc1skY2hhbmdlc10ub3BlcmF0aW9uKGV4cG9ydHMuT1BFUkFUSU9OLlJFVkVSU0UpO1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5yZXZlcnNlKCk7XG4gICAgICAgICAgICB0aGlzLnRtcEl0ZW1zLnJldmVyc2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIHRoZSBmaXJzdCBlbGVtZW50IGZyb20gYW4gYXJyYXkgYW5kIHJldHVybnMgaXQuXG4gICAgICAgICAqL1xuICAgICAgICBzaGlmdCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLml0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb25zdCBpbmRleCA9IE51bWJlcihPYmplY3Qua2V5cyhjaGFuZ2VUcmVlLmluZGV4ZXMpWzBdKTtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZVRyZWUgPSB0aGlzWyRjaGFuZ2VzXTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy50bXBJdGVtcy5maW5kSW5kZXgoaXRlbSA9PiBpdGVtID09PSB0aGlzLml0ZW1zWzBdKTtcbiAgICAgICAgICAgIGNvbnN0IGFsbENoYW5nZXNJbmRleCA9IHRoaXMuaXRlbXMuZmluZEluZGV4KGl0ZW0gPT4gaXRlbSA9PT0gdGhpcy5pdGVtc1swXSk7XG4gICAgICAgICAgICBjaGFuZ2VUcmVlLmRlbGV0ZShpbmRleCwgZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFLCBhbGxDaGFuZ2VzSW5kZXgpO1xuICAgICAgICAgICAgY2hhbmdlVHJlZS5zaGlmdEFsbENoYW5nZUluZGV4ZXMoLTEsIGFsbENoYW5nZXNJbmRleCk7XG4gICAgICAgICAgICAvLyB0aGlzLmRlbGV0ZWRJbmRleGVzW2luZGV4XSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgc2VjdGlvbiBvZiBhbiBhcnJheS5cbiAgICAgICAgICogQHBhcmFtIHN0YXJ0IFRoZSBiZWdpbm5pbmcgb2YgdGhlIHNwZWNpZmllZCBwb3J0aW9uIG9mIHRoZSBhcnJheS5cbiAgICAgICAgICogQHBhcmFtIGVuZCBUaGUgZW5kIG9mIHRoZSBzcGVjaWZpZWQgcG9ydGlvbiBvZiB0aGUgYXJyYXkuIFRoaXMgaXMgZXhjbHVzaXZlIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBpbmRleCAnZW5kJy5cbiAgICAgICAgICovXG4gICAgICAgIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNsaWNlZCA9IG5ldyBBcnJheVNjaGVtYSgpO1xuICAgICAgICAgICAgc2xpY2VkLnB1c2goLi4udGhpcy5pdGVtcy5zbGljZShzdGFydCwgZW5kKSk7XG4gICAgICAgICAgICByZXR1cm4gc2xpY2VkO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTb3J0cyBhbiBhcnJheS5cbiAgICAgICAgICogQHBhcmFtIGNvbXBhcmVGbiBGdW5jdGlvbiB1c2VkIHRvIGRldGVybWluZSB0aGUgb3JkZXIgb2YgdGhlIGVsZW1lbnRzLiBJdCBpcyBleHBlY3RlZCB0byByZXR1cm5cbiAgICAgICAgICogYSBuZWdhdGl2ZSB2YWx1ZSBpZiBmaXJzdCBhcmd1bWVudCBpcyBsZXNzIHRoYW4gc2Vjb25kIGFyZ3VtZW50LCB6ZXJvIGlmIHRoZXkncmUgZXF1YWwgYW5kIGEgcG9zaXRpdmVcbiAgICAgICAgICogdmFsdWUgb3RoZXJ3aXNlLiBJZiBvbWl0dGVkLCB0aGUgZWxlbWVudHMgYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcsIEFTQ0lJIGNoYXJhY3RlciBvcmRlci5cbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogWzExLDIsMjIsMV0uc29ydCgoYSwgYikgPT4gYSAtIGIpXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgc29ydChjb21wYXJlRm4gPSBERUZBVUxUX1NPUlQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNNb3ZpbmdJdGVtcyA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VUcmVlID0gdGhpc1skY2hhbmdlc107XG4gICAgICAgICAgICBjb25zdCBzb3J0ZWRJdGVtcyA9IHRoaXMuaXRlbXMuc29ydChjb21wYXJlRm4pO1xuICAgICAgICAgICAgLy8gd291bGRuJ3QgT1BFUkFUSU9OLk1PVkUgbWFrZSBtb3JlIHNlbnNlIGhlcmU/XG4gICAgICAgICAgICBzb3J0ZWRJdGVtcy5mb3JFYWNoKChfLCBpKSA9PiBjaGFuZ2VUcmVlLmNoYW5nZShpLCBleHBvcnRzLk9QRVJBVElPTi5SRVBMQUNFKSk7XG4gICAgICAgICAgICB0aGlzLnRtcEl0ZW1zLnNvcnQoY29tcGFyZUZuKTtcbiAgICAgICAgICAgIHRoaXMuaXNNb3ZpbmdJdGVtcyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgZWxlbWVudHMgZnJvbSBhbiBhcnJheSBhbmQsIGlmIG5lY2Vzc2FyeSwgaW5zZXJ0cyBuZXcgZWxlbWVudHMgaW4gdGhlaXIgcGxhY2UsIHJldHVybmluZyB0aGUgZGVsZXRlZCBlbGVtZW50cy5cbiAgICAgICAgICogQHBhcmFtIHN0YXJ0IFRoZSB6ZXJvLWJhc2VkIGxvY2F0aW9uIGluIHRoZSBhcnJheSBmcm9tIHdoaWNoIHRvIHN0YXJ0IHJlbW92aW5nIGVsZW1lbnRzLlxuICAgICAgICAgKiBAcGFyYW0gZGVsZXRlQ291bnQgVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byByZW1vdmUuXG4gICAgICAgICAqIEBwYXJhbSBpbnNlcnRJdGVtcyBFbGVtZW50cyB0byBpbnNlcnQgaW50byB0aGUgYXJyYXkgaW4gcGxhY2Ugb2YgdGhlIGRlbGV0ZWQgZWxlbWVudHMuXG4gICAgICAgICAqL1xuICAgICAgICBzcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50LCAuLi5pbnNlcnRJdGVtcykge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlVHJlZSA9IHRoaXNbJGNoYW5nZXNdO1xuICAgICAgICAgICAgY29uc3QgaXRlbXNMZW5ndGggPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IHRtcEl0ZW1zTGVuZ3RoID0gdGhpcy50bXBJdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBpbnNlcnRDb3VudCA9IGluc2VydEl0ZW1zLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIGJ1aWxkIHVwLXRvLWRhdGUgbGlzdCBvZiBpbmRleGVzLCBleGNsdWRpbmcgcmVtb3ZlZCB2YWx1ZXMuXG4gICAgICAgICAgICBjb25zdCBpbmRleGVzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRtcEl0ZW1zTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWxldGVkSW5kZXhlc1tpXSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleGVzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW1zTGVuZ3RoID4gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBkZWxldGVDb3VudCBpcyBub3QgcHJvdmlkZWQsIGRlbGV0ZSBhbGwgaXRlbXMgZnJvbSBzdGFydCB0byBlbmRcbiAgICAgICAgICAgICAgICBpZiAoZGVsZXRlQ291bnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGVDb3VudCA9IGl0ZW1zTGVuZ3RoIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlIG9wZXJhdGlvbnMgYXQgY29ycmVjdCBpbmRleFxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBkZWxldGVDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gaW5kZXhlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlVHJlZS5kZWxldGUoaW5kZXgsIGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlZEluZGV4ZXNbaW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBub3QgZW5vdWdoIGl0ZW1zIHRvIGRlbGV0ZVxuICAgICAgICAgICAgICAgIGRlbGV0ZUNvdW50ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGluc2VydCBvcGVyYXRpb25zXG4gICAgICAgICAgICBpZiAoaW5zZXJ0Q291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluc2VydENvdW50ID4gZGVsZXRlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkluc2VydGluZyBtb3JlIGVsZW1lbnRzIHRoYW4gZGVsZXRpbmcgZHVyaW5nIEFycmF5U2NoZW1hI3NwbGljZSgpXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcnJheVNjaGVtYSNzcGxpY2UoKTogaW5zZXJ0Q291bnQgbXVzdCBiZSBlcXVhbCBvciBsb3dlciB0aGFuIGRlbGV0ZUNvdW50LlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnNlcnRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFkZEluZGV4ID0gKGluZGV4ZXNbc3RhcnRdID8/IGl0ZW1zTGVuZ3RoKSArIGk7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZVRyZWUuaW5kZXhlZE9wZXJhdGlvbihhZGRJbmRleCwgKHRoaXMuZGVsZXRlZEluZGV4ZXNbYWRkSW5kZXhdKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEVfQU5EX0FERFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBleHBvcnRzLk9QRVJBVElPTi5BREQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgdmFsdWUncyBwYXJlbnQvcm9vdFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRJdGVtc1tpXVskY2hhbmdlc10/LnNldFBhcmVudCh0aGlzLCBjaGFuZ2VUcmVlLnJvb3QsIGFkZEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gZGVsZXRlIGV4Y2VlZGluZyBpbmRleGVzIGZyb20gXCJhbGxDaGFuZ2VzXCJcbiAgICAgICAgICAgIC8vIChwcmV2ZW50IC5lbmNvZGVBbGwoKSBmcm9tIGVuY29kaW5nIG5vbi1leGlzdGluZyBpdGVtcylcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBpZiAoZGVsZXRlQ291bnQgPiBpbnNlcnRDb3VudCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZVRyZWUuc2hpZnRBbGxDaGFuZ2VJbmRleGVzKC0oZGVsZXRlQ291bnQgLSBpbnNlcnRDb3VudCksIGluZGV4ZXNbc3RhcnQgKyBpbnNlcnRDb3VudF0pO1xuICAgICAgICAgICAgICAgIC8vIGRlYnVnQ2hhbmdlU2V0KFwiQUZURVIgU0hJRlQgaW5kZXhlc1wiLCBjaGFuZ2VUcmVlLmFsbENoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEZJWE1FOiB0aGlzIGNvZGUgYmxvY2sgaXMgZHVwbGljYXRlZCBvbiBDaGFuZ2VUcmVlXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgaWYgKGNoYW5nZVRyZWUuZmlsdGVyZWRDaGFuZ2VzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBlbnF1ZXVlQ2hhbmdlVHJlZShjaGFuZ2VUcmVlLnJvb3QsIGNoYW5nZVRyZWUsICdmaWx0ZXJlZENoYW5nZXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVucXVldWVDaGFuZ2VUcmVlKGNoYW5nZVRyZWUucm9vdCwgY2hhbmdlVHJlZSwgJ2NoYW5nZXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zLnNwbGljZShzdGFydCwgZGVsZXRlQ291bnQsIC4uLmluc2VydEl0ZW1zKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zZXJ0cyBuZXcgZWxlbWVudHMgYXQgdGhlIHN0YXJ0IG9mIGFuIGFycmF5LlxuICAgICAgICAgKiBAcGFyYW0gaXRlbXMgIEVsZW1lbnRzIHRvIGluc2VydCBhdCB0aGUgc3RhcnQgb2YgdGhlIEFycmF5LlxuICAgICAgICAgKi9cbiAgICAgICAgdW5zaGlmdCguLi5pdGVtcykge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlVHJlZSA9IHRoaXNbJGNoYW5nZXNdO1xuICAgICAgICAgICAgLy8gc2hpZnQgaW5kZXhlc1xuICAgICAgICAgICAgY2hhbmdlVHJlZS5zaGlmdENoYW5nZUluZGV4ZXMoaXRlbXMubGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIG5ldyBpbmRleFxuICAgICAgICAgICAgaWYgKGNoYW5nZVRyZWUuaXNGaWx0ZXJlZCkge1xuICAgICAgICAgICAgICAgIHNldE9wZXJhdGlvbkF0SW5kZXgoY2hhbmdlVHJlZS5maWx0ZXJlZENoYW5nZXMsIHRoaXMuaXRlbXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBjaGFuZ2VUcmVlLmZpbHRlcmVkQ2hhbmdlc1t0aGlzLml0ZW1zLmxlbmd0aF0gPSBPUEVSQVRJT04uQUREO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0T3BlcmF0aW9uQXRJbmRleChjaGFuZ2VUcmVlLmFsbENoYW5nZXMsIHRoaXMuaXRlbXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBjaGFuZ2VUcmVlLmFsbENoYW5nZXNbdGhpcy5pdGVtcy5sZW5ndGhdID0gT1BFUkFUSU9OLkFERDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZJWE1FOiBzaG91bGQgd2UgdXNlIE9QRVJBVElPTi5NT1ZFIGhlcmUgaW5zdGVhZD9cbiAgICAgICAgICAgIGl0ZW1zLmZvckVhY2goKF8sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY2hhbmdlVHJlZS5jaGFuZ2UoaW5kZXgsIGV4cG9ydHMuT1BFUkFUSU9OLkFERCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudG1wSXRlbXMudW5zaGlmdCguLi5pdGVtcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy51bnNoaWZ0KC4uLml0ZW1zKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYSB2YWx1ZSBpbiBhbiBhcnJheS5cbiAgICAgICAgICogQHBhcmFtIHNlYXJjaEVsZW1lbnQgVGhlIHZhbHVlIHRvIGxvY2F0ZSBpbiB0aGUgYXJyYXkuXG4gICAgICAgICAqIEBwYXJhbSBmcm9tSW5kZXggVGhlIGFycmF5IGluZGV4IGF0IHdoaWNoIHRvIGJlZ2luIHRoZSBzZWFyY2guIElmIGZyb21JbmRleCBpcyBvbWl0dGVkLCB0aGUgc2VhcmNoIHN0YXJ0cyBhdCBpbmRleCAwLlxuICAgICAgICAgKi9cbiAgICAgICAgaW5kZXhPZihzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmluZGV4T2Yoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgb2NjdXJyZW5jZSBvZiBhIHNwZWNpZmllZCB2YWx1ZSBpbiBhbiBhcnJheS5cbiAgICAgICAgICogQHBhcmFtIHNlYXJjaEVsZW1lbnQgVGhlIHZhbHVlIHRvIGxvY2F0ZSBpbiB0aGUgYXJyYXkuXG4gICAgICAgICAqIEBwYXJhbSBmcm9tSW5kZXggVGhlIGFycmF5IGluZGV4IGF0IHdoaWNoIHRvIGJlZ2luIHRoZSBzZWFyY2guIElmIGZyb21JbmRleCBpcyBvbWl0dGVkLCB0aGUgc2VhcmNoIHN0YXJ0cyBhdCB0aGUgbGFzdCBpbmRleCBpbiB0aGUgYXJyYXkuXG4gICAgICAgICAqL1xuICAgICAgICBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXggPSB0aGlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZXZlcnkoY2FsbGJhY2tmbiwgdGhpc0FyZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuZXZlcnkoY2FsbGJhY2tmbiwgdGhpc0FyZyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSBmb3IgYW55IGVsZW1lbnQgb2YgYW4gYXJyYXkuXG4gICAgICAgICAqIEBwYXJhbSBjYWxsYmFja2ZuIEEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHVwIHRvIHRocmVlIGFyZ3VtZW50cy4gVGhlIHNvbWUgbWV0aG9kIGNhbGxzXG4gICAgICAgICAqIHRoZSBjYWxsYmFja2ZuIGZ1bmN0aW9uIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIGFycmF5IHVudGlsIHRoZSBjYWxsYmFja2ZuIHJldHVybnMgYSB2YWx1ZVxuICAgICAgICAgKiB3aGljaCBpcyBjb2VyY2libGUgdG8gdGhlIEJvb2xlYW4gdmFsdWUgdHJ1ZSwgb3IgdW50aWwgdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgICAgICAqIEBwYXJhbSB0aGlzQXJnIEFuIG9iamVjdCB0byB3aGljaCB0aGUgdGhpcyBrZXl3b3JkIGNhbiByZWZlciBpbiB0aGUgY2FsbGJhY2tmbiBmdW5jdGlvbi5cbiAgICAgICAgICogSWYgdGhpc0FyZyBpcyBvbWl0dGVkLCB1bmRlZmluZWQgaXMgdXNlZCBhcyB0aGUgdGhpcyB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHNvbWUoY2FsbGJhY2tmbiwgdGhpc0FyZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuc29tZShjYWxsYmFja2ZuLCB0aGlzQXJnKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUGVyZm9ybXMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZm9yIGVhY2ggZWxlbWVudCBpbiBhbiBhcnJheS5cbiAgICAgICAgICogQHBhcmFtIGNhbGxiYWNrZm4gIEEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHVwIHRvIHRocmVlIGFyZ3VtZW50cy4gZm9yRWFjaCBjYWxscyB0aGUgY2FsbGJhY2tmbiBmdW5jdGlvbiBvbmUgdGltZSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheS5cbiAgICAgICAgICogQHBhcmFtIHRoaXNBcmcgIEFuIG9iamVjdCB0byB3aGljaCB0aGUgdGhpcyBrZXl3b3JkIGNhbiByZWZlciBpbiB0aGUgY2FsbGJhY2tmbiBmdW5jdGlvbi4gSWYgdGhpc0FyZyBpcyBvbWl0dGVkLCB1bmRlZmluZWQgaXMgdXNlZCBhcyB0aGUgdGhpcyB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIGZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbHMgYSBkZWZpbmVkIGNhbGxiYWNrIGZ1bmN0aW9uIG9uIGVhY2ggZWxlbWVudCBvZiBhbiBhcnJheSwgYW5kIHJldHVybnMgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIGNhbGxiYWNrZm4gQSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdXAgdG8gdGhyZWUgYXJndW1lbnRzLiBUaGUgbWFwIG1ldGhvZCBjYWxscyB0aGUgY2FsbGJhY2tmbiBmdW5jdGlvbiBvbmUgdGltZSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheS5cbiAgICAgICAgICogQHBhcmFtIHRoaXNBcmcgQW4gb2JqZWN0IHRvIHdoaWNoIHRoZSB0aGlzIGtleXdvcmQgY2FuIHJlZmVyIGluIHRoZSBjYWxsYmFja2ZuIGZ1bmN0aW9uLiBJZiB0aGlzQXJnIGlzIG9taXR0ZWQsIHVuZGVmaW5lZCBpcyB1c2VkIGFzIHRoZSB0aGlzIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgbWFwKGNhbGxiYWNrZm4sIHRoaXNBcmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zLm1hcChjYWxsYmFja2ZuLCB0aGlzQXJnKTtcbiAgICAgICAgfVxuICAgICAgICBmaWx0ZXIoY2FsbGJhY2tmbiwgdGhpc0FyZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuZmlsdGVyKGNhbGxiYWNrZm4sIHRoaXNBcmcpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxscyB0aGUgc3BlY2lmaWVkIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBhbGwgdGhlIGVsZW1lbnRzIGluIGFuIGFycmF5LiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0LCBhbmQgaXMgcHJvdmlkZWQgYXMgYW4gYXJndW1lbnQgaW4gdGhlIG5leHQgY2FsbCB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICAgICAqIEBwYXJhbSBjYWxsYmFja2ZuIEEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHVwIHRvIGZvdXIgYXJndW1lbnRzLiBUaGUgcmVkdWNlIG1ldGhvZCBjYWxscyB0aGUgY2FsbGJhY2tmbiBmdW5jdGlvbiBvbmUgdGltZSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheS5cbiAgICAgICAgICogQHBhcmFtIGluaXRpYWxWYWx1ZSBJZiBpbml0aWFsVmFsdWUgaXMgc3BlY2lmaWVkLCBpdCBpcyB1c2VkIGFzIHRoZSBpbml0aWFsIHZhbHVlIHRvIHN0YXJ0IHRoZSBhY2N1bXVsYXRpb24uIFRoZSBmaXJzdCBjYWxsIHRvIHRoZSBjYWxsYmFja2ZuIGZ1bmN0aW9uIHByb3ZpZGVzIHRoaXMgdmFsdWUgYXMgYW4gYXJndW1lbnQgaW5zdGVhZCBvZiBhbiBhcnJheSB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHJlZHVjZShjYWxsYmFja2ZuLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zLnJlZHVjZShjYWxsYmFja2ZuLCBpbml0aWFsVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxscyB0aGUgc3BlY2lmaWVkIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBhbGwgdGhlIGVsZW1lbnRzIGluIGFuIGFycmF5LCBpbiBkZXNjZW5kaW5nIG9yZGVyLiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0LCBhbmQgaXMgcHJvdmlkZWQgYXMgYW4gYXJndW1lbnQgaW4gdGhlIG5leHQgY2FsbCB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICAgICAqIEBwYXJhbSBjYWxsYmFja2ZuIEEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHVwIHRvIGZvdXIgYXJndW1lbnRzLiBUaGUgcmVkdWNlUmlnaHQgbWV0aG9kIGNhbGxzIHRoZSBjYWxsYmFja2ZuIGZ1bmN0aW9uIG9uZSB0aW1lIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIGFycmF5LlxuICAgICAgICAgKiBAcGFyYW0gaW5pdGlhbFZhbHVlIElmIGluaXRpYWxWYWx1ZSBpcyBzcGVjaWZpZWQsIGl0IGlzIHVzZWQgYXMgdGhlIGluaXRpYWwgdmFsdWUgdG8gc3RhcnQgdGhlIGFjY3VtdWxhdGlvbi4gVGhlIGZpcnN0IGNhbGwgdG8gdGhlIGNhbGxiYWNrZm4gZnVuY3Rpb24gcHJvdmlkZXMgdGhpcyB2YWx1ZSBhcyBhbiBhcmd1bWVudCBpbnN0ZWFkIG9mIGFuIGFycmF5IHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVkdWNlUmlnaHQoY2FsbGJhY2tmbiwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5yZWR1Y2VSaWdodChjYWxsYmFja2ZuLCBpbml0aWFsVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgYXJyYXkgd2hlcmUgcHJlZGljYXRlIGlzIHRydWUsIGFuZCB1bmRlZmluZWRcbiAgICAgICAgICogb3RoZXJ3aXNlLlxuICAgICAgICAgKiBAcGFyYW0gcHJlZGljYXRlIGZpbmQgY2FsbHMgcHJlZGljYXRlIG9uY2UgZm9yIGVhY2ggZWxlbWVudCBvZiB0aGUgYXJyYXksIGluIGFzY2VuZGluZ1xuICAgICAgICAgKiBvcmRlciwgdW50aWwgaXQgZmluZHMgb25lIHdoZXJlIHByZWRpY2F0ZSByZXR1cm5zIHRydWUuIElmIHN1Y2ggYW4gZWxlbWVudCBpcyBmb3VuZCwgZmluZFxuICAgICAgICAgKiBpbW1lZGlhdGVseSByZXR1cm5zIHRoYXQgZWxlbWVudCB2YWx1ZS4gT3RoZXJ3aXNlLCBmaW5kIHJldHVybnMgdW5kZWZpbmVkLlxuICAgICAgICAgKiBAcGFyYW0gdGhpc0FyZyBJZiBwcm92aWRlZCwgaXQgd2lsbCBiZSB1c2VkIGFzIHRoZSB0aGlzIHZhbHVlIGZvciBlYWNoIGludm9jYXRpb24gb2ZcbiAgICAgICAgICogcHJlZGljYXRlLiBJZiBpdCBpcyBub3QgcHJvdmlkZWQsIHVuZGVmaW5lZCBpcyB1c2VkIGluc3RlYWQuXG4gICAgICAgICAqL1xuICAgICAgICBmaW5kKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuZmluZChwcmVkaWNhdGUsIHRoaXNBcmcpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgYXJyYXkgd2hlcmUgcHJlZGljYXRlIGlzIHRydWUsIGFuZCAtMVxuICAgICAgICAgKiBvdGhlcndpc2UuXG4gICAgICAgICAqIEBwYXJhbSBwcmVkaWNhdGUgZmluZCBjYWxscyBwcmVkaWNhdGUgb25jZSBmb3IgZWFjaCBlbGVtZW50IG9mIHRoZSBhcnJheSwgaW4gYXNjZW5kaW5nXG4gICAgICAgICAqIG9yZGVyLCB1bnRpbCBpdCBmaW5kcyBvbmUgd2hlcmUgcHJlZGljYXRlIHJldHVybnMgdHJ1ZS4gSWYgc3VjaCBhbiBlbGVtZW50IGlzIGZvdW5kLFxuICAgICAgICAgKiBmaW5kSW5kZXggaW1tZWRpYXRlbHkgcmV0dXJucyB0aGF0IGVsZW1lbnQgaW5kZXguIE90aGVyd2lzZSwgZmluZEluZGV4IHJldHVybnMgLTEuXG4gICAgICAgICAqIEBwYXJhbSB0aGlzQXJnIElmIHByb3ZpZGVkLCBpdCB3aWxsIGJlIHVzZWQgYXMgdGhlIHRoaXMgdmFsdWUgZm9yIGVhY2ggaW52b2NhdGlvbiBvZlxuICAgICAgICAgKiBwcmVkaWNhdGUuIElmIGl0IGlzIG5vdCBwcm92aWRlZCwgdW5kZWZpbmVkIGlzIHVzZWQgaW5zdGVhZC5cbiAgICAgICAgICovXG4gICAgICAgIGZpbmRJbmRleChwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmZpbmRJbmRleChwcmVkaWNhdGUsIHRoaXNBcmcpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB0aGlzIG9iamVjdCBhZnRlciBmaWxsaW5nIHRoZSBzZWN0aW9uIGlkZW50aWZpZWQgYnkgc3RhcnQgYW5kIGVuZCB3aXRoIHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZSB2YWx1ZSB0byBmaWxsIGFycmF5IHNlY3Rpb24gd2l0aFxuICAgICAgICAgKiBAcGFyYW0gc3RhcnQgaW5kZXggdG8gc3RhcnQgZmlsbGluZyB0aGUgYXJyYXkgYXQuIElmIHN0YXJ0IGlzIG5lZ2F0aXZlLCBpdCBpcyB0cmVhdGVkIGFzXG4gICAgICAgICAqIGxlbmd0aCtzdGFydCB3aGVyZSBsZW5ndGggaXMgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gICAgICAgICAqIEBwYXJhbSBlbmQgaW5kZXggdG8gc3RvcCBmaWxsaW5nIHRoZSBhcnJheSBhdC4gSWYgZW5kIGlzIG5lZ2F0aXZlLCBpdCBpcyB0cmVhdGVkIGFzXG4gICAgICAgICAqIGxlbmd0aCtlbmQuXG4gICAgICAgICAqL1xuICAgICAgICBmaWxsKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFycmF5U2NoZW1hI2ZpbGwoKSBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHRoaXMgb2JqZWN0IGFmdGVyIGNvcHlpbmcgYSBzZWN0aW9uIG9mIHRoZSBhcnJheSBpZGVudGlmaWVkIGJ5IHN0YXJ0IGFuZCBlbmRcbiAgICAgICAgICogdG8gdGhlIHNhbWUgYXJyYXkgc3RhcnRpbmcgYXQgcG9zaXRpb24gdGFyZ2V0XG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgSWYgdGFyZ2V0IGlzIG5lZ2F0aXZlLCBpdCBpcyB0cmVhdGVkIGFzIGxlbmd0aCt0YXJnZXQgd2hlcmUgbGVuZ3RoIGlzIHRoZVxuICAgICAgICAgKiBsZW5ndGggb2YgdGhlIGFycmF5LlxuICAgICAgICAgKiBAcGFyYW0gc3RhcnQgSWYgc3RhcnQgaXMgbmVnYXRpdmUsIGl0IGlzIHRyZWF0ZWQgYXMgbGVuZ3RoK3N0YXJ0LiBJZiBlbmQgaXMgbmVnYXRpdmUsIGl0XG4gICAgICAgICAqIGlzIHRyZWF0ZWQgYXMgbGVuZ3RoK2VuZC5cbiAgICAgICAgICogQHBhcmFtIGVuZCBJZiBub3Qgc3BlY2lmaWVkLCBsZW5ndGggb2YgdGhlIHRoaXMgb2JqZWN0IGlzIHVzZWQgYXMgaXRzIGRlZmF1bHQgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICBjb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcnJheVNjaGVtYSNjb3B5V2l0aGluKCkgbm90IGltcGxlbWVudGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGFycmF5LlxuICAgICAgICAgKi9cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGFycmF5LiBUaGUgZWxlbWVudHMgYXJlIGNvbnZlcnRlZCB0byBzdHJpbmcgdXNpbmcgdGhlaXIgdG9Mb2NhbFN0cmluZyBtZXRob2RzLlxuICAgICAgICAgKi9cbiAgICAgICAgdG9Mb2NhbGVTdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy50b0xvY2FsZVN0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgLyoqIEl0ZXJhdG9yICovXG4gICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXNbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXQgW1N5bWJvbC5zcGVjaWVzXSgpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheVNjaGVtYTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhbiBpdGVyYWJsZSBvZiBrZXksIHZhbHVlIHBhaXJzIGZvciBldmVyeSBlbnRyeSBpbiB0aGUgYXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIGVudHJpZXMoKSB7IHJldHVybiB0aGlzLml0ZW1zLmVudHJpZXMoKTsgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhbiBpdGVyYWJsZSBvZiBrZXlzIGluIHRoZSBhcnJheVxuICAgICAgICAgKi9cbiAgICAgICAga2V5cygpIHsgcmV0dXJuIHRoaXMuaXRlbXMua2V5cygpOyB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGFuIGl0ZXJhYmxlIG9mIHZhbHVlcyBpbiB0aGUgYXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlcygpIHsgcmV0dXJuIHRoaXMuaXRlbXMudmFsdWVzKCk7IH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciBhbiBhcnJheSBpbmNsdWRlcyBhIGNlcnRhaW4gZWxlbWVudCwgcmV0dXJuaW5nIHRydWUgb3IgZmFsc2UgYXMgYXBwcm9wcmlhdGUuXG4gICAgICAgICAqIEBwYXJhbSBzZWFyY2hFbGVtZW50IFRoZSBlbGVtZW50IHRvIHNlYXJjaCBmb3IuXG4gICAgICAgICAqIEBwYXJhbSBmcm9tSW5kZXggVGhlIHBvc2l0aW9uIGluIHRoaXMgYXJyYXkgYXQgd2hpY2ggdG8gYmVnaW4gc2VhcmNoaW5nIGZvciBzZWFyY2hFbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgaW5jbHVkZXMoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5pbmNsdWRlcyhzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEVTMjAyMlxuICAgICAgICAvL1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbHMgYSBkZWZpbmVkIGNhbGxiYWNrIGZ1bmN0aW9uIG9uIGVhY2ggZWxlbWVudCBvZiBhbiBhcnJheS4gVGhlbiwgZmxhdHRlbnMgdGhlIHJlc3VsdCBpbnRvXG4gICAgICAgICAqIGEgbmV3IGFycmF5LlxuICAgICAgICAgKiBUaGlzIGlzIGlkZW50aWNhbCB0byBhIG1hcCBmb2xsb3dlZCBieSBmbGF0IHdpdGggZGVwdGggMS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNhbGxiYWNrIEEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHVwIHRvIHRocmVlIGFyZ3VtZW50cy4gVGhlIGZsYXRNYXAgbWV0aG9kIGNhbGxzIHRoZVxuICAgICAgICAgKiBjYWxsYmFjayBmdW5jdGlvbiBvbmUgdGltZSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheS5cbiAgICAgICAgICogQHBhcmFtIHRoaXNBcmcgQW4gb2JqZWN0IHRvIHdoaWNoIHRoZSB0aGlzIGtleXdvcmQgY2FuIHJlZmVyIGluIHRoZSBjYWxsYmFjayBmdW5jdGlvbi4gSWZcbiAgICAgICAgICogdGhpc0FyZyBpcyBvbWl0dGVkLCB1bmRlZmluZWQgaXMgdXNlZCBhcyB0aGUgdGhpcyB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgZmxhdE1hcChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlTY2hlbWEjZmxhdE1hcCgpIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IGFycmF5IHdpdGggYWxsIHN1Yi1hcnJheSBlbGVtZW50cyBjb25jYXRlbmF0ZWQgaW50byBpdCByZWN1cnNpdmVseSB1cCB0byB0aGVcbiAgICAgICAgICogc3BlY2lmaWVkIGRlcHRoLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoXG4gICAgICAgICAqL1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGZsYXQoZGVwdGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFycmF5U2NoZW1hI2ZsYXQoKSBpcyBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5kTGFzdCgpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmZpbmRMYXN0LmFwcGx5KHRoaXMuaXRlbXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgZmluZExhc3RJbmRleCguLi5hcmdzKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5maW5kTGFzdEluZGV4LmFwcGx5KHRoaXMuaXRlbXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRVMyMDIzXG4gICAgICAgIC8vXG4gICAgICAgIHdpdGgoaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBjb3B5ID0gdGhpcy5pdGVtcy5zbGljZSgpO1xuICAgICAgICAgICAgLy8gQWxsb3cgbmVnYXRpdmUgaW5kZXhpbmcgZnJvbSB0aGUgZW5kXG4gICAgICAgICAgICBpZiAoaW5kZXggPCAwKVxuICAgICAgICAgICAgICAgIGluZGV4ICs9IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgY29weVtpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlTY2hlbWEoLi4uY29weSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9SZXZlcnNlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRvU29ydGVkKGNvbXBhcmVGbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuc2xpY2UoKS5zb3J0KGNvbXBhcmVGbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0b1NwbGljZWQoc3RhcnQsIGRlbGV0ZUNvdW50LCAuLi5pdGVtcykge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMudG9TcGxpY2VkLmFwcGx5KGNvcHksIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgc2h1ZmZsZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vdmUoKF8pID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudEluZGV4ID0gdGhpcy5pdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRJbmRleCAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByYW5kb21JbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleC0tO1xuICAgICAgICAgICAgICAgICAgICBbdGhpc1tjdXJyZW50SW5kZXhdLCB0aGlzW3JhbmRvbUluZGV4XV0gPSBbdGhpc1tyYW5kb21JbmRleF0sIHRoaXNbY3VycmVudEluZGV4XV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbG93cyB0byBtb3ZlIGl0ZW1zIGFyb3VuZCBpbiB0aGUgYXJyYXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEV4YW1wbGU6XG4gICAgICAgICAqICAgICBzdGF0ZS5jYXJkcy5tb3ZlKChjYXJkcykgPT4ge1xuICAgICAgICAgKiAgICAgICAgIFtjYXJkc1s0XSwgY2FyZHNbM11dID0gW2NhcmRzWzNdLCBjYXJkc1s0XV07XG4gICAgICAgICAqICAgICAgICAgW2NhcmRzWzNdLCBjYXJkc1syXV0gPSBbY2FyZHNbMl0sIGNhcmRzWzNdXTtcbiAgICAgICAgICogICAgICAgICBbY2FyZHNbMl0sIGNhcmRzWzBdXSA9IFtjYXJkc1swXSwgY2FyZHNbMl1dO1xuICAgICAgICAgKiAgICAgICAgIFtjYXJkc1sxXSwgY2FyZHNbMV1dID0gW2NhcmRzWzFdLCBjYXJkc1sxXV07XG4gICAgICAgICAqICAgICAgICAgW2NhcmRzWzBdLCBjYXJkc1swXV0gPSBbY2FyZHNbMF0sIGNhcmRzWzBdXTtcbiAgICAgICAgICogICAgIH0pXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjYlxuICAgICAgICAgKiBAcmV0dXJuc1xuICAgICAgICAgKi9cbiAgICAgICAgbW92ZShjYikge1xuICAgICAgICAgICAgdGhpcy5pc01vdmluZ0l0ZW1zID0gdHJ1ZTtcbiAgICAgICAgICAgIGNiKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5pc01vdmluZ0l0ZW1zID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBbKCRnZXRCeUluZGV4KV0oaW5kZXgsIGlzRW5jb2RlQWxsID0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUT0RPOiBhdm9pZCB1bmVjZXNzYXJ5IGB0aGlzLnRtcEl0ZW1zYCBjaGVjayBkdXJpbmcgZGVjb2RpbmcuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICAgRU5DT0RJTkcgdXNlcyBgdGhpcy50bXBJdGVtc2AgKG9yIGB0aGlzLml0ZW1zYCBpZiBgaXNFbmNvZGVBbGxgIGlzIHRydWUpXG4gICAgICAgICAgICAvLyAgICBERUNPRElORyB1c2VzIGB0aGlzLml0ZW1zYFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHJldHVybiAoaXNFbmNvZGVBbGwpXG4gICAgICAgICAgICAgICAgPyB0aGlzLml0ZW1zW2luZGV4XVxuICAgICAgICAgICAgICAgIDogdGhpcy5kZWxldGVkSW5kZXhlc1tpbmRleF1cbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLml0ZW1zW2luZGV4XVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMudG1wSXRlbXNbaW5kZXhdIHx8IHRoaXMuaXRlbXNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIFskZGVsZXRlQnlJbmRleF0oaW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXNbaW5kZXhdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy50bXBJdGVtc1tpbmRleF0gPSB1bmRlZmluZWQ7IC8vIFRPRE86IGRvIG5vdCB0cnkgdG8gZ2V0IFwidG1wSXRlbXNcIiBhdCBkZWNvZGluZyB0aW1lLlxuICAgICAgICB9XG4gICAgICAgIFskb25FbmNvZGVFbmRdKCkge1xuICAgICAgICAgICAgdGhpcy50bXBJdGVtcyA9IHRoaXMuaXRlbXMuc2xpY2UoKTtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlZEluZGV4ZXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBbJG9uRGVjb2RlRW5kXSgpIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXMgPSB0aGlzLml0ZW1zLmZpbHRlcigoaXRlbSkgPT4gaXRlbSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHRoaXMudG1wSXRlbXMgPSB0aGlzLml0ZW1zLnNsaWNlKCk7IC8vIFRPRE86IGRvIG5vIHVzZSBcInRtcEl0ZW1zXCIgYXQgZGVjb2RpbmcgdGltZS5cbiAgICAgICAgfVxuICAgICAgICB0b0FycmF5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuc2xpY2UoMCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9KU09OKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLm1hcCgodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHR5cGVvZiAodmFsdWVbJ3RvSlNPTiddKSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgICAgICA/IHZhbHVlWyd0b0pTT04nXSgpXG4gICAgICAgICAgICAgICAgICAgIDogdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvL1xuICAgICAgICAvLyBEZWNvZGluZyB1dGlsaXRpZXNcbiAgICAgICAgLy9cbiAgICAgICAgY2xvbmUoaXNEZWNvZGluZykge1xuICAgICAgICAgICAgbGV0IGNsb25lZDtcbiAgICAgICAgICAgIGlmIChpc0RlY29kaW5nKSB7XG4gICAgICAgICAgICAgICAgY2xvbmVkID0gbmV3IEFycmF5U2NoZW1hKCk7XG4gICAgICAgICAgICAgICAgY2xvbmVkLnB1c2goLi4udGhpcy5pdGVtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbG9uZWQgPSBuZXcgQXJyYXlTY2hlbWEoLi4udGhpcy5tYXAoaXRlbSA9PiAoKGl0ZW1bJGNoYW5nZXNdKVxuICAgICAgICAgICAgICAgICAgICA/IGl0ZW0uY2xvbmUoKVxuICAgICAgICAgICAgICAgICAgICA6IGl0ZW0pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVkO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICB9XG4gICAgcmVnaXN0ZXJUeXBlKFwiYXJyYXlcIiwgeyBjb25zdHJ1Y3RvcjogQXJyYXlTY2hlbWEgfSk7XG5cbiAgICB2YXIgX2EkMywgX2IkMztcbiAgICBjbGFzcyBNYXBTY2hlbWEge1xuICAgICAgICBzdGF0aWMgeyB0aGlzW19hJDNdID0gZW5jb2RlS2V5VmFsdWVPcGVyYXRpb247IH1cbiAgICAgICAgc3RhdGljIHsgdGhpc1tfYiQzXSA9IGRlY29kZUtleVZhbHVlT3BlcmF0aW9uOyB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmUgaWYgYSBwcm9wZXJ0eSBtdXN0IGJlIGZpbHRlcmVkLlxuICAgICAgICAgKiAtIElmIHJldHVybnMgZmFsc2UsIHRoZSBwcm9wZXJ0eSBpcyBOT1QgZ29pbmcgdG8gYmUgZW5jb2RlZC5cbiAgICAgICAgICogLSBJZiByZXR1cm5zIHRydWUsIHRoZSBwcm9wZXJ0eSBpcyBnb2luZyB0byBiZSBlbmNvZGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBFbmNvZGluZyB3aXRoIFwiZmlsdGVyc1wiIGhhcHBlbnMgaW4gdHdvIHN0ZXBzOlxuICAgICAgICAgKiAtIEZpcnN0LCB0aGUgZW5jb2RlciBpdGVyYXRlcyBvdmVyIGFsbCBcIm5vdCBvd25lZFwiIHByb3BlcnRpZXMgYW5kIGVuY29kZXMgdGhlbS5cbiAgICAgICAgICogLSBUaGVuLCB0aGUgZW5jb2RlciBpdGVyYXRlcyBvdmVyIGFsbCBcIm93bmVkXCIgcHJvcGVydGllcyBwZXIgaW5zdGFuY2UgYW5kIGVuY29kZXMgdGhlbS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBbKF9hJDMgPSAkZW5jb2RlciwgX2IkMyA9ICRkZWNvZGVyLCAkZmlsdGVyKV0ocmVmLCBpbmRleCwgdmlldykge1xuICAgICAgICAgICAgcmV0dXJuICghdmlldyB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiAocmVmWyRjaGlsZFR5cGVdKSA9PT0gXCJzdHJpbmdcIiB8fFxuICAgICAgICAgICAgICAgIHZpZXcuaXNDaGFuZ2VUcmVlVmlzaWJsZSgocmVmWyRnZXRCeUluZGV4XShpbmRleCkgPz8gcmVmLmRlbGV0ZWRJdGVtc1tpbmRleF0pWyRjaGFuZ2VzXSkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBpcyh0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZVsnbWFwJ10gIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdHJ1Y3Rvcihpbml0aWFsVmFsdWVzKSB7XG4gICAgICAgICAgICB0aGlzLiRpdGVtcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuJGluZGV4ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZWRJdGVtcyA9IHt9O1xuICAgICAgICAgICAgdGhpc1skY2hhbmdlc10gPSBuZXcgQ2hhbmdlVHJlZSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXNbJGNoYW5nZXNdLmluZGV4ZXMgPSB7fTtcbiAgICAgICAgICAgIGlmIChpbml0aWFsVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluaXRpYWxWYWx1ZXMgaW5zdGFuY2VvZiBNYXAgfHxcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFZhbHVlcyBpbnN0YW5jZW9mIE1hcFNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICBpbml0aWFsVmFsdWVzLmZvckVhY2goKHYsIGspID0+IHRoaXMuc2V0KGssIHYpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgayBpbiBpbml0aWFsVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldChrLCBpbml0aWFsVmFsdWVzW2tdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAkY2hpbGRUeXBlLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKiogSXRlcmF0b3IgKi9cbiAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7IHJldHVybiB0aGlzLiRpdGVtc1tTeW1ib2wuaXRlcmF0b3JdKCk7IH1cbiAgICAgICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkgeyByZXR1cm4gdGhpcy4kaXRlbXNbU3ltYm9sLnRvU3RyaW5nVGFnXTsgfVxuICAgICAgICBzdGF0aWMgZ2V0IFtTeW1ib2wuc3BlY2llc10oKSB7IHJldHVybiBNYXBTY2hlbWE7IH1cbiAgICAgICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNYXBTY2hlbWEjc2V0KCcke2tleX0nLCAke3ZhbHVlfSk6IHRyeWluZyB0byBzZXQgJHt2YWx1ZX0gdmFsdWUgb24gJyR7a2V5fScuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIiAmJiB0aGlzWyRjaGlsZFR5cGVdKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0SW5zdGFuY2VUeXBlKHZhbHVlLCB0aGlzWyRjaGlsZFR5cGVdLCB0aGlzLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRm9yY2UgXCJrZXlcIiBhcyBzdHJpbmdcbiAgICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2NvbHlzZXVzL2NvbHlzZXVzL2lzc3Vlcy81NjEjaXNzdWVjb21tZW50LTE2NDY3MzM0NjhcbiAgICAgICAgICAgIGtleSA9IGtleS50b1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlVHJlZSA9IHRoaXNbJGNoYW5nZXNdO1xuICAgICAgICAgICAgY29uc3QgaXNSZWYgPSAodmFsdWVbJGNoYW5nZXNdKSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICAgICAgbGV0IG9wZXJhdGlvbjtcbiAgICAgICAgICAgIC8vIElTIFJFUExBQ0U/XG4gICAgICAgICAgICBpZiAodHlwZW9mIChjaGFuZ2VUcmVlLmluZGV4ZXNba2V5XSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGNoYW5nZVRyZWUuaW5kZXhlc1trZXldO1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9IGV4cG9ydHMuT1BFUkFUSU9OLlJFUExBQ0U7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IHRoaXMuJGl0ZW1zLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1ZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB2YWx1ZSBpcyB0aGUgc2FtZSwgYXZvaWQgcmUtZW5jb2RpbmcgaXQuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXMgc2NoZW1hLCBmb3JjZSBBREQgb3BlcmF0aW9uIGlmIHZhbHVlIGRpZmZlciBmcm9tIHByZXZpb3VzIG9uZS5cbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uID0gZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFX0FORF9BREQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBwcmV2aW91cyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1ZhbHVlWyRjaGFuZ2VzXS5yb290Py5yZW1vdmUocHJldmlvdXNWYWx1ZVskY2hhbmdlc10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBjaGFuZ2VUcmVlLmluZGV4ZXNbJG51bUZpZWxkc10gPz8gMDtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24gPSBleHBvcnRzLk9QRVJBVElPTi5BREQ7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5kZXhlcy5zZXQoaW5kZXgsIGtleSk7XG4gICAgICAgICAgICAgICAgY2hhbmdlVHJlZS5pbmRleGVzW2tleV0gPSBpbmRleDtcbiAgICAgICAgICAgICAgICBjaGFuZ2VUcmVlLmluZGV4ZXNbJG51bUZpZWxkc10gPSBpbmRleCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiRpdGVtcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICBjaGFuZ2VUcmVlLmNoYW5nZShpbmRleCwgb3BlcmF0aW9uKTtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBzZXQgdmFsdWUncyBwYXJlbnQgYWZ0ZXIgdGhlIHZhbHVlIGlzIHNldFxuICAgICAgICAgICAgLy8gKHRvIGF2b2lkIGVuY29kaW5nIFwicmVmSWRcIiBvcGVyYXRpb25zIGJlZm9yZSBwYXJlbnQncyBcIkFERFwiIG9wZXJhdGlvbilcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBpZiAoaXNSZWYpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVskY2hhbmdlc10uc2V0UGFyZW50KHRoaXMsIGNoYW5nZVRyZWUucm9vdCwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0KGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGl0ZW1zLmdldChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpc1skY2hhbmdlc10uaW5kZXhlc1trZXldO1xuICAgICAgICAgICAgdGhpcy5kZWxldGVkSXRlbXNbaW5kZXhdID0gdGhpc1skY2hhbmdlc10uZGVsZXRlKGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRpdGVtcy5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhcigpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZVRyZWUgPSB0aGlzWyRjaGFuZ2VzXTtcbiAgICAgICAgICAgIC8vIGRpc2NhcmQgcHJldmlvdXMgb3BlcmF0aW9ucy5cbiAgICAgICAgICAgIGNoYW5nZVRyZWUuZGlzY2FyZCh0cnVlKTtcbiAgICAgICAgICAgIGNoYW5nZVRyZWUuaW5kZXhlcyA9IHt9O1xuICAgICAgICAgICAgLy8gY2xlYXIgcHJldmlvdXMgaW5kZXhlc1xuICAgICAgICAgICAgdGhpcy4kaW5kZXhlcy5jbGVhcigpO1xuICAgICAgICAgICAgLy8gY2xlYXIgaXRlbXNcbiAgICAgICAgICAgIHRoaXMuJGl0ZW1zLmNsZWFyKCk7XG4gICAgICAgICAgICBjaGFuZ2VUcmVlLm9wZXJhdGlvbihleHBvcnRzLk9QRVJBVElPTi5DTEVBUik7XG4gICAgICAgIH1cbiAgICAgICAgaGFzKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGl0ZW1zLmhhcyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGZvckVhY2goY2FsbGJhY2tmbikge1xuICAgICAgICAgICAgdGhpcy4kaXRlbXMuZm9yRWFjaChjYWxsYmFja2ZuKTtcbiAgICAgICAgfVxuICAgICAgICBlbnRyaWVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGl0ZW1zLmVudHJpZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBrZXlzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGl0ZW1zLmtleXMoKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMudmFsdWVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMuc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBzZXRJbmRleChpbmRleCwga2V5KSB7XG4gICAgICAgICAgICB0aGlzLiRpbmRleGVzLnNldChpbmRleCwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBnZXRJbmRleChpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGluZGV4ZXMuZ2V0KGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBbJGdldEJ5SW5kZXhdKGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMuZ2V0KHRoaXMuJGluZGV4ZXMuZ2V0KGluZGV4KSk7XG4gICAgICAgIH1cbiAgICAgICAgWyRkZWxldGVCeUluZGV4XShpbmRleCkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gdGhpcy4kaW5kZXhlcy5nZXQoaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy4kaXRlbXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB0aGlzLiRpbmRleGVzLmRlbGV0ZShpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgWyRvbkVuY29kZUVuZF0oKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZWRJdGVtcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRvSlNPTigpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgICAgICAgICAgdGhpcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgbWFwW2tleV0gPSAodHlwZW9mICh2YWx1ZVsndG9KU09OJ10pID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgICAgID8gdmFsdWVbJ3RvSlNPTiddKClcbiAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgfVxuICAgICAgICAvL1xuICAgICAgICAvLyBEZWNvZGluZyB1dGlsaXRpZXNcbiAgICAgICAgLy9cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjbG9uZShpc0RlY29kaW5nKSB7XG4gICAgICAgICAgICBsZXQgY2xvbmVkO1xuICAgICAgICAgICAgaWYgKGlzRGVjb2RpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBjbGllbnQtc2lkZVxuICAgICAgICAgICAgICAgIGNsb25lZCA9IE9iamVjdC5hc3NpZ24obmV3IE1hcFNjaGVtYSgpLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHNlcnZlci1zaWRlXG4gICAgICAgICAgICAgICAgY2xvbmVkID0gbmV3IE1hcFNjaGVtYSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVbJGNoYW5nZXNdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZWQuc2V0KGtleSwgdmFsdWVbJ2Nsb25lJ10oKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZWQuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZ2lzdGVyVHlwZShcIm1hcFwiLCB7IGNvbnN0cnVjdG9yOiBNYXBTY2hlbWEgfSk7XG5cbiAgICBjb25zdCBERUZBVUxUX1ZJRVdfVEFHID0gLTE7XG4gICAgZnVuY3Rpb24gZW50aXR5KGNvbnN0cnVjdG9yKSB7XG4gICAgICAgIFR5cGVDb250ZXh0LnJlZ2lzdGVyKGNvbnN0cnVjdG9yKTtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBbU2VlIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5jb2x5c2V1cy5pby9zdGF0ZS9zY2hlbWEvKVxuICAgICAqXG4gICAgICogQW5ub3RhdGUgYSBTY2hlbWEgcHJvcGVydHkgdG8gYmUgc2VyaWFsaXplYWJsZS5cbiAgICAgKiBcXEB0eXBlKCknZCBmaWVsZHMgYXJlIGF1dG9tYXRpY2FsbHkgZmxhZ2dlZCBhcyBcImRpcnR5XCIgZm9yIHRoZSBuZXh0IHBhdGNoLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgU3RhbmRhcmQgdXNhZ2UsIHdpdGggYXV0b21hdGljIGNoYW5nZSB0cmFja2luZy5cbiAgICAgKiBgYGBcbiAgICAgKiBcXEB0eXBlKFwic3RyaW5nXCIpIHByb3BlcnR5TmFtZTogc3RyaW5nO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGV4YW1wbGUgWW91IGNhbiBwcm92aWRlIHRoZSBcIm1hbnVhbFwiIG9wdGlvbiBpZiB5b3UnZCBsaWtlIHRvIG1hbnVhbGx5IGNvbnRyb2wgeW91ciBwYXRjaGVzIHZpYSAuc2V0RGlydHkoKS5cbiAgICAgKiBgYGBcbiAgICAgKiBcXEB0eXBlKFwic3RyaW5nXCIsIHsgbWFudWFsOiB0cnVlIH0pXG4gICAgICogYGBgXG4gICAgICovXG4gICAgLy8gZXhwb3J0IGZ1bmN0aW9uIHR5cGUodHlwZTogRGVmaW5pdGlvblR5cGUsIG9wdGlvbnM/OiBUeXBlT3B0aW9ucykge1xuICAgIC8vICAgICByZXR1cm4gZnVuY3Rpb24gKHsgZ2V0LCBzZXQgfSwgY29udGV4dDogQ2xhc3NBY2Nlc3NvckRlY29yYXRvckNvbnRleHQpOiBDbGFzc0FjY2Vzc29yRGVjb3JhdG9yUmVzdWx0PFNjaGVtYSwgYW55PiB7XG4gICAgLy8gICAgICAgICBpZiAoY29udGV4dC5raW5kICE9PSBcImFjY2Vzc29yXCIpIHtcbiAgICAvLyAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJAdHlwZSgpIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzcyBhY2Nlc3NvciBwcm9wZXJ0aWVzXCIpO1xuICAgIC8vICAgICAgICAgfVxuICAgIC8vICAgICAgICAgY29uc3QgZmllbGQgPSBjb250ZXh0Lm5hbWUudG9TdHJpbmcoKTtcbiAgICAvLyAgICAgICAgIC8vXG4gICAgLy8gICAgICAgICAvLyBkZXRlY3QgaW5kZXggZm9yIHRoaXMgZmllbGQsIGNvbnNpZGVyaW5nIGluaGVyaXRhbmNlXG4gICAgLy8gICAgICAgICAvL1xuICAgIC8vICAgICAgICAgY29uc3QgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGNvbnRleHQubWV0YWRhdGEpO1xuICAgIC8vICAgICAgICAgbGV0IGZpZWxkSW5kZXg6IG51bWJlciA9IGNvbnRleHQubWV0YWRhdGFbJG51bUZpZWxkc10gLy8gY3VycmVudCBzdHJ1Y3R1cmUgYWxyZWFkeSBoYXMgZmllbGRzIGRlZmluZWRcbiAgICAvLyAgICAgICAgICAgICA/PyAocGFyZW50ICYmIHBhcmVudFskbnVtRmllbGRzXSkgLy8gcGFyZW50IHN0cnVjdHVyZSBoYXMgZmllbGRzIGRlZmluZWRcbiAgICAvLyAgICAgICAgICAgICA/PyAtMTsgLy8gbm8gZmllbGRzIGRlZmluZWRcbiAgICAvLyAgICAgICAgIGZpZWxkSW5kZXgrKztcbiAgICAvLyAgICAgICAgIGlmIChcbiAgICAvLyAgICAgICAgICAgICAhcGFyZW50ICYmIC8vIHRoZSBwYXJlbnQgYWxyZWFkeSBpbml0aWFsaXplcyB0aGUgYCRjaGFuZ2VzYCBwcm9wZXJ0eVxuICAgIC8vICAgICAgICAgICAgICFNZXRhZGF0YS5oYXNGaWVsZHMoY29udGV4dC5tZXRhZGF0YSlcbiAgICAvLyAgICAgICAgICkge1xuICAgIC8vICAgICAgICAgICAgIGNvbnRleHQuYWRkSW5pdGlhbGl6ZXIoZnVuY3Rpb24gKHRoaXM6IFJlZikge1xuICAgIC8vICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJGNoYW5nZXMsIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgQ2hhbmdlVHJlZSh0aGlzKSxcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAvLyAgICAgICAgICAgICAgICAgfSk7XG4gICAgLy8gICAgICAgICAgICAgfSk7XG4gICAgLy8gICAgICAgICB9XG4gICAgLy8gICAgICAgICBNZXRhZGF0YS5hZGRGaWVsZChjb250ZXh0Lm1ldGFkYXRhLCBmaWVsZEluZGV4LCBmaWVsZCwgdHlwZSk7XG4gICAgLy8gICAgICAgICBjb25zdCBpc0FycmF5ID0gQXJyYXlTY2hlbWEuaXModHlwZSk7XG4gICAgLy8gICAgICAgICBjb25zdCBpc01hcCA9ICFpc0FycmF5ICYmIE1hcFNjaGVtYS5pcyh0eXBlKTtcbiAgICAvLyAgICAgICAgIC8vIGlmIChvcHRpb25zICYmIG9wdGlvbnMubWFudWFsKSB7XG4gICAgLy8gICAgICAgICAvLyAgICAgLy8gZG8gbm90IGRlY2xhcmUgZ2V0dGVyL3NldHRlciBkZXNjcmlwdG9yXG4gICAgLy8gICAgICAgICAvLyAgICAgZGVmaW5pdGlvbi5kZXNjcmlwdG9yc1tmaWVsZF0gPSB7XG4gICAgLy8gICAgICAgICAvLyAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgLy8gICAgICAgICAvLyAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAvLyAgICAgICAgIC8vICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgLy8gICAgICAgICAvLyAgICAgfTtcbiAgICAvLyAgICAgICAgIC8vICAgICByZXR1cm47XG4gICAgLy8gICAgICAgICAvLyB9XG4gICAgLy8gICAgICAgICByZXR1cm4ge1xuICAgIC8vICAgICAgICAgICAgIGluaXQodmFsdWUpIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgLy8gVE9ETzogbWF5IG5lZWQgdG8gY29udmVydCBBcnJheVNjaGVtYS9NYXBTY2hlbWEgaGVyZVxuICAgIC8vICAgICAgICAgICAgICAgICAvLyBkbyBub3QgZmxhZyBjaGFuZ2UgaWYgdmFsdWUgaXMgdW5kZWZpbmVkLlxuICAgIC8vICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgdGhpc1skY2hhbmdlc10uY2hhbmdlKGZpZWxkSW5kZXgpO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgLy8gYXV0b21hdGljYWxsdHkgdHJhbnNmb3JtIEFycmF5IGludG8gQXJyYXlTY2hlbWFcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBBcnJheVNjaGVtYSkpIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgQXJyYXlTY2hlbWEoLi4udmFsdWUpO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVskY2hpbGRUeXBlXSA9IE9iamVjdC52YWx1ZXModHlwZSlbMF07XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICB9XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAvLyBhdXRvbWF0aWNhbGx0eSB0cmFuc2Zvcm0gTWFwIGludG8gTWFwU2NoZW1hXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBpZiAoaXNNYXApIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIE1hcFNjaGVtYSkpIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgTWFwU2NoZW1hKHZhbHVlKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbJGNoaWxkVHlwZV0gPSBPYmplY3QudmFsdWVzKHR5cGUpWzBdO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHRvIHR1cm4gcHJvdmlkZWQgc3RydWN0dXJlIGludG8gYSBQcm94eVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlWyckcHJveHknXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTWFwKSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZ2V0TWFwUHJveHkodmFsdWUpO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgLy8gICAgICAgICAgICAgfSxcbiAgICAvLyAgICAgICAgICAgICBnZXQoKSB7XG4gICAgLy8gICAgICAgICAgICAgICAgIHJldHVybiBnZXQuY2FsbCh0aGlzKTtcbiAgICAvLyAgICAgICAgICAgICB9LFxuICAgIC8vICAgICAgICAgICAgIHNldCh2YWx1ZTogYW55KSB7XG4gICAgLy8gICAgICAgICAgICAgICAgIC8qKlxuICAgIC8vICAgICAgICAgICAgICAgICAgKiBDcmVhdGUgUHJveHkgZm9yIGFycmF5IG9yIG1hcCBpdGVtc1xuICAgIC8vICAgICAgICAgICAgICAgICAgKi9cbiAgICAvLyAgICAgICAgICAgICAgICAgLy8gc2tpcCBpZiB2YWx1ZSBpcyB0aGUgc2FtZSBhcyBjYWNoZWQuXG4gICAgLy8gICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gZ2V0LmNhbGwodGhpcykpIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAvLyAgICAgICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgICAgICAgICBpZiAoXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICB2YWx1ZSAhPT0gbnVsbFxuICAgIC8vICAgICAgICAgICAgICAgICApIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHR5IHRyYW5zZm9ybSBBcnJheSBpbnRvIEFycmF5U2NoZW1hXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlTY2hlbWEpKSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IEFycmF5U2NoZW1hKC4uLnZhbHVlKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbJGNoaWxkVHlwZV0gPSBPYmplY3QudmFsdWVzKHR5cGUpWzBdO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgLy8gYXV0b21hdGljYWxsdHkgdHJhbnNmb3JtIE1hcCBpbnRvIE1hcFNjaGVtYVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTWFwKSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBNYXBTY2hlbWEpKSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IE1hcFNjaGVtYSh2YWx1ZSk7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlWyRjaGlsZFR5cGVdID0gT2JqZWN0LnZhbHVlcyh0eXBlKVswXTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIC8vIHRyeSB0byB0dXJuIHByb3ZpZGVkIHN0cnVjdHVyZSBpbnRvIGEgUHJveHlcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZVsnJHByb3h5J10gPT09IHVuZGVmaW5lZCkge1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc01hcCkge1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdldE1hcFByb3h5KHZhbHVlKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICB9XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAvLyBmbGFnIHRoZSBjaGFuZ2UgZm9yIGVuY29kaW5nLlxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgdGhpc1skY2hhbmdlc10uY2hhbmdlKGZpZWxkSW5kZXgpO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGwgc2V0UGFyZW50KCkgcmVjdXJzaXZlbHkgZm9yIHRoaXMgYW5kIGl0cyBjaGlsZFxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgLy8gc3RydWN0dXJlcy5cbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVbJGNoYW5nZXNdKSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbJGNoYW5nZXNdLnNldFBhcmVudChcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1skY2hhbmdlc10ucm9vdCxcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWV0YWRhdGEuZ2V0SW5kZXgoY29udGV4dC5tZXRhZGF0YSwgZmllbGQpLFxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICB9XG4gICAgLy8gICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2V0LmNhbGwodGhpcykpIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAvLyBTZXR0aW5nIGEgZmllbGQgdG8gYG51bGxgIG9yIGB1bmRlZmluZWRgIHdpbGwgZGVsZXRlIGl0LlxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIHRoaXNbJGNoYW5nZXNdLmRlbGV0ZShmaWVsZCk7XG4gICAgLy8gICAgICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgICAgICAgICAgc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgIC8vICAgICAgICAgICAgIH0sXG4gICAgLy8gICAgICAgICB9O1xuICAgIC8vICAgICB9XG4gICAgLy8gfVxuICAgIGZ1bmN0aW9uIHZpZXcodGFnID0gREVGQVVMVF9WSUVXX1RBRykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgZmllbGROYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBjb25zdHJ1Y3RvciA9IHRhcmdldC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudENsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudE1ldGFkYXRhID0gcGFyZW50Q2xhc3NbU3ltYm9sLm1ldGFkYXRhXTtcbiAgICAgICAgICAgIC8vIFRPRE86IHVzZSBNZXRhZGF0YS5pbml0aWFsaXplKClcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gKGNvbnN0cnVjdG9yW1N5bWJvbC5tZXRhZGF0YV0gPz89IE9iamVjdC5hc3NpZ24oe30sIGNvbnN0cnVjdG9yW1N5bWJvbC5tZXRhZGF0YV0sIHBhcmVudE1ldGFkYXRhID8/IE9iamVjdC5jcmVhdGUobnVsbCkpKTtcbiAgICAgICAgICAgIC8vIGNvbnN0IGZpZWxkSW5kZXggPSBtZXRhZGF0YVtmaWVsZE5hbWVdO1xuICAgICAgICAgICAgLy8gaWYgKCFtZXRhZGF0YVtmaWVsZEluZGV4XSkge1xuICAgICAgICAgICAgLy8gICAgIC8vXG4gICAgICAgICAgICAvLyAgICAgLy8gZGV0ZWN0IGluZGV4IGZvciB0aGlzIGZpZWxkLCBjb25zaWRlcmluZyBpbmhlcml0YW5jZVxuICAgICAgICAgICAgLy8gICAgIC8vXG4gICAgICAgICAgICAvLyAgICAgbWV0YWRhdGFbZmllbGRJbmRleF0gPSB7XG4gICAgICAgICAgICAvLyAgICAgICAgIHR5cGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vICAgICAgICAgaW5kZXg6IChtZXRhZGF0YVskbnVtRmllbGRzXSAvLyBjdXJyZW50IHN0cnVjdHVyZSBhbHJlYWR5IGhhcyBmaWVsZHMgZGVmaW5lZFxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgPz8gKHBhcmVudE1ldGFkYXRhICYmIHBhcmVudE1ldGFkYXRhWyRudW1GaWVsZHNdKSAvLyBwYXJlbnQgc3RydWN0dXJlIGhhcyBmaWVsZHMgZGVmaW5lZFxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgPz8gLTEpICsgMSAvLyBubyBmaWVsZHMgZGVmaW5lZFxuICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIE1ldGFkYXRhLnNldFRhZyhtZXRhZGF0YSwgZmllbGROYW1lLCB0YWcpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0eXBlKHR5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGZpZWxkKSB7XG4gICAgICAgICAgICBjb25zdCBjb25zdHJ1Y3RvciA9IHRhcmdldC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb25zdHJ1Y3Rvci5uYW1lfTogQHR5cGUoKSByZWZlcmVuY2UgcHJvdmlkZWQgZm9yIFwiJHtmaWVsZH1cIiBpcyB1bmRlZmluZWQuIE1ha2Ugc3VyZSB5b3UgZG9uJ3QgaGF2ZSBhbnkgY2lyY3VsYXIgZGVwZW5kZW5jaWVzLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZm9yIGluaGVyaXRhbmNlIHN1cHBvcnRcbiAgICAgICAgICAgIFR5cGVDb250ZXh0LnJlZ2lzdGVyKGNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudENsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudE1ldGFkYXRhID0gcGFyZW50Q2xhc3NbU3ltYm9sLm1ldGFkYXRhXTtcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gTWV0YWRhdGEuaW5pdGlhbGl6ZShjb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICBsZXQgZmllbGRJbmRleCA9IG1ldGFkYXRhW2ZpZWxkXTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogc2tpcCBpZiBkZXNjcmlwdG9yIGFscmVhZHkgZXhpc3RzIGZvciB0aGlzIGZpZWxkIChgQGRlcHJlY2F0ZWQoKWApXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChtZXRhZGF0YVtmaWVsZEluZGV4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhW2ZpZWxkSW5kZXhdLmRlcHJlY2F0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90IGNyZWF0ZSBhY2Nlc3NvcnMgZm9yIGRlcHJlY2F0ZWQgcHJvcGVydGllcy5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtZXRhZGF0YVtmaWVsZEluZGV4XS50eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJ5aW5nIHRvIGRlZmluZSBzYW1lIHByb3BlcnR5IG11bHRpcGxlIHRpbWVzIGFjcm9zcyBpbmhlcml0YW5jZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NvbHlzZXVzL2NvbHlzZXVzLXVuaXR5M2QvaXNzdWVzLzEzMSNpc3N1ZWNvbW1lbnQtODE0MzA4NTcyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBjb2x5c2V1cy9zY2hlbWE6IER1cGxpY2F0ZSAnJHtmaWVsZH0nIGRlZmluaXRpb24gb24gJyR7Y29uc3RydWN0b3IubmFtZX0nLlxcbkNoZWNrIEB0eXBlKCkgYW5ub3RhdGlvbmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWZpbml0aW9uQXRMaW5lID0gZS5zdGFjay5zcGxpdChcIlxcblwiKVs0XS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZS5tZXNzYWdlfSAke2RlZmluaXRpb25BdExpbmV9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIGRldGVjdCBpbmRleCBmb3IgdGhpcyBmaWVsZCwgY29uc2lkZXJpbmcgaW5oZXJpdGFuY2VcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGZpZWxkSW5kZXggPSBtZXRhZGF0YVskbnVtRmllbGRzXSAvLyBjdXJyZW50IHN0cnVjdHVyZSBhbHJlYWR5IGhhcyBmaWVsZHMgZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/PyAocGFyZW50TWV0YWRhdGEgJiYgcGFyZW50TWV0YWRhdGFbJG51bUZpZWxkc10pIC8vIHBhcmVudCBzdHJ1Y3R1cmUgaGFzIGZpZWxkcyBkZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8/IC0xOyAvLyBubyBmaWVsZHMgZGVmaW5lZFxuICAgICAgICAgICAgICAgIGZpZWxkSW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubWFudWFsKSB7XG4gICAgICAgICAgICAgICAgTWV0YWRhdGEuYWRkRmllbGQobWV0YWRhdGEsIGZpZWxkSW5kZXgsIGZpZWxkLCB0eXBlLCB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBkZWNsYXJlIGdldHRlci9zZXR0ZXIgZGVzY3JpcHRvclxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcGxleFR5cGVLbGFzcyA9IChBcnJheS5pc0FycmF5KHR5cGUpKVxuICAgICAgICAgICAgICAgICAgICA/IGdldFR5cGUoXCJhcnJheVwiKVxuICAgICAgICAgICAgICAgICAgICA6ICh0eXBlb2YgKE9iamVjdC5rZXlzKHR5cGUpWzBdKSA9PT0gXCJzdHJpbmdcIikgJiYgZ2V0VHlwZShPYmplY3Qua2V5cyh0eXBlKVswXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRUeXBlID0gKGNvbXBsZXhUeXBlS2xhc3MpXG4gICAgICAgICAgICAgICAgICAgID8gT2JqZWN0LnZhbHVlcyh0eXBlKVswXVxuICAgICAgICAgICAgICAgICAgICA6IHR5cGU7XG4gICAgICAgICAgICAgICAgTWV0YWRhdGEuYWRkRmllbGQobWV0YWRhdGEsIGZpZWxkSW5kZXgsIGZpZWxkLCB0eXBlLCBnZXRQcm9wZXJ0eURlc2NyaXB0b3IoYF8ke2ZpZWxkfWAsIGZpZWxkSW5kZXgsIGNoaWxkVHlwZSwgY29tcGxleFR5cGVLbGFzcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRQcm9wZXJ0eURlc2NyaXB0b3IoZmllbGRDYWNoZWQsIGZpZWxkSW5kZXgsIHR5cGUsIGNvbXBsZXhUeXBlS2xhc3MpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpc1tmaWVsZENhY2hlZF07IH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSB0aGlzW2ZpZWxkQ2FjaGVkXSA/PyB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgLy8gc2tpcCBpZiB2YWx1ZSBpcyB0aGUgc2FtZSBhcyBjYWNoZWQuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBwcmV2aW91c1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXhUeXBlS2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHR5IHRyYW5zZm9ybSBBcnJheSBpbnRvIEFycmF5U2NoZW1hXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxleFR5cGVLbGFzcy5jb25zdHJ1Y3RvciA9PT0gQXJyYXlTY2hlbWEgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5U2NoZW1hKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IEFycmF5U2NoZW1hKC4uLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHR5IHRyYW5zZm9ybSBNYXAgaW50byBNYXBTY2hlbWFcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV4VHlwZUtsYXNzLmNvbnN0cnVjdG9yID09PSBNYXBTY2hlbWEgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIE1hcFNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBNYXBTY2hlbWEodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbJGNoaWxkVHlwZV0gPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiAodHlwZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydEluc3RhbmNlVHlwZSh2YWx1ZSwgdHlwZSwgdGhpcywgZmllbGRDYWNoZWQuc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydFR5cGUodmFsdWUsIHR5cGUsIHRoaXMsIGZpZWxkQ2FjaGVkLnN1YnN0cmluZygxKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlVHJlZSA9IHRoaXNbJGNoYW5nZXNdO1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXBsYWNpbmcgZXhpc3RpbmcgXCJyZWZcIiwgcmVtb3ZlIGl0IGZyb20gcm9vdC5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcmV2aW91c1ZhbHVlWyRjaGFuZ2VzXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlVHJlZS5yb290Py5yZW1vdmUocHJldmlvdXNWYWx1ZVskY2hhbmdlc10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3RvclskdHJhY2tdKGNoYW5nZVRyZWUsIGZpZWxkSW5kZXgsIGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURV9BTkRfQUREKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3JbJHRyYWNrXShjaGFuZ2VUcmVlLCBmaWVsZEluZGV4LCBleHBvcnRzLk9QRVJBVElPTi5BREQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGwgc2V0UGFyZW50KCkgcmVjdXJzaXZlbHkgZm9yIHRoaXMgYW5kIGl0cyBjaGlsZFxuICAgICAgICAgICAgICAgICAgICAvLyBzdHJ1Y3R1cmVzLlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVskY2hhbmdlc10/LnNldFBhcmVudCh0aGlzLCBjaGFuZ2VUcmVlLnJvb3QsIGZpZWxkSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcmV2aW91c1ZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0dGluZyBhIGZpZWxkIHRvIGBudWxsYCBvciBgdW5kZWZpbmVkYCB3aWxsIGRlbGV0ZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgdGhpc1skY2hhbmdlc10uZGVsZXRlKGZpZWxkSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzW2ZpZWxkQ2FjaGVkXSA9IHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYEBkZXByZWNhdGVkKClgIGZsYWcgYSBmaWVsZCBhcyBkZXByZWNhdGVkLlxuICAgICAqIFRoZSBwcmV2aW91cyBgQHR5cGUoKWAgYW5ub3RhdGlvbiBzaG91bGQgcmVtYWluIGFsb25nIHdpdGggdGhpcyBvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlZCh0aHJvd3MgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoa2xhc3MsIGZpZWxkKSB7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gRklYTUU6IHRoZSBmb2xsb3dpbmcgYmxvY2sgb2YgY29kZSBpcyByZXBlYXRlZCBhY3Jvc3MgYEB0eXBlKClgLCBgQGRlcHJlY2F0ZWQoKWAgYW5kIGBAdW5yZWxpYWJsZSgpYCBkZWNvcmF0b3JzLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0ga2xhc3MuY29uc3RydWN0b3I7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRDbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRNZXRhZGF0YSA9IHBhcmVudENsYXNzW1N5bWJvbC5tZXRhZGF0YV07XG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IChjb25zdHJ1Y3RvcltTeW1ib2wubWV0YWRhdGFdID8/PSBPYmplY3QuYXNzaWduKHt9LCBjb25zdHJ1Y3RvcltTeW1ib2wubWV0YWRhdGFdLCBwYXJlbnRNZXRhZGF0YSA/PyBPYmplY3QuY3JlYXRlKG51bGwpKSk7XG4gICAgICAgICAgICBjb25zdCBmaWVsZEluZGV4ID0gbWV0YWRhdGFbZmllbGRdO1xuICAgICAgICAgICAgLy8gaWYgKCFtZXRhZGF0YVtmaWVsZF0pIHtcbiAgICAgICAgICAgIC8vICAgICAvL1xuICAgICAgICAgICAgLy8gICAgIC8vIGRldGVjdCBpbmRleCBmb3IgdGhpcyBmaWVsZCwgY29uc2lkZXJpbmcgaW5oZXJpdGFuY2VcbiAgICAgICAgICAgIC8vICAgICAvL1xuICAgICAgICAgICAgLy8gICAgIG1ldGFkYXRhW2ZpZWxkXSA9IHtcbiAgICAgICAgICAgIC8vICAgICAgICAgdHlwZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgLy8gICAgICAgICBpbmRleDogKG1ldGFkYXRhWyRudW1GaWVsZHNdIC8vIGN1cnJlbnQgc3RydWN0dXJlIGFscmVhZHkgaGFzIGZpZWxkcyBkZWZpbmVkXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICA/PyAocGFyZW50TWV0YWRhdGEgJiYgcGFyZW50TWV0YWRhdGFbJG51bUZpZWxkc10pIC8vIHBhcmVudCBzdHJ1Y3R1cmUgaGFzIGZpZWxkcyBkZWZpbmVkXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICA/PyAtMSkgKyAxIC8vIG5vIGZpZWxkcyBkZWZpbmVkXG4gICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgbWV0YWRhdGFbZmllbGRJbmRleF0uZGVwcmVjYXRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhyb3dzKSB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGFbJGRlc2NyaXB0b3JzXSA/Pz0ge307XG4gICAgICAgICAgICAgICAgbWV0YWRhdGFbJGRlc2NyaXB0b3JzXVtmaWVsZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgRXJyb3IoYCR7ZmllbGR9IGlzIGRlcHJlY2F0ZWQuYCk7IH0sXG4gICAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IH0sXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmxhZyBtZXRhZGF0YVtmaWVsZF0gYXMgbm9uLWVudW1lcmFibGVcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXRhZGF0YSwgZmllbGRJbmRleCwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBtZXRhZGF0YVtmaWVsZEluZGV4XSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZpbmVUeXBlcyh0YXJnZXQsIGZpZWxkcywgb3B0aW9ucykge1xuICAgICAgICBmb3IgKGxldCBmaWVsZCBpbiBmaWVsZHMpIHtcbiAgICAgICAgICAgIHR5cGUoZmllbGRzW2ZpZWxkXSwgb3B0aW9ucykodGFyZ2V0LnByb3RvdHlwZSwgZmllbGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVtYShmaWVsZHMsIG5hbWUsIGluaGVyaXRzID0gU2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZXMgPSB7fTtcbiAgICAgICAgY29uc3Qgdmlld1RhZ0ZpZWxkcyA9IHt9O1xuICAgICAgICBmb3IgKGxldCBmaWVsZE5hbWUgaW4gZmllbGRzKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGZpZWxkc1tmaWVsZE5hbWVdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoZmllbGQpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkWydkZWZhdWx0J10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWVzW2ZpZWxkTmFtZV0gPSBmaWVsZFsnZGVmYXVsdCddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmllbGRbJ3ZpZXcnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdUYWdGaWVsZHNbZmllbGROYW1lXSA9ICh0eXBlb2YgKGZpZWxkWyd2aWV3J10pID09PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgID8gREVGQVVMVF9WSUVXX1RBR1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBmaWVsZFsndmlldyddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrbGFzcyA9IE1ldGFkYXRhLnNldEZpZWxkcyhjbGFzcyBleHRlbmRzIGluaGVyaXRzIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBhcmdzWzBdID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFZhbHVlcywgYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZpZWxkcyk7XG4gICAgICAgIGZvciAobGV0IGZpZWxkTmFtZSBpbiB2aWV3VGFnRmllbGRzKSB7XG4gICAgICAgICAgICB2aWV3KHZpZXdUYWdGaWVsZHNbZmllbGROYW1lXSkoa2xhc3MucHJvdG90eXBlLCBmaWVsZE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoa2xhc3MsIFwibmFtZVwiLCB7IHZhbHVlOiBuYW1lIH0pO1xuICAgICAgICB9XG4gICAgICAgIGtsYXNzLmV4dGVuZHMgPSAoZmllbGRzLCBuYW1lKSA9PiBzY2hlbWEoZmllbGRzLCBuYW1lLCBrbGFzcyk7XG4gICAgICAgIHJldHVybiBrbGFzcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJbmRlbnQobGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIChuZXcgQXJyYXkobGV2ZWwpLmZpbGwoMCkpLm1hcCgoXywgaSkgPT4gKGkgPT09IGxldmVsIC0gMSkgPyBg4pSU4pSAIGAgOiBgICAgYCkuam9pbihcIlwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZHVtcENoYW5nZXMoc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0ICRyb290ID0gc2NoZW1hWyRjaGFuZ2VzXS5yb290O1xuICAgICAgICBjb25zdCBkdW1wID0ge1xuICAgICAgICAgICAgb3BzOiB7fSxcbiAgICAgICAgICAgIHJlZnM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIC8vIGZvciAoY29uc3QgcmVmSWQgaW4gJHJvb3QuY2hhbmdlcykge1xuICAgICAgICAkcm9vdC5jaGFuZ2VzLmZvckVhY2goY2hhbmdlVHJlZSA9PiB7XG4gICAgICAgICAgICAvLyBza2lwIGlmIENoYW5nZVRyZWUgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgICBpZiAoY2hhbmdlVHJlZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IGNoYW5nZVRyZWUuaW5kZXhlZE9wZXJhdGlvbnM7XG4gICAgICAgICAgICBkdW1wLnJlZnMucHVzaChgcmVmSWQjJHtjaGFuZ2VUcmVlLnJlZklkfWApO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpbmRleCBpbiBjaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3AgPSBjaGFuZ2VzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBvcE5hbWUgPSBleHBvcnRzLk9QRVJBVElPTltvcF07XG4gICAgICAgICAgICAgICAgaWYgKCFkdW1wLm9wc1tvcE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGR1bXAub3BzW29wTmFtZV0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkdW1wLm9wc1tleHBvcnRzLk9QRVJBVElPTltvcF1dKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZHVtcDtcbiAgICB9XG5cbiAgICB2YXIgX2EkMiwgX2IkMjtcbiAgICAvKipcbiAgICAgKiBTY2hlbWEgZW5jb2RlciAvIGRlY29kZXJcbiAgICAgKi9cbiAgICBjbGFzcyBTY2hlbWEge1xuICAgICAgICBzdGF0aWMgeyB0aGlzW19hJDJdID0gZW5jb2RlU2NoZW1hT3BlcmF0aW9uOyB9XG4gICAgICAgIHN0YXRpYyB7IHRoaXNbX2IkMl0gPSBkZWNvZGVTY2hlbWFPcGVyYXRpb247IH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFzc2lnbiB0aGUgcHJvcGVydHkgZGVzY3JpcHRvcnMgcmVxdWlyZWQgdG8gdHJhY2sgY2hhbmdlcyBvbiB0aGlzIGluc3RhbmNlLlxuICAgICAgICAgKiBAcGFyYW0gaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBpbml0aWFsaXplKGluc3RhbmNlKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdGFuY2UsICRjaGFuZ2VzLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBDaGFuZ2VUcmVlKGluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnN0YW5jZSwgaW5zdGFuY2UuY29uc3RydWN0b3JbU3ltYm9sLm1ldGFkYXRhXT8uWyRkZXNjcmlwdG9yc10gfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBpcyh0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mICh0eXBlW1N5bWJvbC5tZXRhZGF0YV0pID09PSBcIm9iamVjdFwiO1xuICAgICAgICAgICAgLy8gY29uc3QgbWV0YWRhdGEgPSB0eXBlW1N5bWJvbC5tZXRhZGF0YV07XG4gICAgICAgICAgICAvLyByZXR1cm4gbWV0YWRhdGEgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1ldGFkYXRhLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYWNrIHByb3BlcnR5IGNoYW5nZXNcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBbKF9hJDIgPSAkZW5jb2RlciwgX2IkMiA9ICRkZWNvZGVyLCAkdHJhY2spXShjaGFuZ2VUcmVlLCBpbmRleCwgb3BlcmF0aW9uID0gZXhwb3J0cy5PUEVSQVRJT04uQUREKSB7XG4gICAgICAgICAgICBjaGFuZ2VUcmVlLmNoYW5nZShpbmRleCwgb3BlcmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lIGlmIGEgcHJvcGVydHkgbXVzdCBiZSBmaWx0ZXJlZC5cbiAgICAgICAgICogLSBJZiByZXR1cm5zIGZhbHNlLCB0aGUgcHJvcGVydHkgaXMgTk9UIGdvaW5nIHRvIGJlIGVuY29kZWQuXG4gICAgICAgICAqIC0gSWYgcmV0dXJucyB0cnVlLCB0aGUgcHJvcGVydHkgaXMgZ29pbmcgdG8gYmUgZW5jb2RlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogRW5jb2Rpbmcgd2l0aCBcImZpbHRlcnNcIiBoYXBwZW5zIGluIHR3byBzdGVwczpcbiAgICAgICAgICogLSBGaXJzdCwgdGhlIGVuY29kZXIgaXRlcmF0ZXMgb3ZlciBhbGwgXCJub3Qgb3duZWRcIiBwcm9wZXJ0aWVzIGFuZCBlbmNvZGVzIHRoZW0uXG4gICAgICAgICAqIC0gVGhlbiwgdGhlIGVuY29kZXIgaXRlcmF0ZXMgb3ZlciBhbGwgXCJvd25lZFwiIHByb3BlcnRpZXMgcGVyIGluc3RhbmNlIGFuZCBlbmNvZGVzIHRoZW0uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgWyRmaWx0ZXJdKHJlZiwgaW5kZXgsIHZpZXcpIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gcmVmLmNvbnN0cnVjdG9yW1N5bWJvbC5tZXRhZGF0YV07XG4gICAgICAgICAgICBjb25zdCB0YWcgPSBtZXRhZGF0YVtpbmRleF0/LnRhZztcbiAgICAgICAgICAgIGlmICh2aWV3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzaGFyZWQgcGFzcy9lbmNvZGU6IGVuY29kZSBpZiBkb2Vzbid0IGhhdmUgYSB0YWdcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFnID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0YWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIHZpZXcgcGFzczogbm8gdGFnXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0YWcgPT09IERFRkFVTFRfVklFV19UQUcpIHtcbiAgICAgICAgICAgICAgICAvLyB2aWV3IHBhc3M6IGRlZmF1bHQgdGFnXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZXcuaXNDaGFuZ2VUcmVlVmlzaWJsZShyZWZbJGNoYW5nZXNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHZpZXcgcGFzczogY3VzdG9tIHRhZ1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhZ3MgPSB2aWV3LnRhZ3M/LmdldChyZWZbJGNoYW5nZXNdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFncyAmJiB0YWdzLmhhcyh0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFsbG93IGluaGVyaXRlZCBjbGFzc2VzIHRvIGhhdmUgYSBjb25zdHJ1Y3RvclxuICAgICAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gaW5saW5lXG4gICAgICAgICAgICAvLyBTY2hlbWEuaW5pdGlhbGl6ZSh0aGlzKTtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBTY2hlbWEuaW5pdGlhbGl6ZSh0aGlzKTtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBBc3NpZ24gaW5pdGlhbCB2YWx1ZXNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBpZiAoYXJnc1swXSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgYXJnc1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzaWduKHByb3BzKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHByb3BzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAoU2VydmVyLXNpZGUpOiBGbGFnIGEgcHJvcGVydHkgdG8gYmUgZW5jb2RlZCBmb3IgdGhlIG5leHQgcGF0Y2guXG4gICAgICAgICAqIEBwYXJhbSBpbnN0YW5jZSBTY2hlbWEgaW5zdGFuY2VcbiAgICAgICAgICogQHBhcmFtIHByb3BlcnR5IHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHByb3BlcnR5IG5hbWUsIG9yIG51bWJlciByZXByZXNlbnRpbmcgdGhlIGluZGV4IG9mIHRoZSBwcm9wZXJ0eS5cbiAgICAgICAgICogQHBhcmFtIG9wZXJhdGlvbiBPUEVSQVRJT04gdG8gcGVyZm9ybSAoZGV0ZWN0ZWQgYXV0b21hdGljYWxseSlcbiAgICAgICAgICovXG4gICAgICAgIHNldERpcnR5KHByb3BlcnR5LCBvcGVyYXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gdGhpcy5jb25zdHJ1Y3RvcltTeW1ib2wubWV0YWRhdGFdO1xuICAgICAgICAgICAgdGhpc1skY2hhbmdlc10uY2hhbmdlKG1ldGFkYXRhW21ldGFkYXRhW3Byb3BlcnR5XV0uaW5kZXgsIG9wZXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgY2xvbmUoKSB7XG4gICAgICAgICAgICBjb25zdCBjbG9uZWQgPSBuZXcgKHRoaXMuY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLmNvbnN0cnVjdG9yW1N5bWJvbC5tZXRhZGF0YV07XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVE9ETzogY2xvbmUgYWxsIHByb3BlcnRpZXMsIG5vdCBvbmx5IGFubm90YXRlZCBvbmVzXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gZm9yIChjb25zdCBmaWVsZCBpbiB0aGlzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkSW5kZXggaW4gbWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zdCBmaWVsZCA9IG1ldGFkYXRhW21ldGFkYXRhW2ZpZWxkSW5kZXhdXS5uYW1lO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gbWV0YWRhdGFbZmllbGRJbmRleF0ubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh0aGlzW2ZpZWxkXSkgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mICh0aGlzW2ZpZWxkXT8uY2xvbmUpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVlcCBjbG9uZVxuICAgICAgICAgICAgICAgICAgICBjbG9uZWRbZmllbGRdID0gdGhpc1tmaWVsZF0uY2xvbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByaW1pdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkW2ZpZWxkXSA9IHRoaXNbZmllbGRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdG9KU09OKCkge1xuICAgICAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHRoaXMuY29uc3RydWN0b3JbU3ltYm9sLm1ldGFkYXRhXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5kZXggaW4gbWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IG1ldGFkYXRhW2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lO1xuICAgICAgICAgICAgICAgIGlmICghZmllbGQuZGVwcmVjYXRlZCAmJiB0aGlzW2ZpZWxkTmFtZV0gIT09IG51bGwgJiYgdHlwZW9mICh0aGlzW2ZpZWxkTmFtZV0pICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtmaWVsZE5hbWVdID0gKHR5cGVvZiAodGhpc1tmaWVsZE5hbWVdWyd0b0pTT04nXSkgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpc1tmaWVsZE5hbWVdWyd0b0pTT04nXSgpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXNbZmllbGROYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGRpc2NhcmRBbGxDaGFuZ2VzKCkge1xuICAgICAgICAgICAgdGhpc1skY2hhbmdlc10uZGlzY2FyZEFsbCgpO1xuICAgICAgICB9XG4gICAgICAgIFskZ2V0QnlJbmRleF0oaW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gdGhpcy5jb25zdHJ1Y3RvcltTeW1ib2wubWV0YWRhdGFdO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbbWV0YWRhdGFbaW5kZXhdLm5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIFskZGVsZXRlQnlJbmRleF0oaW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gdGhpcy5jb25zdHJ1Y3RvcltTeW1ib2wubWV0YWRhdGFdO1xuICAgICAgICAgICAgdGhpc1ttZXRhZGF0YVtpbmRleF0ubmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc3BlY3QgdGhlIGByZWZJZGAgb2YgYWxsIFNjaGVtYSBpbnN0YW5jZXMgaW4gdGhlIHRyZWUuIE9wdGlvbmFsbHkgZGlzcGxheSB0aGUgY29udGVudHMgb2YgdGhlIGluc3RhbmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcmVmIFNjaGVtYSBpbnN0YW5jZVxuICAgICAgICAgKiBAcGFyYW0gc2hvd0NvbnRlbnRzIGRpc3BsYXkgSlNPTiBjb250ZW50cyBvZiB0aGUgaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnNcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBkZWJ1Z1JlZklkcyhyZWYsIHNob3dDb250ZW50cyA9IGZhbHNlLCBsZXZlbCA9IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRzID0gKHNob3dDb250ZW50cykgPyBgIC0gJHtKU09OLnN0cmluZ2lmeShyZWYudG9KU09OKCkpfWAgOiBcIlwiO1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlVHJlZSA9IHJlZlskY2hhbmdlc107XG4gICAgICAgICAgICBjb25zdCByZWZJZCA9IGNoYW5nZVRyZWUucmVmSWQ7XG4gICAgICAgICAgICBsZXQgb3V0cHV0ID0gXCJcIjtcbiAgICAgICAgICAgIG91dHB1dCArPSBgJHtnZXRJbmRlbnQobGV2ZWwpfSR7cmVmLmNvbnN0cnVjdG9yLm5hbWV9IChyZWZJZDogJHtyZWZJZH0pJHtjb250ZW50c31cXG5gO1xuICAgICAgICAgICAgY2hhbmdlVHJlZS5mb3JFYWNoQ2hpbGQoKGNoaWxkQ2hhbmdlVHJlZSkgPT4gb3V0cHV0ICs9IHRoaXMuZGVidWdSZWZJZHMoY2hpbGRDaGFuZ2VUcmVlLnJlZiwgc2hvd0NvbnRlbnRzLCBsZXZlbCArIDEpKTtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgY2hhbmdlcyBvbiBhIFNjaGVtYSBpbnN0YW5jZS5cbiAgICAgICAgICogVGhlIGxpc3Qgb2YgY2hhbmdlcyBpcyBjbGVhcmVkIGFmdGVyIGVhY2ggZW5jb2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaW5zdGFuY2UgU2NoZW1hIGluc3RhbmNlXG4gICAgICAgICAqIEBwYXJhbSBpc0VuY29kZUFsbCBSZXR1cm4gXCJmdWxsIGVuY29kZVwiIGluc3RlYWQgb2YgY3VycmVudCBjaGFuZ2Ugc2V0LlxuICAgICAgICAgKiBAcmV0dXJuc1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRlYnVnQ2hhbmdlcyhpbnN0YW5jZSwgaXNFbmNvZGVBbGwgPSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlVHJlZSA9IGluc3RhbmNlWyRjaGFuZ2VzXTtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZVNldCA9IChpc0VuY29kZUFsbCkgPyBjaGFuZ2VUcmVlLmFsbENoYW5nZXMgOiBjaGFuZ2VUcmVlLmNoYW5nZXM7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VTZXROYW1lID0gKGlzRW5jb2RlQWxsKSA/IFwiYWxsQ2hhbmdlc1wiIDogXCJjaGFuZ2VzXCI7XG4gICAgICAgICAgICBsZXQgb3V0cHV0ID0gYCR7aW5zdGFuY2UuY29uc3RydWN0b3IubmFtZX0gKCR7Y2hhbmdlVHJlZS5yZWZJZH0pIC0+IC4ke2NoYW5nZVNldE5hbWV9OlxcbmA7XG4gICAgICAgICAgICBmdW5jdGlvbiBkdW1wQ2hhbmdlU2V0KGNoYW5nZVNldCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZVNldC5vcGVyYXRpb25zXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIob3AgPT4gb3ApXG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKChpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcGVyYXRpb24gPSBjaGFuZ2VUcmVlLmluZGV4ZWRPcGVyYXRpb25zW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coeyBpbmRleCwgb3BlcmF0aW9uIH0pO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gYC0gWyR7aW5kZXh9XTogJHtleHBvcnRzLk9QRVJBVElPTltvcGVyYXRpb25dfSAoJHtKU09OLnN0cmluZ2lmeShjaGFuZ2VUcmVlLmdldFZhbHVlKE51bWJlcihpbmRleCksIGlzRW5jb2RlQWxsKSl9KVxcbmA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkdW1wQ2hhbmdlU2V0KGNoYW5nZVNldCk7XG4gICAgICAgICAgICAvLyBkaXNwbGF5IGZpbHRlcmVkIGNoYW5nZXNcbiAgICAgICAgICAgIGlmICghaXNFbmNvZGVBbGwgJiZcbiAgICAgICAgICAgICAgICBjaGFuZ2VUcmVlLmZpbHRlcmVkQ2hhbmdlcyAmJlxuICAgICAgICAgICAgICAgIChjaGFuZ2VUcmVlLmZpbHRlcmVkQ2hhbmdlcy5vcGVyYXRpb25zKS5maWx0ZXIob3AgPT4gb3ApLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gYCR7aW5zdGFuY2UuY29uc3RydWN0b3IubmFtZX0gKCR7Y2hhbmdlVHJlZS5yZWZJZH0pIC0+IC5maWx0ZXJlZENoYW5nZXM6XFxuYDtcbiAgICAgICAgICAgICAgICBkdW1wQ2hhbmdlU2V0KGNoYW5nZVRyZWUuZmlsdGVyZWRDaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRpc3BsYXkgZmlsdGVyZWQgY2hhbmdlc1xuICAgICAgICAgICAgaWYgKGlzRW5jb2RlQWxsICYmXG4gICAgICAgICAgICAgICAgY2hhbmdlVHJlZS5hbGxGaWx0ZXJlZENoYW5nZXMgJiZcbiAgICAgICAgICAgICAgICAoY2hhbmdlVHJlZS5hbGxGaWx0ZXJlZENoYW5nZXMub3BlcmF0aW9ucykuZmlsdGVyKG9wID0+IG9wKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGAke2luc3RhbmNlLmNvbnN0cnVjdG9yLm5hbWV9ICgke2NoYW5nZVRyZWUucmVmSWR9KSAtPiAuYWxsRmlsdGVyZWRDaGFuZ2VzOlxcbmA7XG4gICAgICAgICAgICAgICAgZHVtcENoYW5nZVNldChjaGFuZ2VUcmVlLmFsbEZpbHRlcmVkQ2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBkZWJ1Z0NoYW5nZXNEZWVwKHJlZiwgY2hhbmdlU2V0TmFtZSA9IFwiY2hhbmdlc1wiKSB7XG4gICAgICAgICAgICBsZXQgb3V0cHV0ID0gXCJcIjtcbiAgICAgICAgICAgIGNvbnN0IHJvb3RDaGFuZ2VUcmVlID0gcmVmWyRjaGFuZ2VzXTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSByb290Q2hhbmdlVHJlZS5yb290O1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlVHJlZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZVJlZklkcyA9IFtdO1xuICAgICAgICAgICAgbGV0IHRvdGFsT3BlcmF0aW9ucyA9IDA7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtyZWZJZCwgY2hhbmdlc10gb2YgT2JqZWN0LmVudHJpZXMocm9vdFtjaGFuZ2VTZXROYW1lXSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VUcmVlID0gcm9vdC5jaGFuZ2VUcmVlc1tyZWZJZF07XG4gICAgICAgICAgICAgICAgbGV0IGluY2x1ZGVDaGFuZ2VUcmVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudENoYW5nZVRyZWVzID0gW107XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudENoYW5nZVRyZWUgPSBjaGFuZ2VUcmVlLnBhcmVudD8uWyRjaGFuZ2VzXTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlVHJlZSA9PT0gcm9vdENoYW5nZVRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZUNoYW5nZVRyZWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBhcmVudENoYW5nZVRyZWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Q2hhbmdlVHJlZXMucHVzaChwYXJlbnRDaGFuZ2VUcmVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRDaGFuZ2VUcmVlLnJlZiA9PT0gcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZUNoYW5nZVRyZWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Q2hhbmdlVHJlZSA9IHBhcmVudENoYW5nZVRyZWUucGFyZW50Py5bJGNoYW5nZXNdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlQ2hhbmdlVHJlZSkge1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZVJlZklkcy5wdXNoKGNoYW5nZVRyZWUucmVmSWQpO1xuICAgICAgICAgICAgICAgICAgICB0b3RhbE9wZXJhdGlvbnMgKz0gT2JqZWN0LmtleXMoY2hhbmdlcykubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VUcmVlcy5zZXQoY2hhbmdlVHJlZSwgcGFyZW50Q2hhbmdlVHJlZXMucmV2ZXJzZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXQgKz0gXCItLS1cXG5cIjtcbiAgICAgICAgICAgIG91dHB1dCArPSBgcm9vdCByZWZJZDogJHtyb290Q2hhbmdlVHJlZS5yZWZJZH1cXG5gO1xuICAgICAgICAgICAgb3V0cHV0ICs9IGBUb3RhbCBpbnN0YW5jZXM6ICR7aW5zdGFuY2VSZWZJZHMubGVuZ3RofSAocmVmSWRzOiAke2luc3RhbmNlUmVmSWRzLmpvaW4oXCIsIFwiKX0pXFxuYDtcbiAgICAgICAgICAgIG91dHB1dCArPSBgVG90YWwgY2hhbmdlczogJHt0b3RhbE9wZXJhdGlvbnN9XFxuYDtcbiAgICAgICAgICAgIG91dHB1dCArPSBcIi0tLVxcblwiO1xuICAgICAgICAgICAgLy8gYmFzZWQgb24gcm9vdC5jaGFuZ2VzLCBkaXNwbGF5IGEgdHJlZSBvZiBjaGFuZ2VzIHRoYXQgaGFzIHRoZSBcInJlZlwiIGluc3RhbmNlIGFzIHBhcmVudFxuICAgICAgICAgICAgY29uc3QgdmlzaXRlZFBhcmVudHMgPSBuZXcgV2Vha1NldCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbY2hhbmdlVHJlZSwgcGFyZW50Q2hhbmdlVHJlZXNdIG9mIGNoYW5nZVRyZWVzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgIHBhcmVudENoYW5nZVRyZWVzLmZvckVhY2goKHBhcmVudENoYW5nZVRyZWUsIGxldmVsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZFBhcmVudHMuaGFzKHBhcmVudENoYW5nZVRyZWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gYCR7Z2V0SW5kZW50KGxldmVsKX0ke3BhcmVudENoYW5nZVRyZWUucmVmLmNvbnN0cnVjdG9yLm5hbWV9IChyZWZJZDogJHtwYXJlbnRDaGFuZ2VUcmVlLnJlZklkfSlcXG5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRlZFBhcmVudHMuYWRkKHBhcmVudENoYW5nZVRyZWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IGNoYW5nZVRyZWUuaW5kZXhlZE9wZXJhdGlvbnM7XG4gICAgICAgICAgICAgICAgY29uc3QgbGV2ZWwgPSBwYXJlbnRDaGFuZ2VUcmVlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZW50ID0gZ2V0SW5kZW50KGxldmVsKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRJbmRleCA9IChsZXZlbCA+IDApID8gYCgke2NoYW5nZVRyZWUucGFyZW50SW5kZXh9KSBgIDogXCJcIjtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gYCR7aW5kZW50fSR7cGFyZW50SW5kZXh9JHtjaGFuZ2VUcmVlLnJlZi5jb25zdHJ1Y3Rvci5uYW1lfSAocmVmSWQ6ICR7Y2hhbmdlVHJlZS5yZWZJZH0pIC0gY2hhbmdlczogJHtPYmplY3Qua2V5cyhjaGFuZ2VzKS5sZW5ndGh9XFxuYDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGluZGV4IGluIGNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gY2hhbmdlc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSBgJHtnZXRJbmRlbnQobGV2ZWwgKyAxKX0ke2V4cG9ydHMuT1BFUkFUSU9OW29wZXJhdGlvbl19OiAke2luZGV4fVxcbmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGAke291dHB1dH1gO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIF9hJDEsIF9iJDE7XG4gICAgY2xhc3MgQ29sbGVjdGlvblNjaGVtYSB7XG4gICAgICAgIHN0YXRpYyB7IHRoaXNbX2EkMV0gPSBlbmNvZGVLZXlWYWx1ZU9wZXJhdGlvbjsgfVxuICAgICAgICBzdGF0aWMgeyB0aGlzW19iJDFdID0gZGVjb2RlS2V5VmFsdWVPcGVyYXRpb247IH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZSBpZiBhIHByb3BlcnR5IG11c3QgYmUgZmlsdGVyZWQuXG4gICAgICAgICAqIC0gSWYgcmV0dXJucyBmYWxzZSwgdGhlIHByb3BlcnR5IGlzIE5PVCBnb2luZyB0byBiZSBlbmNvZGVkLlxuICAgICAgICAgKiAtIElmIHJldHVybnMgdHJ1ZSwgdGhlIHByb3BlcnR5IGlzIGdvaW5nIHRvIGJlIGVuY29kZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEVuY29kaW5nIHdpdGggXCJmaWx0ZXJzXCIgaGFwcGVucyBpbiB0d28gc3RlcHM6XG4gICAgICAgICAqIC0gRmlyc3QsIHRoZSBlbmNvZGVyIGl0ZXJhdGVzIG92ZXIgYWxsIFwibm90IG93bmVkXCIgcHJvcGVydGllcyBhbmQgZW5jb2RlcyB0aGVtLlxuICAgICAgICAgKiAtIFRoZW4sIHRoZSBlbmNvZGVyIGl0ZXJhdGVzIG92ZXIgYWxsIFwib3duZWRcIiBwcm9wZXJ0aWVzIHBlciBpbnN0YW5jZSBhbmQgZW5jb2RlcyB0aGVtLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIFsoX2EkMSA9ICRlbmNvZGVyLCBfYiQxID0gJGRlY29kZXIsICRmaWx0ZXIpXShyZWYsIGluZGV4LCB2aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gKCF2aWV3IHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIChyZWZbJGNoaWxkVHlwZV0pID09PSBcInN0cmluZ1wiIHx8XG4gICAgICAgICAgICAgICAgdmlldy5pc0NoYW5nZVRyZWVWaXNpYmxlKChyZWZbJGdldEJ5SW5kZXhdKGluZGV4KSA/PyByZWYuZGVsZXRlZEl0ZW1zW2luZGV4XSlbJGNoYW5nZXNdKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGlzKHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlWydjb2xsZWN0aW9uJ10gIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdHJ1Y3Rvcihpbml0aWFsVmFsdWVzKSB7XG4gICAgICAgICAgICB0aGlzLiRpdGVtcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuJGluZGV4ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZWRJdGVtcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy4kcmVmSWQgPSAwO1xuICAgICAgICAgICAgdGhpc1skY2hhbmdlc10gPSBuZXcgQ2hhbmdlVHJlZSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXNbJGNoYW5nZXNdLmluZGV4ZXMgPSB7fTtcbiAgICAgICAgICAgIGlmIChpbml0aWFsVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbFZhbHVlcy5mb3JFYWNoKCh2KSA9PiB0aGlzLmFkZCh2KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJGNoaWxkVHlwZSwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBzZXQgXCJpbmRleFwiIGZvciByZWZlcmVuY2UuXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuJHJlZklkKys7XG4gICAgICAgICAgICBjb25zdCBpc1JlZiA9ICh2YWx1ZVskY2hhbmdlc10pICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoaXNSZWYpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVskY2hhbmdlc10uc2V0UGFyZW50KHRoaXMsIHRoaXNbJGNoYW5nZXNdLnJvb3QsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbJGNoYW5nZXNdLmluZGV4ZXNbaW5kZXhdID0gaW5kZXg7XG4gICAgICAgICAgICB0aGlzLiRpbmRleGVzLnNldChpbmRleCwgaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy4kaXRlbXMuc2V0KGluZGV4LCB2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzWyRjaGFuZ2VzXS5jaGFuZ2UoaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGF0KGluZGV4KSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLmtleXMoKSlbaW5kZXhdO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGl0ZW1zLmdldChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVudHJpZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMuZW50cmllcygpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZShpdGVtKSB7XG4gICAgICAgICAgICBjb25zdCBlbnRyaWVzID0gdGhpcy4kaXRlbXMuZW50cmllcygpO1xuICAgICAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICAgICAgbGV0IGVudHJ5O1xuICAgICAgICAgICAgd2hpbGUgKGVudHJ5ID0gZW50cmllcy5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gPT09IGVudHJ5LnZhbHVlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gZW50cnkudmFsdWVbMF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kZWxldGVkSXRlbXNbaW5kZXhdID0gdGhpc1skY2hhbmdlc10uZGVsZXRlKGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuJGluZGV4ZXMuZGVsZXRlKGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRpdGVtcy5kZWxldGUoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyKCkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlVHJlZSA9IHRoaXNbJGNoYW5nZXNdO1xuICAgICAgICAgICAgLy8gZGlzY2FyZCBwcmV2aW91cyBvcGVyYXRpb25zLlxuICAgICAgICAgICAgY2hhbmdlVHJlZS5kaXNjYXJkKHRydWUpO1xuICAgICAgICAgICAgY2hhbmdlVHJlZS5pbmRleGVzID0ge307XG4gICAgICAgICAgICAvLyBjbGVhciBwcmV2aW91cyBpbmRleGVzXG4gICAgICAgICAgICB0aGlzLiRpbmRleGVzLmNsZWFyKCk7XG4gICAgICAgICAgICAvLyBjbGVhciBpdGVtc1xuICAgICAgICAgICAgdGhpcy4kaXRlbXMuY2xlYXIoKTtcbiAgICAgICAgICAgIGNoYW5nZVRyZWUub3BlcmF0aW9uKGV4cG9ydHMuT1BFUkFUSU9OLkNMRUFSKTtcbiAgICAgICAgfVxuICAgICAgICBoYXModmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLnZhbHVlcygpKS5zb21lKCh2KSA9PiB2ID09PSB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yRWFjaChjYWxsYmFja2ZuKSB7XG4gICAgICAgICAgICB0aGlzLiRpdGVtcy5mb3JFYWNoKCh2YWx1ZSwga2V5LCBfKSA9PiBjYWxsYmFja2ZuKHZhbHVlLCBrZXksIHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMudmFsdWVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMuc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvKiogSXRlcmF0b3IgKi9cbiAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMudmFsdWVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0SW5kZXgoaW5kZXgsIGtleSkge1xuICAgICAgICAgICAgdGhpcy4kaW5kZXhlcy5zZXQoaW5kZXgsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0SW5kZXgoaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRpbmRleGVzLmdldChpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgWyRnZXRCeUluZGV4XShpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGl0ZW1zLmdldCh0aGlzLiRpbmRleGVzLmdldChpbmRleCkpO1xuICAgICAgICB9XG4gICAgICAgIFskZGVsZXRlQnlJbmRleF0oaW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMuJGluZGV4ZXMuZ2V0KGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuJGl0ZW1zLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgdGhpcy4kaW5kZXhlcy5kZWxldGUoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIFskb25FbmNvZGVFbmRdKCkge1xuICAgICAgICAgICAgdGhpcy5kZWxldGVkSXRlbXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0b0FycmF5KCkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy4kaXRlbXMudmFsdWVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRvSlNPTigpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goKHR5cGVvZiAodmFsdWVbJ3RvSlNPTiddKSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgICAgICA/IHZhbHVlWyd0b0pTT04nXSgpXG4gICAgICAgICAgICAgICAgICAgIDogdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIC8vXG4gICAgICAgIC8vIERlY29kaW5nIHV0aWxpdGllc1xuICAgICAgICAvL1xuICAgICAgICBjbG9uZShpc0RlY29kaW5nKSB7XG4gICAgICAgICAgICBsZXQgY2xvbmVkO1xuICAgICAgICAgICAgaWYgKGlzRGVjb2RpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBjbGllbnQtc2lkZVxuICAgICAgICAgICAgICAgIGNsb25lZCA9IE9iamVjdC5hc3NpZ24obmV3IENvbGxlY3Rpb25TY2hlbWEoKSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzZXJ2ZXItc2lkZVxuICAgICAgICAgICAgICAgIGNsb25lZCA9IG5ldyBDb2xsZWN0aW9uU2NoZW1hKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVbJGNoYW5nZXNdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZWQuYWRkKHZhbHVlWydjbG9uZSddKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVkLmFkZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXJUeXBlKFwiY29sbGVjdGlvblwiLCB7IGNvbnN0cnVjdG9yOiBDb2xsZWN0aW9uU2NoZW1hLCB9KTtcblxuICAgIHZhciBfYSwgX2I7XG4gICAgY2xhc3MgU2V0U2NoZW1hIHtcbiAgICAgICAgc3RhdGljIHsgdGhpc1tfYV0gPSBlbmNvZGVLZXlWYWx1ZU9wZXJhdGlvbjsgfVxuICAgICAgICBzdGF0aWMgeyB0aGlzW19iXSA9IGRlY29kZUtleVZhbHVlT3BlcmF0aW9uOyB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmUgaWYgYSBwcm9wZXJ0eSBtdXN0IGJlIGZpbHRlcmVkLlxuICAgICAgICAgKiAtIElmIHJldHVybnMgZmFsc2UsIHRoZSBwcm9wZXJ0eSBpcyBOT1QgZ29pbmcgdG8gYmUgZW5jb2RlZC5cbiAgICAgICAgICogLSBJZiByZXR1cm5zIHRydWUsIHRoZSBwcm9wZXJ0eSBpcyBnb2luZyB0byBiZSBlbmNvZGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBFbmNvZGluZyB3aXRoIFwiZmlsdGVyc1wiIGhhcHBlbnMgaW4gdHdvIHN0ZXBzOlxuICAgICAgICAgKiAtIEZpcnN0LCB0aGUgZW5jb2RlciBpdGVyYXRlcyBvdmVyIGFsbCBcIm5vdCBvd25lZFwiIHByb3BlcnRpZXMgYW5kIGVuY29kZXMgdGhlbS5cbiAgICAgICAgICogLSBUaGVuLCB0aGUgZW5jb2RlciBpdGVyYXRlcyBvdmVyIGFsbCBcIm93bmVkXCIgcHJvcGVydGllcyBwZXIgaW5zdGFuY2UgYW5kIGVuY29kZXMgdGhlbS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBbKF9hID0gJGVuY29kZXIsIF9iID0gJGRlY29kZXIsICRmaWx0ZXIpXShyZWYsIGluZGV4LCB2aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gKCF2aWV3IHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIChyZWZbJGNoaWxkVHlwZV0pID09PSBcInN0cmluZ1wiIHx8XG4gICAgICAgICAgICAgICAgdmlldy52aXNpYmxlLmhhcygocmVmWyRnZXRCeUluZGV4XShpbmRleCkgPz8gcmVmLmRlbGV0ZWRJdGVtc1tpbmRleF0pWyRjaGFuZ2VzXSkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBpcyh0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZVsnc2V0J10gIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdHJ1Y3Rvcihpbml0aWFsVmFsdWVzKSB7XG4gICAgICAgICAgICB0aGlzLiRpdGVtcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuJGluZGV4ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZWRJdGVtcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy4kcmVmSWQgPSAwO1xuICAgICAgICAgICAgdGhpc1skY2hhbmdlc10gPSBuZXcgQ2hhbmdlVHJlZSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXNbJGNoYW5nZXNdLmluZGV4ZXMgPSB7fTtcbiAgICAgICAgICAgIGlmIChpbml0aWFsVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbFZhbHVlcy5mb3JFYWNoKCh2KSA9PiB0aGlzLmFkZCh2KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJGNoaWxkVHlwZSwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBpbW1lZGlhdGVsbHkgcmV0dXJuIGZhbHNlIGlmIHZhbHVlIGFscmVhZHkgYWRkZWQuXG4gICAgICAgICAgICBpZiAodGhpcy5oYXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IFwiaW5kZXhcIiBmb3IgcmVmZXJlbmNlLlxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLiRyZWZJZCsrO1xuICAgICAgICAgICAgaWYgKCh2YWx1ZVskY2hhbmdlc10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVskY2hhbmdlc10uc2V0UGFyZW50KHRoaXMsIHRoaXNbJGNoYW5nZXNdLnJvb3QsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IHRoaXNbJGNoYW5nZXNdLmluZGV4ZXNbaW5kZXhdPy5vcCA/PyBleHBvcnRzLk9QRVJBVElPTi5BREQ7XG4gICAgICAgICAgICB0aGlzWyRjaGFuZ2VzXS5pbmRleGVzW2luZGV4XSA9IGluZGV4O1xuICAgICAgICAgICAgdGhpcy4kaW5kZXhlcy5zZXQoaW5kZXgsIGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuJGl0ZW1zLnNldChpbmRleCwgdmFsdWUpO1xuICAgICAgICAgICAgdGhpc1skY2hhbmdlc10uY2hhbmdlKGluZGV4LCBvcGVyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGVudHJpZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMuZW50cmllcygpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZShpdGVtKSB7XG4gICAgICAgICAgICBjb25zdCBlbnRyaWVzID0gdGhpcy4kaXRlbXMuZW50cmllcygpO1xuICAgICAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICAgICAgbGV0IGVudHJ5O1xuICAgICAgICAgICAgd2hpbGUgKGVudHJ5ID0gZW50cmllcy5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gPT09IGVudHJ5LnZhbHVlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gZW50cnkudmFsdWVbMF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kZWxldGVkSXRlbXNbaW5kZXhdID0gdGhpc1skY2hhbmdlc10uZGVsZXRlKGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuJGluZGV4ZXMuZGVsZXRlKGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRpdGVtcy5kZWxldGUoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyKCkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlVHJlZSA9IHRoaXNbJGNoYW5nZXNdO1xuICAgICAgICAgICAgLy8gZGlzY2FyZCBwcmV2aW91cyBvcGVyYXRpb25zLlxuICAgICAgICAgICAgY2hhbmdlVHJlZS5kaXNjYXJkKHRydWUpO1xuICAgICAgICAgICAgY2hhbmdlVHJlZS5pbmRleGVzID0ge307XG4gICAgICAgICAgICAvLyBjbGVhciBwcmV2aW91cyBpbmRleGVzXG4gICAgICAgICAgICB0aGlzLiRpbmRleGVzLmNsZWFyKCk7XG4gICAgICAgICAgICAvLyBjbGVhciBpdGVtc1xuICAgICAgICAgICAgdGhpcy4kaXRlbXMuY2xlYXIoKTtcbiAgICAgICAgICAgIGNoYW5nZVRyZWUub3BlcmF0aW9uKGV4cG9ydHMuT1BFUkFUSU9OLkNMRUFSKTtcbiAgICAgICAgfVxuICAgICAgICBoYXModmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMuJGl0ZW1zLnZhbHVlcygpO1xuICAgICAgICAgICAgbGV0IGhhcyA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGVudHJ5O1xuICAgICAgICAgICAgd2hpbGUgKGVudHJ5ID0gdmFsdWVzLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IGVudHJ5LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoYXM7XG4gICAgICAgIH1cbiAgICAgICAgZm9yRWFjaChjYWxsYmFja2ZuKSB7XG4gICAgICAgICAgICB0aGlzLiRpdGVtcy5mb3JFYWNoKCh2YWx1ZSwga2V5LCBfKSA9PiBjYWxsYmFja2ZuKHZhbHVlLCBrZXksIHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMudmFsdWVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMuc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvKiogSXRlcmF0b3IgKi9cbiAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMudmFsdWVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0SW5kZXgoaW5kZXgsIGtleSkge1xuICAgICAgICAgICAgdGhpcy4kaW5kZXhlcy5zZXQoaW5kZXgsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0SW5kZXgoaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRpbmRleGVzLmdldChpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgWyRnZXRCeUluZGV4XShpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGl0ZW1zLmdldCh0aGlzLiRpbmRleGVzLmdldChpbmRleCkpO1xuICAgICAgICB9XG4gICAgICAgIFskZGVsZXRlQnlJbmRleF0oaW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMuJGluZGV4ZXMuZ2V0KGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuJGl0ZW1zLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgdGhpcy4kaW5kZXhlcy5kZWxldGUoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIFskb25FbmNvZGVFbmRdKCkge1xuICAgICAgICAgICAgdGhpcy5kZWxldGVkSXRlbXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0b0FycmF5KCkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy4kaXRlbXMudmFsdWVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRvSlNPTigpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goKHR5cGVvZiAodmFsdWVbJ3RvSlNPTiddKSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgICAgICA/IHZhbHVlWyd0b0pTT04nXSgpXG4gICAgICAgICAgICAgICAgICAgIDogdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIC8vXG4gICAgICAgIC8vIERlY29kaW5nIHV0aWxpdGllc1xuICAgICAgICAvL1xuICAgICAgICBjbG9uZShpc0RlY29kaW5nKSB7XG4gICAgICAgICAgICBsZXQgY2xvbmVkO1xuICAgICAgICAgICAgaWYgKGlzRGVjb2RpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBjbGllbnQtc2lkZVxuICAgICAgICAgICAgICAgIGNsb25lZCA9IE9iamVjdC5hc3NpZ24obmV3IFNldFNjaGVtYSgpLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHNlcnZlci1zaWRlXG4gICAgICAgICAgICAgICAgY2xvbmVkID0gbmV3IFNldFNjaGVtYSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlWyRjaGFuZ2VzXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVkLmFkZCh2YWx1ZVsnY2xvbmUnXSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lZC5hZGQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZ2lzdGVyVHlwZShcInNldFwiLCB7IGNvbnN0cnVjdG9yOiBTZXRTY2hlbWEgfSk7XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcbiAgICBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxuICAgIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcbiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcbiAgICBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuICAgIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuICAgIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG4gICAgTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuICAgIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuICAgIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4gICAgLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UsIFN1cHByZXNzZWRFcnJvciwgU3ltYm9sLCBJdGVyYXRvciAqL1xyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICAgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICAgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxuICAgIH1cclxuXHJcbiAgICB0eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgICAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgICAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG4gICAgfTtcblxuICAgIGNsYXNzIFJvb3Qge1xuICAgICAgICBjb25zdHJ1Y3Rvcih0eXBlcykge1xuICAgICAgICAgICAgdGhpcy50eXBlcyA9IHR5cGVzO1xuICAgICAgICAgICAgdGhpcy5uZXh0VW5pcXVlSWQgPSAwO1xuICAgICAgICAgICAgdGhpcy5yZWZDb3VudCA9IHt9O1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VUcmVlcyA9IHt9O1xuICAgICAgICAgICAgLy8gYWxsIGNoYW5nZXNcbiAgICAgICAgICAgIHRoaXMuYWxsQ2hhbmdlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5hbGxGaWx0ZXJlZENoYW5nZXMgPSBbXTsgLy8gVE9ETzogZG8gbm90IGluaXRpYWxpemUgaXQgaWYgZmlsdGVycyBhcmUgbm90IHVzZWRcbiAgICAgICAgICAgIC8vIHBlbmRpbmcgY2hhbmdlcyB0byBiZSBlbmNvZGVkXG4gICAgICAgICAgICB0aGlzLmNoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyZWRDaGFuZ2VzID0gW107IC8vIFRPRE86IGRvIG5vdCBpbml0aWFsaXplIGl0IGlmIGZpbHRlcnMgYXJlIG5vdCB1c2VkXG4gICAgICAgIH1cbiAgICAgICAgZ2V0TmV4dFVuaXF1ZUlkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dFVuaXF1ZUlkKys7XG4gICAgICAgIH1cbiAgICAgICAgYWRkKGNoYW5nZVRyZWUpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBtb3ZlIGltcGxlbWVudGF0aW9uIG9mIGBlbnN1cmVSZWZJZGAgdG8gYFJvb3RgIGNsYXNzXG4gICAgICAgICAgICBjaGFuZ2VUcmVlLmVuc3VyZVJlZklkKCk7XG4gICAgICAgICAgICBjb25zdCBpc05ld0NoYW5nZVRyZWUgPSAodGhpcy5jaGFuZ2VUcmVlc1tjaGFuZ2VUcmVlLnJlZklkXSA9PT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGlmIChpc05ld0NoYW5nZVRyZWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVRyZWVzW2NoYW5nZVRyZWUucmVmSWRdID0gY2hhbmdlVHJlZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzUmVmQ291bnQgPSB0aGlzLnJlZkNvdW50W2NoYW5nZVRyZWUucmVmSWRdO1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzUmVmQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gYSBDaGFuZ2VUcmVlIGlzIHJlLWFkZGVkLCBpdCBtZWFucyB0aGF0IGl0IHdhcyBwcmV2aW91c2x5IHJlbW92ZWQuXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byByZS1hZGQgYWxsIGNoYW5nZXMgdG8gdGhlIGBjaGFuZ2VzYCBtYXAuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBjb25zdCBvcHMgPSBjaGFuZ2VUcmVlLmFsbENoYW5nZXMub3BlcmF0aW9ucztcbiAgICAgICAgICAgICAgICBsZXQgbGVuID0gb3BzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlVHJlZS5pbmRleGVkT3BlcmF0aW9uc1tvcHNbbGVuXV0gPSBleHBvcnRzLk9QRVJBVElPTi5BREQ7XG4gICAgICAgICAgICAgICAgICAgIHNldE9wZXJhdGlvbkF0SW5kZXgoY2hhbmdlVHJlZS5jaGFuZ2VzLCBsZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVmQ291bnRbY2hhbmdlVHJlZS5yZWZJZF0gPSAocHJldmlvdXNSZWZDb3VudCB8fCAwKSArIDE7XG4gICAgICAgICAgICByZXR1cm4gaXNOZXdDaGFuZ2VUcmVlO1xuICAgICAgICB9XG4gICAgICAgIHJlbW92ZShjaGFuZ2VUcmVlKSB7XG4gICAgICAgICAgICBjb25zdCByZWZDb3VudCA9ICh0aGlzLnJlZkNvdW50W2NoYW5nZVRyZWUucmVmSWRdKSAtIDE7XG4gICAgICAgICAgICBpZiAocmVmQ291bnQgPD0gMCkge1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gT25seSByZW1vdmUgXCJyb290XCIgcmVmZXJlbmNlIGlmIGl0J3MgdGhlIGxhc3QgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBjaGFuZ2VUcmVlLnJvb3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2hhbmdlVHJlZXNbY2hhbmdlVHJlZS5yZWZJZF07XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGFuZ2VGcm9tQ2hhbmdlU2V0KFwiYWxsQ2hhbmdlc1wiLCBjaGFuZ2VUcmVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNoYW5nZUZyb21DaGFuZ2VTZXQoXCJjaGFuZ2VzXCIsIGNoYW5nZVRyZWUpO1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VUcmVlLmZpbHRlcmVkQ2hhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNoYW5nZUZyb21DaGFuZ2VTZXQoXCJhbGxGaWx0ZXJlZENoYW5nZXNcIiwgY2hhbmdlVHJlZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2hhbmdlRnJvbUNoYW5nZVNldChcImZpbHRlcmVkQ2hhbmdlc1wiLCBjaGFuZ2VUcmVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZDb3VudFtjaGFuZ2VUcmVlLnJlZklkXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZkNvdW50W2NoYW5nZVRyZWUucmVmSWRdID0gcmVmQ291bnQ7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBXaGVuIGxvc2luZyBhIHJlZmVyZW5jZSB0byBhbiBpbnN0YW5jZSwgaXQgaXMgYmVzdCB0byBtb3ZlIHRoZVxuICAgICAgICAgICAgICAgIC8vIENoYW5nZVRyZWUgdG8gdGhlIGVuZCBvZiB0aGUgZW5jb2RpbmcgcXVldWUuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBUaGlzIHdheSwgYXQgZGVjb2RpbmcgdGltZSwgdGhlIGluc3RhbmNlIHRoYXQgY29udGFpbnMgdGhlXG4gICAgICAgICAgICAgICAgLy8gQ2hhbmdlVHJlZSB3aWxsIGJlIGF2YWlsYWJsZSBiZWZvcmUgdGhlIENoYW5nZVRyZWUgaXRzZWxmLiBJZiB0aGVcbiAgICAgICAgICAgICAgICAvLyBjb250YWluaW5nIGluc3RhbmNlIGlzIG5vdCBhdmFpbGFibGUsIHRoZSBEZWNvZGVyIHdpbGwgdGhyb3dcbiAgICAgICAgICAgICAgICAvLyBcInJlZklkIG5vdCBmb3VuZFwiIGVycm9yLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZVRyZWUuZmlsdGVyZWRDaGFuZ2VzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGFuZ2VGcm9tQ2hhbmdlU2V0KFwiZmlsdGVyZWRDaGFuZ2VzXCIsIGNoYW5nZVRyZWUpO1xuICAgICAgICAgICAgICAgICAgICBlbnF1ZXVlQ2hhbmdlVHJlZSh0aGlzLCBjaGFuZ2VUcmVlLCBcImZpbHRlcmVkQ2hhbmdlc1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2hhbmdlRnJvbUNoYW5nZVNldChcImNoYW5nZXNcIiwgY2hhbmdlVHJlZSk7XG4gICAgICAgICAgICAgICAgICAgIGVucXVldWVDaGFuZ2VUcmVlKHRoaXMsIGNoYW5nZVRyZWUsIFwiY2hhbmdlc1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFuZ2VUcmVlLmZvckVhY2hDaGlsZCgoY2hpbGQsIF8pID0+IHRoaXMucmVtb3ZlKGNoaWxkKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVmQ291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlQ2hhbmdlRnJvbUNoYW5nZVNldChjaGFuZ2VTZXROYW1lLCBjaGFuZ2VUcmVlKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VTZXQgPSB0aGlzW2NoYW5nZVNldE5hbWVdO1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlU2V0SW5kZXggPSBjaGFuZ2VTZXQuaW5kZXhPZihjaGFuZ2VUcmVlKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VTZXRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VUcmVlW2NoYW5nZVNldE5hbWVdLnF1ZXVlUm9vdEluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgY2hhbmdlU2V0W2NoYW5nZVNldEluZGV4XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIChzcGxpY2VPbmUoY2hhbmdlU2V0LCBjaGFuZ2VTZXQuaW5kZXhPZihjaGFuZ2VUcmVlKSkpIHtcbiAgICAgICAgICAgIC8vICAgICBjaGFuZ2VUcmVlW2NoYW5nZVNldE5hbWVdLnF1ZXVlUm9vdEluZGV4ID0gLTE7XG4gICAgICAgICAgICAvLyAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXIoKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZXMubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzIEVuY29kZXIge1xuICAgICAgICBzdGF0aWMgeyB0aGlzLkJVRkZFUl9TSVpFID0gKHR5cGVvZiAoQnVmZmVyKSAhPT0gXCJ1bmRlZmluZWRcIikgJiYgQnVmZmVyLnBvb2xTaXplIHx8IDggKiAxMDI0OyB9IC8vIDhLQlxuICAgICAgICBjb25zdHJ1Y3RvcihzdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5zaGFyZWRCdWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoRW5jb2Rlci5CVUZGRVJfU0laRSk7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVXNlIC5jYWNoZSgpIGhlcmUgdG8gYXZvaWQgcmUtY3JlYXRpbmcgYSBuZXcgY29udGV4dCBmb3IgZXZlcnkgbmV3IHJvb20gaW5zdGFuY2UuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gV2UgbWF5IG5lZWQgdG8gbWFrZSB0aGlzIG9wdGlvbmFsIGluIGNhc2Ugb2YgZHluYW1pY2FsbHkgY3JlYXRlZFxuICAgICAgICAgICAgLy8gc2NoZW1hcyAtIHdoaWNoIHdvdWxkIGxlYWQgdG8gbWVtb3J5IGxlYWtzXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gVHlwZUNvbnRleHQuY2FjaGUoc3RhdGUuY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgdGhpcy5yb290ID0gbmV3IFJvb3QodGhpcy5jb250ZXh0KTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoc3RhdGUpO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCI+Pj4+Pj4+Pj4+Pj4+Pj4+IEVuY29kZXIgdHlwZXNcIik7XG4gICAgICAgICAgICAvLyB0aGlzLmNvbnRleHQuc2NoZW1hcy5mb3JFYWNoKChpZCwgc2NoZW1hKSA9PiB7XG4gICAgICAgICAgICAvLyAgICAgY29uc29sZS5sb2coXCJ0eXBlOlwiLCBpZCwgc2NoZW1hLm5hbWUsIE9iamVjdC5rZXlzKHNjaGVtYVtTeW1ib2wubWV0YWRhdGFdKSk7XG4gICAgICAgICAgICAvLyB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRTdGF0ZShzdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZVskY2hhbmdlc10uc2V0Um9vdCh0aGlzLnJvb3QpO1xuICAgICAgICB9XG4gICAgICAgIGVuY29kZShpdCA9IHsgb2Zmc2V0OiAwIH0sIHZpZXcsIGJ1ZmZlciA9IHRoaXMuc2hhcmVkQnVmZmVyLCBjaGFuZ2VTZXROYW1lID0gXCJjaGFuZ2VzXCIsIGlzRW5jb2RlQWxsID0gY2hhbmdlU2V0TmFtZSA9PT0gXCJhbGxDaGFuZ2VzXCIsIGluaXRpYWxPZmZzZXQgPSBpdC5vZmZzZXQgLy8gY2FjaGUgY3VycmVudCBvZmZzZXQgaW4gY2FzZSB3ZSBuZWVkIHRvIHJlc2l6ZSB0aGUgYnVmZmVyXG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uc3QgaGFzVmlldyA9ICh2aWV3ICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdENoYW5nZVRyZWUgPSB0aGlzLnN0YXRlWyRjaGFuZ2VzXTtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZVRyZWVzID0gdGhpcy5yb290W2NoYW5nZVNldE5hbWVdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG51bUNoYW5nZVRyZWVzID0gY2hhbmdlVHJlZXMubGVuZ3RoOyBpIDwgbnVtQ2hhbmdlVHJlZXM7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZVRyZWUgPSBjaGFuZ2VUcmVlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoYW5nZVRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYXNWaWV3KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmlldy5pc0NoYW5nZVRyZWVWaXNpYmxlKGNoYW5nZVRyZWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIk1BUksgQVMgSU5WSVNJQkxFOlwiLCB7IHJlZjogY2hhbmdlVHJlZS5yZWYuY29uc3RydWN0b3IubmFtZSwgcmVmSWQ6IGNoYW5nZVRyZWUucmVmSWQsIHJhdzogY2hhbmdlVHJlZS5yZWYudG9KU09OKCkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmludmlzaWJsZS5hZGQoY2hhbmdlVHJlZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gc2tpcCB0aGlzIGNoYW5nZSB0cmVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmlldy5pbnZpc2libGUuZGVsZXRlKGNoYW5nZVRyZWUpOyAvLyByZW1vdmUgZnJvbSBpbnZpc2libGUgbGlzdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VTZXQgPSBjaGFuZ2VUcmVlW2NoYW5nZVNldE5hbWVdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IGNoYW5nZVRyZWUucmVmO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGF2b2lkIGl0ZXJhdGluZyBvdmVyIGNoYW5nZSB0cmVlIGlmIG5vIGNoYW5nZXMgd2VyZSBtYWRlXG4gICAgICAgICAgICAgICAgY29uc3QgbnVtQ2hhbmdlcyA9IGNoYW5nZVNldC5vcGVyYXRpb25zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobnVtQ2hhbmdlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY3RvciA9IHJlZi5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gY3RvclskZW5jb2Rlcl07XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyID0gY3RvclskZmlsdGVyXTtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGN0b3JbU3ltYm9sLm1ldGFkYXRhXTtcbiAgICAgICAgICAgICAgICAvLyBza2lwIHJvb3QgYHJlZklkYCBpZiBpdCdzIHRoZSBmaXJzdCBjaGFuZ2UgdHJlZVxuICAgICAgICAgICAgICAgIC8vICh1bmxlc3MgaXQgXCJoYXNWaWV3XCIsIHdoaWNoIHdpbGwgbmVlZCB0byByZXZpc2l0IHRoZSByb290KVxuICAgICAgICAgICAgICAgIGlmIChoYXNWaWV3IHx8IGl0Lm9mZnNldCA+IGluaXRpYWxPZmZzZXQgfHwgY2hhbmdlVHJlZSAhPT0gcm9vdENoYW5nZVRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2l0Lm9mZnNldCsrXSA9IFNXSVRDSF9UT19TVFJVQ1RVUkUgJiAyNTU7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kZS5udW1iZXIoYnVmZmVyLCBjaGFuZ2VUcmVlLnJlZklkLCBpdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtQ2hhbmdlczsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkSW5kZXggPSBjaGFuZ2VTZXQub3BlcmF0aW9uc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gKGZpZWxkSW5kZXggPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBNYXRoLmFicyhmaWVsZEluZGV4KSAvLyBcInB1cmVcIiBvcGVyYXRpb24gd2l0aG91dCBmaWVsZEluZGV4IChlLmcuIENMRUFSLCBSRVZFUlNFLCBldGMuKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAoaXNFbmNvZGVBbGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBleHBvcnRzLk9QRVJBVElPTi5BRERcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNoYW5nZVRyZWUuaW5kZXhlZE9wZXJhdGlvbnNbZmllbGRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpcnN0IHBhc3MgKGVuY29kZUFsbCksIGlkZW50aWZ5IFwiZmlsdGVyZWRcIiBvcGVyYXRpb25zIHdpdGhvdXQgZW5jb2RpbmcgdGhlbVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGV5IHdpbGwgYmUgZW5jb2RlZCBwZXIgY2xpZW50LCBiYXNlZCBvbiB0aGVpciB2aWV3LlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBob3cgY2FuIHdlIG9wdGltaXplIGZpbHRlcmluZyBvdXQgXCJlbmNvZGUgYWxsXCIgb3BlcmF0aW9ucz9cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogYXZvaWQgY2hlY2tpbmcgaWYgbm8gdmlldyB0YWdzIHdlcmUgZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRJbmRleCA9PT0gdW5kZWZpbmVkIHx8IG9wZXJhdGlvbiA9PT0gdW5kZWZpbmVkIHx8IChmaWx0ZXIgJiYgIWZpbHRlcihyZWYsIGZpZWxkSW5kZXgsIHZpZXcpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJBREQgQVMgSU5WSVNJQkxFOlwiLCBmaWVsZEluZGV4LCBjaGFuZ2VUcmVlLnJlZi5jb25zdHJ1Y3Rvci5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmlldz8uaW52aXNpYmxlLmFkZChjaGFuZ2VUcmVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVuY29kZXIodGhpcywgYnVmZmVyLCBjaGFuZ2VUcmVlLCBmaWVsZEluZGV4LCBvcGVyYXRpb24sIGl0LCBpc0VuY29kZUFsbCwgaGFzVmlldywgbWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdC5vZmZzZXQgPiBidWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBhc3N1bWUgdGhhdCBuICsgMSBwb29sU2l6ZSB3aWxsIHN1ZmZpY2UgZ2l2ZW4gdGhhdCB3ZSBhcmUgbGlrZWx5IGRvbmUgd2l0aCBlbmNvZGluZyBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgICAgICAgLy8gbXVsdGlwbGVzIG9mIHBvb2xTaXplIGFyZSBmYXN0ZXIgdG8gYWxsb2NhdGUgdGhhbiBhcmJpdHJhcnkgc2l6ZXNcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhcmUgb24gYW4gb2xkZXIgcGxhdGZvcm0gdGhhdCBkb2Vzbid0IGltcGxlbWVudCBwb29saW5nIHVzZSA4a2IgYXMgcG9vbFNpemUgKHRoYXQncyB0aGUgZGVmYXVsdCBmb3Igbm9kZSlcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdTaXplID0gTWF0aC5jZWlsKGl0Lm9mZnNldCAvIChCdWZmZXIucG9vbFNpemUgPz8gOCAqIDEwMjQpKSAqIChCdWZmZXIucG9vbFNpemUgPz8gOCAqIDEwMjQpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQGNvbHlzZXVzL3NjaGVtYSBidWZmZXIgb3ZlcmZsb3cuIEVuY29kZWQgc3RhdGUgaXMgaGlnaGVyIHRoYW4gZGVmYXVsdCBCVUZGRVJfU0laRS4gVXNlIHRoZSBmb2xsb3dpbmcgdG8gaW5jcmVhc2UgZGVmYXVsdCBCVUZGRVJfU0laRTpcblxuICAgIGltcG9ydCB7IEVuY29kZXIgfSBmcm9tIFwiQGNvbHlzZXVzL3NjaGVtYVwiO1xuICAgIEVuY29kZXIuQlVGRkVSX1NJWkUgPSAke01hdGgucm91bmQobmV3U2l6ZSAvIDEwMjQpfSAqIDEwMjQ7IC8vICR7TWF0aC5yb3VuZChuZXdTaXplIC8gMTAyNCl9IEtCXG5gKTtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIHJlc2l6ZSBidWZmZXIgYW5kIHJlLWVuY29kZSAoVE9ETzogY2FuIHdlIGF2b2lkIHJlLWVuY29kaW5nIGhlcmU/KVxuICAgICAgICAgICAgICAgIC8vIC0+IE5vIHdlIHByb2JhYmx5IGNhbid0IHVubGVzcyB3ZSBjYXRjaCB0aGUgbmVlZCBmb3IgcmVzaXplIGJlZm9yZSBlbmNvZGluZyB3aGljaCBpcyBsaWtlbHkgbW9yZSBjb21wdXRhdGlvbmFsbHkgZXhwZW5zaXZlIHRoYW4gcmVzaXppbmcgb24gZGVtYW5kXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBidWZmZXIgPSBCdWZmZXIuYWxsb2MobmV3U2l6ZSwgYnVmZmVyKTsgLy8gZmlsbCB3aXRoIGJ1ZmZlciBoZXJlIHRvIG1lbWNweSBwcmV2aW91cyBlbmNvZGluZyBzdGVwcyBiZXlvbmQgdGhlIGluaXRpYWxPZmZzZXRcbiAgICAgICAgICAgICAgICAvLyBhc3NpZ24gcmVzaXplZCBidWZmZXIgdG8gbG9jYWwgc2hhcmVkQnVmZmVyXG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlciA9PT0gdGhpcy5zaGFyZWRCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaGFyZWRCdWZmZXIgPSBidWZmZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZSh7IG9mZnNldDogaW5pdGlhbE9mZnNldCB9LCB2aWV3LCBidWZmZXIsIGNoYW5nZVNldE5hbWUsIGlzRW5jb2RlQWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIuc3ViYXJyYXkoMCwgaXQub2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbmNvZGVBbGwoaXQgPSB7IG9mZnNldDogMCB9LCBidWZmZXIgPSB0aGlzLnNoYXJlZEJ1ZmZlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKGl0LCB1bmRlZmluZWQsIGJ1ZmZlciwgXCJhbGxDaGFuZ2VzXCIsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVuY29kZUFsbFZpZXcodmlldywgc2hhcmVkT2Zmc2V0LCBpdCwgYnl0ZXMgPSB0aGlzLnNoYXJlZEJ1ZmZlcikge1xuICAgICAgICAgICAgY29uc3Qgdmlld09mZnNldCA9IGl0Lm9mZnNldDtcbiAgICAgICAgICAgIC8vIHRyeSB0byBlbmNvZGUgXCJmaWx0ZXJlZFwiIGNoYW5nZXNcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlKGl0LCB2aWV3LCBieXRlcywgXCJhbGxGaWx0ZXJlZENoYW5nZXNcIiwgdHJ1ZSwgdmlld09mZnNldCk7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgYnl0ZXMuc3ViYXJyYXkoMCwgc2hhcmVkT2Zmc2V0KSxcbiAgICAgICAgICAgICAgICBieXRlcy5zdWJhcnJheSh2aWV3T2Zmc2V0LCBpdC5vZmZzZXQpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1Z0NoYW5nZXMoZmllbGQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3RDaGFuZ2VTZXQgPSAodHlwZW9mIChmaWVsZCkgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgPyB0aGlzLnJvb3RbZmllbGRdXG4gICAgICAgICAgICAgICAgOiBmaWVsZDtcbiAgICAgICAgICAgIHJvb3RDaGFuZ2VTZXQuZm9yRWFjaCgoY2hhbmdlVHJlZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZVNldCA9IGNoYW5nZVRyZWVbZmllbGRdO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gY2hhbmdlVHJlZS5yZWYuY29uc3RydWN0b3JbU3ltYm9sLm1ldGFkYXRhXTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIi0+XCIsIHsgcmVmOiBjaGFuZ2VUcmVlLnJlZi5jb25zdHJ1Y3Rvci5uYW1lLCByZWZJZDogY2hhbmdlVHJlZS5yZWZJZCwgY2hhbmdlczogT2JqZWN0LmtleXMoY2hhbmdlU2V0KS5sZW5ndGggfSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpbmRleCBpbiBjaGFuZ2VTZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3AgPSBjaGFuZ2VTZXRbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIiAgLT5cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogbWV0YWRhdGE/LltpbmRleF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvcDogZXhwb3J0cy5PUEVSQVRJT05bb3BdLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGVWaWV3KHZpZXcsIHNoYXJlZE9mZnNldCwgaXQsIGJ5dGVzID0gdGhpcy5zaGFyZWRCdWZmZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZXdPZmZzZXQgPSBpdC5vZmZzZXQ7XG4gICAgICAgICAgICAvLyBlbmNvZGUgdmlzaWJpbGl0eSBjaGFuZ2VzIChhZGQvcmVtb3ZlIGZvciB0aGlzIHZpZXcpXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtyZWZJZCwgY2hhbmdlc10gb2Ygdmlldy5jaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlVHJlZSA9IHRoaXMucm9vdC5jaGFuZ2VUcmVlc1tyZWZJZF07XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZVRyZWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZXRhY2hlZCBpbnN0YW5jZSwgcmVtb3ZlIGZyb20gdmlldyBhbmQgc2tpcC5cbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJkZXRhY2hlZCBpbnN0YW5jZSwgcmVtb3ZlIGZyb20gdmlldyBhbmQgc2tpcC5cIiwgcmVmSWQpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmNoYW5nZXMuZGVsZXRlKHJlZklkKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IGF2b2lkIGhhdmluZyBlbXB0eSBjaGFuZ2VzIGlmIG5vIGNoYW5nZXMgd2VyZSBtYWRlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiY2hhbmdlcy5zaXplID09PSAwLCBza2lwXCIsIHJlZklkLCBjaGFuZ2VUcmVlLnJlZi5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IGNoYW5nZVRyZWUucmVmO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN0b3IgPSByZWYuY29uc3RydWN0b3I7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5jb2RlciA9IGN0b3JbJGVuY29kZXJdO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gY3RvcltTeW1ib2wubWV0YWRhdGFdO1xuICAgICAgICAgICAgICAgIGJ5dGVzW2l0Lm9mZnNldCsrXSA9IFNXSVRDSF9UT19TVFJVQ1RVUkUgJiAyNTU7XG4gICAgICAgICAgICAgICAgZW5jb2RlLm51bWJlcihieXRlcywgY2hhbmdlVHJlZS5yZWZJZCwgaXQpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBudW1DaGFuZ2VzID0ga2V5cy5sZW5ndGg7IGkgPCBudW1DaGFuZ2VzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBOdW1iZXIoa2V5c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdvcmthcm91bmQgd2hlbiB1c2luZyB2aWV3LmFkZCgpIG9uIGl0ZW0gdGhhdCBoYXMgYmVlbiBkZWxldGVkIGZyb20gc3RhdGUgKHNlZSB0ZXN0IFwiYWRkaW5nIHRvIHZpZXcgaXRlbSB0aGF0IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSBzdGF0ZVwiKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNoYW5nZVRyZWUucmVmWyRnZXRCeUluZGV4XShpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9ICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIGNoYW5nZXNbaW5kZXhdKSB8fCBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEU7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlzRW5jb2RlQWxsID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFzVmlldyA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgZW5jb2Rlcih0aGlzLCBieXRlcywgY2hhbmdlVHJlZSwgaW5kZXgsIG9wZXJhdGlvbiwgaXQsIGZhbHNlLCB0cnVlLCBtZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRPRE86IG9ubHkgY2xlYXIgdmlldyBjaGFuZ2VzIGFmdGVyIGFsbCB2aWV3cyBhcmUgZW5jb2RlZFxuICAgICAgICAgICAgLy8gKHRvIGFsbG93IHJlLXVzaW5nIFN0YXRlVmlldydzIGZvciBtdWx0aXBsZSBjbGllbnRzKVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGNsZWFyIFwidmlld1wiIGNoYW5nZXMgYWZ0ZXIgZW5jb2RpbmdcbiAgICAgICAgICAgIHZpZXcuY2hhbmdlcy5jbGVhcigpO1xuICAgICAgICAgICAgLy8gdHJ5IHRvIGVuY29kZSBcImZpbHRlcmVkXCIgY2hhbmdlc1xuICAgICAgICAgICAgdGhpcy5lbmNvZGUoaXQsIHZpZXcsIGJ5dGVzLCBcImZpbHRlcmVkQ2hhbmdlc1wiLCBmYWxzZSwgdmlld09mZnNldCk7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgYnl0ZXMuc3ViYXJyYXkoMCwgc2hhcmVkT2Zmc2V0KSxcbiAgICAgICAgICAgICAgICBieXRlcy5zdWJhcnJheSh2aWV3T2Zmc2V0LCBpdC5vZmZzZXQpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICBkaXNjYXJkQ2hhbmdlcygpIHtcbiAgICAgICAgICAgIC8vIGRpc2NhcmQgc2hhcmVkIGNoYW5nZXNcbiAgICAgICAgICAgIGxldCBsZW5ndGggPSB0aGlzLnJvb3QuY2hhbmdlcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb3QuY2hhbmdlc1tsZW5ndGhdPy5lbmRFbmNvZGUoJ2NoYW5nZXMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yb290LmNoYW5nZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRpc2NhcmQgZmlsdGVyZWQgY2hhbmdlc1xuICAgICAgICAgICAgbGVuZ3RoID0gdGhpcy5yb290LmZpbHRlcmVkQ2hhbmdlcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb3QuZmlsdGVyZWRDaGFuZ2VzW2xlbmd0aF0/LmVuZEVuY29kZSgnZmlsdGVyZWRDaGFuZ2VzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucm9vdC5maWx0ZXJlZENoYW5nZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cnlFbmNvZGVUeXBlSWQoYnl0ZXMsIGJhc2VUeXBlLCB0YXJnZXRUeXBlLCBpdCkge1xuICAgICAgICAgICAgY29uc3QgYmFzZVR5cGVJZCA9IHRoaXMuY29udGV4dC5nZXRUeXBlSWQoYmFzZVR5cGUpO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0VHlwZUlkID0gdGhpcy5jb250ZXh0LmdldFR5cGVJZCh0YXJnZXRUeXBlKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXRUeXBlSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQGNvbHlzZXVzL3NjaGVtYSBXQVJOSU5HOiBDbGFzcyBcIiR7dGFyZ2V0VHlwZS5uYW1lfVwiIGlzIG5vdCByZWdpc3RlcmVkIG9uIFR5cGVSZWdpc3RyeSAtIFBsZWFzZSBlaXRoZXIgdGFnIHRoZSBjbGFzcyB3aXRoIEBlbnRpdHkgb3IgZGVmaW5lIGEgQHR5cGUoKSBmaWVsZC5gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmFzZVR5cGVJZCAhPT0gdGFyZ2V0VHlwZUlkKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXNbaXQub2Zmc2V0KytdID0gVFlQRV9JRCAmIDI1NTtcbiAgICAgICAgICAgICAgICBlbmNvZGUubnVtYmVyKGJ5dGVzLCB0YXJnZXRUeXBlSWQsIGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZXQgaGFzQ2hhbmdlcygpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5yb290LmNoYW5nZXMubGVuZ3RoID4gMCB8fFxuICAgICAgICAgICAgICAgIHRoaXMucm9vdC5maWx0ZXJlZENoYW5nZXMubGVuZ3RoID4gMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzcGxpY2VPbmUoYXJyLCBpbmRleCkge1xuICAgICAgICAvLyBtYW51YWxseSBzcGxpY2UgYW4gYXJyYXlcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSB8fCBpbmRleCA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgICAgIGZvciAobGV0IGkgPSBpbmRleDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBhcnJbaV0gPSBhcnJbaSArIDFdO1xuICAgICAgICB9XG4gICAgICAgIGFyci5sZW5ndGggPSBsZW47XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGNsYXNzIERlY29kaW5nV2FybmluZyBleHRlbmRzIEVycm9yIHtcbiAgICAgICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBcIkRlY29kaW5nV2FybmluZ1wiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsYXNzIFJlZmVyZW5jZVRyYWNrZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBSZWxhdGlvbiBvZiByZWZJZCA9PiBTY2hlbWEgc3RydWN0dXJlXG4gICAgICAgICAgICAvLyBGb3IgZGlyZWN0IGFjY2VzcyBvZiBzdHJ1Y3R1cmVzIGR1cmluZyBkZWNvZGluZyB0aW1lLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHRoaXMucmVmcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMucmVmSWRzID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgICAgIHRoaXMucmVmQ291bnRzID0ge307XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZWRSZWZzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MgPSB7fTtcbiAgICAgICAgICAgIHRoaXMubmV4dFVuaXF1ZUlkID0gMDtcbiAgICAgICAgfVxuICAgICAgICBnZXROZXh0VW5pcXVlSWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZXh0VW5pcXVlSWQrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBmb3IgZGVjb2RpbmdcbiAgICAgICAgYWRkUmVmKHJlZklkLCByZWYsIGluY3JlbWVudENvdW50ID0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5yZWZzLnNldChyZWZJZCwgcmVmKTtcbiAgICAgICAgICAgIHRoaXMucmVmSWRzLnNldChyZWYsIHJlZklkKTtcbiAgICAgICAgICAgIGlmIChpbmNyZW1lbnRDb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVmQ291bnRzW3JlZklkXSA9ICh0aGlzLnJlZkNvdW50c1tyZWZJZF0gfHwgMCkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZGVsZXRlZFJlZnMuaGFzKHJlZklkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlZFJlZnMuZGVsZXRlKHJlZklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBmb3IgZGVjb2RpbmdcbiAgICAgICAgcmVtb3ZlUmVmKHJlZklkKSB7XG4gICAgICAgICAgICBjb25zdCByZWZDb3VudCA9IHRoaXMucmVmQ291bnRzW3JlZklkXTtcbiAgICAgICAgICAgIGlmIChyZWZDb3VudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IERlY29kaW5nV2FybmluZyhcInRyeWluZyB0byByZW1vdmUgcmVmSWQgdGhhdCBkb2Vzbid0IGV4aXN0OiBcIiArIHJlZklkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVmQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWYgPSB0aGlzLnJlZnMuZ2V0KHJlZklkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IERlY29kaW5nV2FybmluZyhgdHJ5aW5nIHRvIHJlbW92ZSByZWZJZCAnJHtyZWZJZH0nIHdpdGggMCByZWZDb3VudCAoJHtyZWYuY29uc3RydWN0b3IubmFtZX06ICR7SlNPTi5zdHJpbmdpZnkocmVmKX0pYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0aGlzLnJlZkNvdW50c1tyZWZJZF0gPSByZWZDb3VudCAtIDEpIDw9IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZWRSZWZzLmFkZChyZWZJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJSZWZzKCkge1xuICAgICAgICAgICAgdGhpcy5yZWZzLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZWRSZWZzLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5yZWZDb3VudHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmb3IgZGVjb2RpbmdcbiAgICAgICAgZ2FyYmFnZUNvbGxlY3REZWxldGVkUmVmcygpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlZFJlZnMuZm9yRWFjaCgocmVmSWQpID0+IHtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFNraXAgYWN0aXZlIHJlZmVyZW5jZXMuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWZDb3VudHNbcmVmSWRdID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IHRoaXMucmVmcy5nZXQocmVmSWQpO1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIGNoaWxkIHNjaGVtYSBpbnN0YW5jZXMgaGF2ZSB0aGVpciByZWZlcmVuY2VzIHJlbW92ZWQgYXMgd2VsbC5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGlmIChyZWYuY29uc3RydWN0b3JbU3ltYm9sLm1ldGFkYXRhXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gcmVmLmNvbnN0cnVjdG9yW1N5bWJvbC5tZXRhZGF0YV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaW5kZXggaW4gbWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gbWV0YWRhdGFbaW5kZXhdLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZFJlZklkID0gdHlwZW9mIChyZWZbZmllbGRdKSA9PT0gXCJvYmplY3RcIiAmJiB0aGlzLnJlZklkcy5nZXQocmVmW2ZpZWxkXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRSZWZJZCAmJiAhdGhpcy5kZWxldGVkUmVmcy5oYXMoY2hpbGRSZWZJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVJlZihjaGlsZFJlZklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocmVmWyRjaGlsZFR5cGVdKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5mcm9tKHJlZi52YWx1ZXMoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZFJlZklkID0gdGhpcy5yZWZJZHMuZ2V0KGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGVsZXRlZFJlZnMuaGFzKGNoaWxkUmVmSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlUmVmKGNoaWxkUmVmSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVmcy5kZWxldGUocmVmSWQpOyAvLyByZW1vdmUgcmVmXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucmVmQ291bnRzW3JlZklkXTsgLy8gcmVtb3ZlIHJlZiBjb3VudFxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrc1tyZWZJZF07IC8vIHJlbW92ZSBjYWxsYmFja3NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gY2xlYXIgZGVsZXRlZCByZWZzLlxuICAgICAgICAgICAgdGhpcy5kZWxldGVkUmVmcy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIGFkZENhbGxiYWNrKHJlZklkLCBmaWVsZE9yT3BlcmF0aW9uLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHJlZklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gKHR5cGVvZiAoZmllbGRPck9wZXJhdGlvbikgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgID8gZXhwb3J0cy5PUEVSQVRJT05bZmllbGRPck9wZXJhdGlvbl1cbiAgICAgICAgICAgICAgICAgICAgOiBmaWVsZE9yT3BlcmF0aW9uO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgYWRkQ2FsbGJhY2sgb24gJyR7bmFtZX0nIChyZWZJZCBpcyB1bmRlZmluZWQpYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2FsbGJhY2tzW3JlZklkXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzW3JlZklkXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmNhbGxiYWNrc1tyZWZJZF1bZmllbGRPck9wZXJhdGlvbl0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrc1tyZWZJZF1bZmllbGRPck9wZXJhdGlvbl0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzW3JlZklkXVtmaWVsZE9yT3BlcmF0aW9uXS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB0aGlzLnJlbW92ZUNhbGxiYWNrKHJlZklkLCBmaWVsZE9yT3BlcmF0aW9uLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlQ2FsbGJhY2socmVmSWQsIGZpZWxkLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmNhbGxiYWNrcz8uW3JlZklkXT8uW2ZpZWxkXT8uaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc3BsaWNlT25lKHRoaXMuY2FsbGJhY2tzW3JlZklkXVtmaWVsZF0sIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzIERlY29kZXIge1xuICAgICAgICBjb25zdHJ1Y3Rvcihyb290LCBjb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSZWZJZCA9IDA7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHJvb3QpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dCB8fCBuZXcgVHlwZUNvbnRleHQocm9vdC5jb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIj4+Pj4+Pj4+Pj4+Pj4+Pj4gRGVjb2RlciB0eXBlc1wiKTtcbiAgICAgICAgICAgIC8vIHRoaXMuY29udGV4dC5zY2hlbWFzLmZvckVhY2goKGlkLCBzY2hlbWEpID0+IHtcbiAgICAgICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhcInR5cGU6XCIsIGlkLCBzY2hlbWEubmFtZSwgT2JqZWN0LmtleXMoc2NoZW1hW1N5bWJvbC5tZXRhZGF0YV0pKTtcbiAgICAgICAgICAgIC8vIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFN0YXRlKHJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSByb290O1xuICAgICAgICAgICAgdGhpcy5yb290ID0gbmV3IFJlZmVyZW5jZVRyYWNrZXIoKTtcbiAgICAgICAgICAgIHRoaXMucm9vdC5hZGRSZWYoMCwgcm9vdCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlKGJ5dGVzLCBpdCA9IHsgb2Zmc2V0OiAwIH0sIHJlZiA9IHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGFsbENoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0ICRyb290ID0gdGhpcy5yb290O1xuICAgICAgICAgICAgY29uc3QgdG90YWxCeXRlcyA9IGJ5dGVzLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBsZXQgZGVjb2RlciA9IHJlZlsnY29uc3RydWN0b3InXVskZGVjb2Rlcl07XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSZWZJZCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoaXQub2Zmc2V0IDwgdG90YWxCeXRlcykge1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gUGVlayBhaGVhZCwgY2hlY2sgaWYgaXQncyBhIHN3aXRjaCB0byBhIGRpZmZlcmVudCBzdHJ1Y3R1cmVcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGlmIChieXRlc1tpdC5vZmZzZXRdID09IFNXSVRDSF9UT19TVFJVQ1RVUkUpIHtcbiAgICAgICAgICAgICAgICAgICAgaXQub2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFJlZklkID0gZGVjb2RlLm51bWJlcihieXRlcywgaXQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0UmVmID0gJHJvb3QucmVmcy5nZXQodGhpcy5jdXJyZW50UmVmSWQpO1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBUcnlpbmcgdG8gYWNjZXNzIGEgcmVmZXJlbmNlIHRoYXQgaGF2ZW4ndCBiZWVuIGRlY29kZWQgeWV0LlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5leHRSZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCJyZWZJZFwiIG5vdCBmb3VuZDogJHt0aGlzLmN1cnJlbnRSZWZJZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZWZbJG9uRGVjb2RlRW5kXT8uKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlZiA9IG5leHRSZWY7XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZXIgPSByZWYuY29uc3RydWN0b3JbJGRlY29kZXJdO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZGVjb2Rlcih0aGlzLCBieXRlcywgaXQsIHJlZiwgYWxsQ2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gREVGSU5JVElPTl9NSVNNQVRDSCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJAY29seXNldXMvc2NoZW1hOiBkZWZpbml0aW9uIG1pc21hdGNoXCIpO1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBrZWVwIHNraXBwaW5nIG5leHQgYnl0ZXMgdW50aWwgcmVhY2hlcyBhIGtub3duIHN0cnVjdHVyZVxuICAgICAgICAgICAgICAgICAgICAvLyBieSBsb2NhbCBkZWNvZGVyLlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0SXRlcmF0b3IgPSB7IG9mZnNldDogaXQub2Zmc2V0IH07XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpdC5vZmZzZXQgPCB0b3RhbEJ5dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnl0ZXNbaXQub2Zmc2V0XSA9PT0gU1dJVENIX1RPX1NUUlVDVFVSRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRJdGVyYXRvci5vZmZzZXQgPSBpdC5vZmZzZXQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkcm9vdC5yZWZzLmhhcyhkZWNvZGUubnVtYmVyKGJ5dGVzLCBuZXh0SXRlcmF0b3IpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGSVhNRTogRFJZIHdpdGggU1dJVENIX1RPX1NUUlVDVFVSRSBibG9jay5cbiAgICAgICAgICAgIHJlZlskb25EZWNvZGVFbmRdPy4oKTtcbiAgICAgICAgICAgIC8vIHRyaWdnZXIgY2hhbmdlc1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyQ2hhbmdlcz8uKGFsbENoYW5nZXMpO1xuICAgICAgICAgICAgLy8gZHJvcCByZWZlcmVuY2VzIG9mIHVudXNlZCBzY2hlbWFzXG4gICAgICAgICAgICAkcm9vdC5nYXJiYWdlQ29sbGVjdERlbGV0ZWRSZWZzKCk7XG4gICAgICAgICAgICByZXR1cm4gYWxsQ2hhbmdlcztcbiAgICAgICAgfVxuICAgICAgICBnZXRJbnN0YW5jZVR5cGUoYnl0ZXMsIGl0LCBkZWZhdWx0VHlwZSkge1xuICAgICAgICAgICAgbGV0IHR5cGU7XG4gICAgICAgICAgICBpZiAoYnl0ZXNbaXQub2Zmc2V0XSA9PT0gVFlQRV9JRCkge1xuICAgICAgICAgICAgICAgIGl0Lm9mZnNldCsrO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVfaWQgPSBkZWNvZGUubnVtYmVyKGJ5dGVzLCBpdCk7XG4gICAgICAgICAgICAgICAgdHlwZSA9IHRoaXMuY29udGV4dC5nZXQodHlwZV9pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZSB8fCBkZWZhdWx0VHlwZTtcbiAgICAgICAgfVxuICAgICAgICBjcmVhdGVJbnN0YW5jZU9mVHlwZSh0eXBlKSB7XG4gICAgICAgICAgICAvLyBsZXQgaW5zdGFuY2U6IFNjaGVtYSA9IG5ldyAodHlwZSBhcyBhbnkpKCk7XG4gICAgICAgICAgICAvLyAvLyBhc3NpZ24gcm9vdCBvbiAkY2hhbmdlc1xuICAgICAgICAgICAgLy8gaW5zdGFuY2VbJGNoYW5nZXNdLnJvb3QgPSB0aGlzLnJvb3RbJGNoYW5nZXNdLnJvb3Q7XG4gICAgICAgICAgICAvLyByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHR5cGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZW1vdmVDaGlsZFJlZnMocmVmLCBhbGxDaGFuZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCBuZWVkUmVtb3ZlUmVmID0gdHlwZW9mIChyZWZbJGNoaWxkVHlwZV0pICE9PSBcInN0cmluZ1wiO1xuICAgICAgICAgICAgY29uc3QgcmVmSWQgPSB0aGlzLnJvb3QucmVmSWRzLmdldChyZWYpO1xuICAgICAgICAgICAgcmVmLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBhbGxDaGFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICByZWY6IHJlZixcbiAgICAgICAgICAgICAgICAgICAgcmVmSWQsXG4gICAgICAgICAgICAgICAgICAgIG9wOiBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEUsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBrZXksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWU6IHZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG5lZWRSZW1vdmVSZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290LnJlbW92ZVJlZih0aGlzLnJvb3QucmVmSWRzLmdldCh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVmbGVjdGlvblxuICAgICAqL1xuICAgIGNsYXNzIFJlZmxlY3Rpb25GaWVsZCBleHRlbmRzIFNjaGVtYSB7XG4gICAgfVxuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0eXBlKFwic3RyaW5nXCIpXG4gICAgXSwgUmVmbGVjdGlvbkZpZWxkLnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHR5cGUoXCJzdHJpbmdcIilcbiAgICBdLCBSZWZsZWN0aW9uRmllbGQucHJvdG90eXBlLCBcInR5cGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdHlwZShcIm51bWJlclwiKVxuICAgIF0sIFJlZmxlY3Rpb25GaWVsZC5wcm90b3R5cGUsIFwicmVmZXJlbmNlZFR5cGVcIiwgdm9pZCAwKTtcbiAgICBjbGFzcyBSZWZsZWN0aW9uVHlwZSBleHRlbmRzIFNjaGVtYSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMuZmllbGRzID0gbmV3IEFycmF5U2NoZW1hKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHR5cGUoXCJudW1iZXJcIilcbiAgICBdLCBSZWZsZWN0aW9uVHlwZS5wcm90b3R5cGUsIFwiaWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdHlwZShcIm51bWJlclwiKVxuICAgIF0sIFJlZmxlY3Rpb25UeXBlLnByb3RvdHlwZSwgXCJleHRlbmRzSWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdHlwZShbUmVmbGVjdGlvbkZpZWxkXSlcbiAgICBdLCBSZWZsZWN0aW9uVHlwZS5wcm90b3R5cGUsIFwiZmllbGRzXCIsIHZvaWQgMCk7XG4gICAgY2xhc3MgUmVmbGVjdGlvbiBleHRlbmRzIFNjaGVtYSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMudHlwZXMgPSBuZXcgQXJyYXlTY2hlbWEoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgVHlwZUNvbnRleHQgb2YgYW4gRW5jb2RlciBpbnRvIGEgYnVmZmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZW5jb2RlciBFbmNvZGVyIGluc3RhbmNlXG4gICAgICAgICAqIEBwYXJhbSBpdFxuICAgICAgICAgKiBAcmV0dXJuc1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGVuY29kZShlbmNvZGVyLCBpdCA9IHsgb2Zmc2V0OiAwIH0pIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBlbmNvZGVyLmNvbnRleHQ7XG4gICAgICAgICAgICBjb25zdCByZWZsZWN0aW9uID0gbmV3IFJlZmxlY3Rpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IHJlZmxlY3Rpb25FbmNvZGVyID0gbmV3IEVuY29kZXIocmVmbGVjdGlvbik7XG4gICAgICAgICAgICAvLyByb290VHlwZSBpcyB1c3VhbGx5IHRoZSBmaXJzdCBzY2hlbWEgcGFzc2VkIHRvIHRoZSBFbmNvZGVyXG4gICAgICAgICAgICAvLyAodW5sZXNzIGl0IGluaGVyaXRzIGZyb20gYW5vdGhlciBzY2hlbWEpXG4gICAgICAgICAgICBjb25zdCByb290VHlwZSA9IGNvbnRleHQuc2NoZW1hcy5nZXQoZW5jb2Rlci5zdGF0ZS5jb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICBpZiAocm9vdFR5cGUgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVmbGVjdGlvbi5yb290VHlwZSA9IHJvb3RUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW5jbHVkZWRUeXBlSWRzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgY29uc3QgcGVuZGluZ1JlZmxlY3Rpb25UeXBlcyA9IHt9O1xuICAgICAgICAgICAgLy8gYWRkIHR5cGUgdG8gcmVmbGVjdGlvbiBpbiBhIHdheSB0aGF0IHJlc3BlY3RzIGluaGVyaXRhbmNlXG4gICAgICAgICAgICAvLyAocGFyZW50IHR5cGVzIHNob3VsZCBiZSBhZGRlZCBiZWZvcmUgdGhlaXIgY2hpbGRyZW4pXG4gICAgICAgICAgICBjb25zdCBhZGRUeXBlID0gKHR5cGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5leHRlbmRzSWQgPT09IHVuZGVmaW5lZCB8fCBpbmNsdWRlZFR5cGVJZHMuaGFzKHR5cGUuZXh0ZW5kc0lkKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmNsdWRlZFR5cGVJZHMuYWRkKHR5cGUuaWQpO1xuICAgICAgICAgICAgICAgICAgICByZWZsZWN0aW9uLnR5cGVzLnB1c2godHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlcHMgPSBwZW5kaW5nUmVmbGVjdGlvblR5cGVzW3R5cGUuaWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVwcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGVuZGluZ1JlZmxlY3Rpb25UeXBlc1t0eXBlLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHMuZm9yRWFjaCgoY2hpbGRUeXBlKSA9PiBhZGRUeXBlKGNoaWxkVHlwZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGVuZGluZ1JlZmxlY3Rpb25UeXBlc1t0eXBlLmV4dGVuZHNJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1JlZmxlY3Rpb25UeXBlc1t0eXBlLmV4dGVuZHNJZF0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nUmVmbGVjdGlvblR5cGVzW3R5cGUuZXh0ZW5kc0lkXS5wdXNoKHR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb250ZXh0LnNjaGVtYXMuZm9yRWFjaCgodHlwZWlkLCBrbGFzcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBuZXcgUmVmbGVjdGlvblR5cGUoKTtcbiAgICAgICAgICAgICAgICB0eXBlLmlkID0gTnVtYmVyKHR5cGVpZCk7XG4gICAgICAgICAgICAgICAgLy8gc3VwcG9ydCBpbmhlcml0YW5jZVxuICAgICAgICAgICAgICAgIGNvbnN0IGluaGVyaXRGcm9tID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGtsYXNzKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5oZXJpdEZyb20gIT09IFNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlLmV4dGVuZHNJZCA9IGNvbnRleHQuc2NoZW1hcy5nZXQoaW5oZXJpdEZyb20pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGtsYXNzW1N5bWJvbC5tZXRhZGF0YV07XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogdGhpcyBpcyBhIHdvcmthcm91bmQgZm9yIGluaGVyaXRlZCB0eXBlcyB3aXRob3V0IGFkZGl0aW9uYWwgZmllbGRzXG4gICAgICAgICAgICAgICAgLy8gaWYgbWV0YWRhdGEgaXMgdGhlIHNhbWUgcmVmZXJlbmNlIGFzIHRoZSBwYXJlbnQgY2xhc3MgLSBpdCBtZWFucyB0aGUgY2xhc3MgaGFzIG5vIG93biBtZXRhZGF0YVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhICE9PSBpbmhlcml0RnJvbVtTeW1ib2wubWV0YWRhdGFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZmllbGRJbmRleCBpbiBtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBOdW1iZXIoZmllbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSBtZXRhZGF0YVtpbmRleF0ubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNraXAgZmllbGRzIGZyb20gcGFyZW50IGNsYXNzZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1ldGFkYXRhLCBmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWZsZWN0aW9uRmllbGQgPSBuZXcgUmVmbGVjdGlvbkZpZWxkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZsZWN0aW9uRmllbGQubmFtZSA9IGZpZWxkTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWVsZFR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IG1ldGFkYXRhW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGZpZWxkLnR5cGUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRUeXBlID0gZmllbGQudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjaGlsZFR5cGVTY2hlbWE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiByZWZhY3RvciBiZWxvdy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTY2hlbWEuaXMoZmllbGQudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRUeXBlID0gXCJyZWZcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRUeXBlU2NoZW1hID0gZmllbGQudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkVHlwZSA9IE9iamVjdC5rZXlzKGZpZWxkLnR5cGUpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChmaWVsZC50eXBlW2ZpZWxkVHlwZV0pID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZFR5cGUgKz0gXCI6XCIgKyBmaWVsZC50eXBlW2ZpZWxkVHlwZV07IC8vIGFycmF5OnN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRUeXBlU2NoZW1hID0gZmllbGQudHlwZVtmaWVsZFR5cGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmxlY3Rpb25GaWVsZC5yZWZlcmVuY2VkVHlwZSA9IChjaGlsZFR5cGVTY2hlbWEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY29udGV4dC5nZXRUeXBlSWQoY2hpbGRUeXBlU2NoZW1hKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmbGVjdGlvbkZpZWxkLnR5cGUgPSBmaWVsZFR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlLmZpZWxkcy5wdXNoKHJlZmxlY3Rpb25GaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkVHlwZSh0eXBlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGVyZSBhcmUgdHlwZXMgdGhhdCB3ZXJlIG5vdCBhZGRlZCBkdWUgdG8gaW5oZXJpdGFuY2VcbiAgICAgICAgICAgIGZvciAoY29uc3QgdHlwZWlkIGluIHBlbmRpbmdSZWZsZWN0aW9uVHlwZXMpIHtcbiAgICAgICAgICAgICAgICBwZW5kaW5nUmVmbGVjdGlvblR5cGVzW3R5cGVpZF0uZm9yRWFjaCgodHlwZSkgPT4gcmVmbGVjdGlvbi50eXBlcy5wdXNoKHR5cGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJ1ZiA9IHJlZmxlY3Rpb25FbmNvZGVyLmVuY29kZUFsbChpdCk7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oYnVmLCAwLCBpdC5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIHRoZSBUeXBlQ29udGV4dCBmcm9tIGEgYnVmZmVyIGludG8gYSBEZWNvZGVyIGluc3RhbmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYnl0ZXMgUmVmbGVjdGlvbi5lbmNvZGUoKSBvdXRwdXRcbiAgICAgICAgICogQHBhcmFtIGl0XG4gICAgICAgICAqIEByZXR1cm5zIERlY29kZXIgaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBkZWNvZGUoYnl0ZXMsIGl0KSB7XG4gICAgICAgICAgICBjb25zdCByZWZsZWN0aW9uID0gbmV3IFJlZmxlY3Rpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IHJlZmxlY3Rpb25EZWNvZGVyID0gbmV3IERlY29kZXIocmVmbGVjdGlvbik7XG4gICAgICAgICAgICByZWZsZWN0aW9uRGVjb2Rlci5kZWNvZGUoYnl0ZXMsIGl0KTtcbiAgICAgICAgICAgIGNvbnN0IHR5cGVDb250ZXh0ID0gbmV3IFR5cGVDb250ZXh0KCk7XG4gICAgICAgICAgICAvLyAxc3QgcGFzcywgaW5pdGlhbGl6ZSBtZXRhZGF0YSArIGluaGVyaXRhbmNlXG4gICAgICAgICAgICByZWZsZWN0aW9uLnR5cGVzLmZvckVhY2goKHJlZmxlY3Rpb25UeXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50Q2xhc3MgPSB0eXBlQ29udGV4dC5nZXQocmVmbGVjdGlvblR5cGUuZXh0ZW5kc0lkKSA/PyBTY2hlbWE7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gY2xhc3MgXyBleHRlbmRzIHBhcmVudENsYXNzIHtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIHJlZ2lzdGVyIGZvciBpbmhlcml0YW5jZSBzdXBwb3J0XG4gICAgICAgICAgICAgICAgVHlwZUNvbnRleHQucmVnaXN0ZXIoc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAvLyAvLyBmb3IgaW5oZXJpdGFuY2Ugc3VwcG9ydFxuICAgICAgICAgICAgICAgIC8vIE1ldGFkYXRhLmluaXRpYWxpemUoc2NoZW1hKTtcbiAgICAgICAgICAgICAgICB0eXBlQ29udGV4dC5hZGQoc2NoZW1hLCByZWZsZWN0aW9uVHlwZS5pZCk7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICAvLyBkZWZpbmUgZmllbGRzXG4gICAgICAgICAgICBjb25zdCBhZGRGaWVsZHMgPSAobWV0YWRhdGEsIHJlZmxlY3Rpb25UeXBlLCBwYXJlbnRGaWVsZEluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVmbGVjdGlvblR5cGUuZmllbGRzLmZvckVhY2goKGZpZWxkLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkSW5kZXggPSBwYXJlbnRGaWVsZEluZGV4ICsgaTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLnJlZmVyZW5jZWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWVsZFR5cGUgPSBmaWVsZC50eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlZlR5cGUgPSB0eXBlQ29udGV4dC5nZXQoZmllbGQucmVmZXJlbmNlZFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFwIG9yIGFycmF5IG9mIHByaW1pdGl2ZSB0eXBlICgtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVmVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVJbmZvID0gZmllbGQudHlwZS5zcGxpdChcIjpcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRUeXBlID0gdHlwZUluZm9bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmVHlwZSA9IHR5cGVJbmZvWzFdOyAvLyBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZFR5cGUgPT09IFwicmVmXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZXRhZGF0YS5hZGRGaWVsZChtZXRhZGF0YSwgZmllbGRJbmRleCwgZmllbGQubmFtZSwgcmVmVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZXRhZGF0YS5hZGRGaWVsZChtZXRhZGF0YSwgZmllbGRJbmRleCwgZmllbGQubmFtZSwgeyBbZmllbGRUeXBlXTogcmVmVHlwZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE1ldGFkYXRhLmFkZEZpZWxkKG1ldGFkYXRhLCBmaWVsZEluZGV4LCBmaWVsZC5uYW1lLCBmaWVsZC50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIDJuZCBwYXNzLCBzZXQgZmllbGRzXG4gICAgICAgICAgICByZWZsZWN0aW9uLnR5cGVzLmZvckVhY2goKHJlZmxlY3Rpb25UeXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gdHlwZUNvbnRleHQuZ2V0KHJlZmxlY3Rpb25UeXBlLmlkKTtcbiAgICAgICAgICAgICAgICAvLyBmb3IgaW5oZXJpdGFuY2Ugc3VwcG9ydFxuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gTWV0YWRhdGEuaW5pdGlhbGl6ZShzY2hlbWEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluaGVyaXRlZFR5cGVzID0gW107XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudFR5cGUgPSByZWZsZWN0aW9uVHlwZTtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGluaGVyaXRlZFR5cGVzLnB1c2gocGFyZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFR5cGUgPSByZWZsZWN0aW9uLnR5cGVzLmZpbmQoKHQpID0+IHQuaWQgPT09IHBhcmVudFR5cGUuZXh0ZW5kc0lkKTtcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgICAgICBsZXQgcGFyZW50RmllbGRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgaW5oZXJpdGVkVHlwZXMucmV2ZXJzZSgpLmZvckVhY2goKHJlZmxlY3Rpb25UeXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBmaWVsZHMgZnJvbSBhbGwgaW5oZXJpdGVkIGNsYXNzZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogcmVmYWN0b3IgdGhpcyB0byBhdm9pZCBhZGRpbmcgZmllbGRzIGZyb20gcGFyZW50IGNsYXNzZXNcbiAgICAgICAgICAgICAgICAgICAgYWRkRmllbGRzKG1ldGFkYXRhLCByZWZsZWN0aW9uVHlwZSwgcGFyZW50RmllbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEZpZWxkSW5kZXggKz0gcmVmbGVjdGlvblR5cGUuZmllbGRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBuZXcgKHR5cGVDb250ZXh0LmdldChyZWZsZWN0aW9uLnJvb3RUeXBlIHx8IDApKSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVyKHN0YXRlLCB0eXBlQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHR5cGUoW1JlZmxlY3Rpb25UeXBlXSlcbiAgICBdLCBSZWZsZWN0aW9uLnByb3RvdHlwZSwgXCJ0eXBlc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0eXBlKFwibnVtYmVyXCIpXG4gICAgXSwgUmVmbGVjdGlvbi5wcm90b3R5cGUsIFwicm9vdFR5cGVcIiwgdm9pZCAwKTtcblxuICAgIGZ1bmN0aW9uIGdldERlY29kZXJTdGF0ZUNhbGxiYWNrcyhkZWNvZGVyKSB7XG4gICAgICAgIGNvbnN0ICRyb290ID0gZGVjb2Rlci5yb290O1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSAkcm9vdC5jYWxsYmFja3M7XG4gICAgICAgIGNvbnN0IG9uQWRkQ2FsbHMgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICBsZXQgY3VycmVudE9uQWRkQ2FsbGJhY2s7XG4gICAgICAgIGRlY29kZXIudHJpZ2dlckNoYW5nZXMgPSBmdW5jdGlvbiAoYWxsQ2hhbmdlcykge1xuICAgICAgICAgICAgY29uc3QgdW5pcXVlUmVmSWRzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBhbGxDaGFuZ2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZSA9IGFsbENoYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmSWQgPSBjaGFuZ2UucmVmSWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmID0gY2hhbmdlLnJlZjtcbiAgICAgICAgICAgICAgICBjb25zdCAkY2FsbGJhY2tzID0gY2FsbGJhY2tzW3JlZklkXTtcbiAgICAgICAgICAgICAgICBpZiAoISRjYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gdHJpZ2dlciBvblJlbW92ZSBvbiBjaGlsZCBzdHJ1Y3R1cmUuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBpZiAoKGNoYW5nZS5vcCAmIGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURSkgPT09IGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURSAmJlxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2UucHJldmlvdXNWYWx1ZSBpbnN0YW5jZW9mIFNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWxldGVDYWxsYmFja3MgPSBjYWxsYmFja3NbJHJvb3QucmVmSWRzLmdldChjaGFuZ2UucHJldmlvdXNWYWx1ZSldPy5bZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGRlbGV0ZUNhbGxiYWNrcz8ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUNhbGxiYWNrc1tpXSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZWYgaW5zdGFuY2VvZiBTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIHNjaGVtYSBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXVuaXF1ZVJlZklkcy5oYXMocmVmSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyIG9uQ2hhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlQ2FsbGJhY2tzID0gJGNhbGxiYWNrcz8uW2V4cG9ydHMuT1BFUkFUSU9OLlJFUExBQ0VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHJlcGxhY2VDYWxsYmFja3M/Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZUNhbGxiYWNrc1tpXSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoJGNhbGxiYWNrcy5oYXNPd25Qcm9wZXJ0eShjaGFuZ2UuZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZENhbGxiYWNrcyA9ICRjYWxsYmFja3NbY2hhbmdlLmZpZWxkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBmaWVsZENhbGxiYWNrcz8ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZENhbGxiYWNrc1tpXShjaGFuZ2UudmFsdWUsIGNoYW5nZS5wcmV2aW91c1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBjb2xsZWN0aW9uIG9mIGl0ZW1zXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIGlmICgoY2hhbmdlLm9wICYgZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFKSA9PT0gZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IGBwcmV2aW91c1ZhbHVlYCBzaG91bGQgYWx3YXlzIGJlIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLnByZXZpb3VzVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyaWdlciBvblJlbW92ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbGV0ZUNhbGxiYWNrcyA9ICRjYWxsYmFja3NbZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gZGVsZXRlQ2FsbGJhY2tzPy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVDYWxsYmFja3NbaV0oY2hhbmdlLnByZXZpb3VzVmFsdWUsIGNoYW5nZS5keW5hbWljSW5kZXggPz8gY2hhbmdlLmZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgREVMRVRFX0FORF9BREQgb3BlcmF0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjaGFuZ2Uub3AgJiBleHBvcnRzLk9QRVJBVElPTi5BREQpID09PSBleHBvcnRzLk9QRVJBVElPTi5BREQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGRDYWxsYmFja3MgPSAkY2FsbGJhY2tzW2V4cG9ydHMuT1BFUkFUSU9OLkFERF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGFkZENhbGxiYWNrcz8ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2FsbGJhY2tzW2ldKGNoYW5nZS52YWx1ZSwgY2hhbmdlLmR5bmFtaWNJbmRleCA/PyBjaGFuZ2UuZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgoY2hhbmdlLm9wICYgZXhwb3J0cy5PUEVSQVRJT04uQUREKSA9PT0gZXhwb3J0cy5PUEVSQVRJT04uQUREICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UucHJldmlvdXNWYWx1ZSAhPT0gY2hhbmdlLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmlnZXIgb25BZGRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFkZENhbGxiYWNrcyA9ICRjYWxsYmFja3NbZXhwb3J0cy5PUEVSQVRJT04uQUREXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBhZGRDYWxsYmFja3M/Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2FsbGJhY2tzW2ldKGNoYW5nZS52YWx1ZSwgY2hhbmdlLmR5bmFtaWNJbmRleCA/PyBjaGFuZ2UuZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyaWdnZXIgb25DaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZS52YWx1ZSAhPT0gY2hhbmdlLnByZXZpb3VzVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBzZWUgXCJzaG91bGQgbm90IGVuY29kZSBpdGVtIGlmIGFkZGVkIGFuZCByZW1vdmVkIGF0IHRoZSBzYW1lIHBhdGNoXCIgdGVzdCBjYXNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc29tZSBcIkFERFwiICsgXCJERUxFVEVcIiBvcGVyYXRpb25zIG9uIHNhbWUgcGF0Y2ggYXJlIGJlaW5nIGVuY29kZWQgYXMgXCJERUxFVEVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKGNoYW5nZS52YWx1ZSAhPT0gdW5kZWZpbmVkIHx8IGNoYW5nZS5wcmV2aW91c1ZhbHVlICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlQ2FsbGJhY2tzID0gJGNhbGxiYWNrc1tleHBvcnRzLk9QRVJBVElPTi5SRVBMQUNFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSByZXBsYWNlQ2FsbGJhY2tzPy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VDYWxsYmFja3NbaV0oY2hhbmdlLnZhbHVlLCBjaGFuZ2UuZHluYW1pY0luZGV4ID8/IGNoYW5nZS5maWVsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdW5pcXVlUmVmSWRzLmFkZChyZWZJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIGdldFByb3h5KG1ldGFkYXRhT3JUeXBlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBsZXQgbWV0YWRhdGEgPSBjb250ZXh0Lmluc3RhbmNlPy5jb25zdHJ1Y3RvcltTeW1ib2wubWV0YWRhdGFdIHx8IG1ldGFkYXRhT3JUeXBlO1xuICAgICAgICAgICAgbGV0IGlzQ29sbGVjdGlvbiA9ICgoY29udGV4dC5pbnN0YW5jZSAmJiB0eXBlb2YgKGNvbnRleHQuaW5zdGFuY2VbJ2ZvckVhY2gnXSkgPT09IFwiZnVuY3Rpb25cIikgfHxcbiAgICAgICAgICAgICAgICAobWV0YWRhdGFPclR5cGUgJiYgdHlwZW9mIChtZXRhZGF0YU9yVHlwZVtTeW1ib2wubWV0YWRhdGFdKSA9PT0gXCJ1bmRlZmluZWRcIikpO1xuICAgICAgICAgICAgaWYgKG1ldGFkYXRhICYmICFpc0NvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvbkFkZExpc3RlbiA9IGZ1bmN0aW9uIChyZWYsIHByb3AsIGNhbGxiYWNrLCBpbW1lZGlhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW1tZWRpYXRlIHRyaWdnZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltbWVkaWF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5pbnN0YW5jZVtwcm9wXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhb25BZGRDYWxscy5oYXMoY3VycmVudE9uQWRkQ2FsbGJhY2spIC8vIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2x5c2V1cy9zY2hlbWEvaXNzdWVzLzE0N1xuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGNvbnRleHQuaW5zdGFuY2VbcHJvcF0sIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRyb290LmFkZENhbGxiYWNrKCRyb290LnJlZklkcy5nZXQocmVmKSwgcHJvcCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogU2NoZW1hIGluc3RhbmNlc1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJveHkoe1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW46IGZ1bmN0aW9uIGxpc3Rlbihwcm9wLCBjYWxsYmFjaywgaW1tZWRpYXRlID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb25BZGRMaXN0ZW4oY29udGV4dC5pbnN0YW5jZSwgcHJvcCwgY2FsbGJhY2ssIGltbWVkaWF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb2xsZWN0aW9uIGluc3RhbmNlIG5vdCByZWNlaXZlZCB5ZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGV0YWNoQ2FsbGJhY2sgPSAoKSA9PiB7IH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkluc3RhbmNlQXZhaWxhYmxlKChyZWYsIGV4aXN0aW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFjaENhbGxiYWNrID0gb25BZGRMaXN0ZW4ocmVmLCBwcm9wLCBjYWxsYmFjaywgaW1tZWRpYXRlICYmIGV4aXN0aW5nICYmICFvbkFkZENhbGxzLmhhcyhjdXJyZW50T25BZGRDYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBkZXRhY2hDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkcm9vdC5hZGRDYWxsYmFjaygkcm9vdC5yZWZJZHMuZ2V0KGNvbnRleHQuaW5zdGFuY2UpLCBleHBvcnRzLk9QRVJBVElPTi5SRVBMQUNFLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHJlZmFjdG9yIGBiaW5kVG8oKWAgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIHJvb20gZm9yIGltcHJvdmVtZW50LlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICBiaW5kVG86IGZ1bmN0aW9uIGJpbmRUbyh0YXJnZXRPYmplY3QsIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhtZXRhZGF0YSkubWFwKChpbmRleCkgPT4gbWV0YWRhdGFbaW5kZXhdLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRyb290LmFkZENhbGxiYWNrKCRyb290LnJlZklkcy5nZXQoY29udGV4dC5pbnN0YW5jZSksIGV4cG9ydHMuT1BFUkFUSU9OLlJFUExBQ0UsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLmZvckVhY2goKHByb3ApID0+IHRhcmdldE9iamVjdFtwcm9wXSA9IGNvbnRleHQuaW5zdGFuY2VbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIGdldCh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhRmllbGQgPSBtZXRhZGF0YVttZXRhZGF0YVtwcm9wXV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGFGaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gY29udGV4dC5pbnN0YW5jZT8uW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9uSW5zdGFuY2VBdmFpbGFibGUgPSAoKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVuYmluZCA9ICQoY29udGV4dC5pbnN0YW5jZSkubGlzdGVuKHByb3AsICh2YWx1ZSwgXykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBieSBcInVuYmluZGluZ1wiIHRoZSBjYWxsYmFjayBoZXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgd2lsbCBub3Qgc3VwcG9ydCB3aGVuIHRoZSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlLWluc3RhbnRpYXRlcyB0aGUgaW5zdGFuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5iaW5kPy4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoYXMgZXhpc3RpbmcgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRyb290LnJlZklkcy5nZXQoaW5zdGFuY2UpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGluc3RhbmNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRQcm94eShtZXRhZGF0YUZpZWxkLnR5cGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHJlZklkIGlzIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIGluc3RhbmNlIHRvIGJlIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6ICgkcm9vdC5yZWZJZHMuZ2V0KGluc3RhbmNlKSAmJiBpbnN0YW5jZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEluc3RhbmNlOiBjb250ZXh0Lmluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkluc3RhbmNlQXZhaWxhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWNjZXNzaW5nIHRoZSBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGhhcyh0YXJnZXQsIHByb3ApIHsgcmV0dXJuIG1ldGFkYXRhW3Byb3BdICE9PSB1bmRlZmluZWQ7IH0sXG4gICAgICAgICAgICAgICAgICAgIHNldChfLCBfMSwgXzIpIHsgdGhyb3cgbmV3IEVycm9yKFwibm90IGFsbG93ZWRcIik7IH0sXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KF8sIF8xKSB7IHRocm93IG5ldyBFcnJvcihcIm5vdCBhbGxvd2VkXCIpOyB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ29sbGVjdGlvbiBpbnN0YW5jZXNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjb25zdCBvbkFkZCA9IGZ1bmN0aW9uIChyZWYsIGNhbGxiYWNrLCBpbW1lZGlhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJpZ2dlciBjYWxsYmFjayBvbiBleGlzdGluZyBpdGVtc1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW1tZWRpYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWYuZm9yRWFjaCgodiwgaykgPT4gY2FsbGJhY2sodiwgaykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcm9vdC5hZGRDYWxsYmFjaygkcm9vdC5yZWZJZHMuZ2V0KHJlZiksIGV4cG9ydHMuT1BFUkFUSU9OLkFERCwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQWRkQ2FsbHMuc2V0KGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRPbkFkZENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh2YWx1ZSwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQWRkQ2FsbHMuZGVsZXRlKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRPbkFkZENhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uUmVtb3ZlID0gZnVuY3Rpb24gKHJlZiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRyb290LmFkZENhbGxiYWNrKCRyb290LnJlZklkcy5nZXQocmVmKSwgZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBvbkNoYW5nZSA9IGZ1bmN0aW9uIChyZWYsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcm9vdC5hZGRDYWxsYmFjaygkcm9vdC5yZWZJZHMuZ2V0KHJlZiksIGV4cG9ydHMuT1BFUkFUSU9OLlJFUExBQ0UsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJveHkoe1xuICAgICAgICAgICAgICAgICAgICBvbkFkZDogZnVuY3Rpb24gKGNhbGxiYWNrLCBpbW1lZGlhdGUgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NvbHlzZXVzL3NjaGVtYS9pc3N1ZXMvMTQ3XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBwYXJlbnQgaW5zdGFuY2UgaGFzIFwib25BZGRcIiByZWdpc3RlcmVkLCBhdm9pZCB0cmlnZ2VyaW5nIGltbWVkaWF0ZSBjYWxsYmFjay5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5pbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvbkFkZChjb250ZXh0Lmluc3RhbmNlLCBjYWxsYmFjaywgaW1tZWRpYXRlICYmICFvbkFkZENhbGxzLmhhcyhjdXJyZW50T25BZGRDYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGV4dC5vbkluc3RhbmNlQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29sbGVjdGlvbiBpbnN0YW5jZSBub3QgcmVjZWl2ZWQgeWV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRldGFjaENhbGxiYWNrID0gKCkgPT4geyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25JbnN0YW5jZUF2YWlsYWJsZSgocmVmLCBleGlzdGluZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhY2hDYWxsYmFjayA9IG9uQWRkKHJlZiwgY2FsbGJhY2ssIGltbWVkaWF0ZSAmJiBleGlzdGluZyAmJiAhb25BZGRDYWxscy5oYXMoY3VycmVudE9uQWRkQ2FsbGJhY2spKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gZGV0YWNoQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25SZW1vdmU6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb25SZW1vdmUoY29udGV4dC5pbnN0YW5jZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGV4dC5vbkluc3RhbmNlQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29sbGVjdGlvbiBpbnN0YW5jZSBub3QgcmVjZWl2ZWQgeWV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRldGFjaENhbGxiYWNrID0gKCkgPT4geyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25JbnN0YW5jZUF2YWlsYWJsZSgocmVmKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFjaENhbGxiYWNrID0gb25SZW1vdmUocmVmLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGRldGFjaENhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0Lmluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9uQ2hhbmdlKGNvbnRleHQuaW5zdGFuY2UsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRleHQub25JbnN0YW5jZUF2YWlsYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbGxlY3Rpb24gaW5zdGFuY2Ugbm90IHJlY2VpdmVkIHlldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkZXRhY2hDYWxsYmFjayA9ICgpID0+IHsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uSW5zdGFuY2VBdmFpbGFibGUoKHJlZikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhY2hDYWxsYmFjayA9IG9uQ2hhbmdlKHJlZiwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBkZXRhY2hDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0KHRhcmdldCwgcHJvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0YXJnZXRbcHJvcF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGFjY2VzcyAnJHtwcm9wfScgdGhyb3VnaCBjYWxsYmFjayBwcm94eS4gYWNjZXNzIHRoZSBpbnN0YW5jZSBkaXJlY3RseS5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGhhcyh0YXJnZXQsIHByb3ApIHsgcmV0dXJuIHRhcmdldFtwcm9wXSAhPT0gdW5kZWZpbmVkOyB9LFxuICAgICAgICAgICAgICAgICAgICBzZXQoXywgXzEsIF8yKSB7IHRocm93IG5ldyBFcnJvcihcIm5vdCBhbGxvd2VkXCIpOyB9LFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVQcm9wZXJ0eShfLCBfMSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJub3QgYWxsb3dlZFwiKTsgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiAkKGluc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0UHJveHkodW5kZWZpbmVkLCB7IGluc3RhbmNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFJhd0NoYW5nZXNDYWxsYmFjayhkZWNvZGVyLCBjYWxsYmFjaykge1xuICAgICAgICBkZWNvZGVyLnRyaWdnZXJDaGFuZ2VzID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgY2xhc3MgU3RhdGVWaWV3IHtcbiAgICAgICAgY29uc3RydWN0b3IoaXRlcmFibGUgPSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5pdGVyYWJsZSA9IGl0ZXJhYmxlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBMaXN0IG9mIENoYW5nZVRyZWUncyB0aGF0IGFyZSB2aXNpYmxlIHRvIHRoaXMgdmlld1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnZpc2libGUgPSBuZXcgV2Vha1NldCgpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBMaXN0IG9mIENoYW5nZVRyZWUncyB0aGF0IGFyZSBpbnZpc2libGUgdG8gdGhpcyB2aWV3XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaW52aXNpYmxlID0gbmV3IFdlYWtTZXQoKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTWFudWFsIFwiQUREXCIgb3BlcmF0aW9ucyBmb3IgY2hhbmdlcyBwZXIgQ2hhbmdlVHJlZSwgc3BlY2lmaWMgdG8gdGhpcyB2aWV3LlxuICAgICAgICAgICAgICogKFRoaXMgaXMgdXNlZCB0byBmb3JjZSBlbmNvZGluZyBhIHByb3BlcnR5LCBldmVuIGlmIGl0IHdhcyBub3QgY2hhbmdlZClcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IGFsbG93IHRvIHNldCBtdWx0aXBsZSB0YWdzIGF0IG9uY2VcbiAgICAgICAgYWRkKG9iaiwgdGFnID0gREVGQVVMVF9WSUVXX1RBRywgY2hlY2tJbmNsdWRlUGFyZW50ID0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlVHJlZSA9IG9iaj8uWyRjaGFuZ2VzXTtcbiAgICAgICAgICAgIGlmICghY2hhbmdlVHJlZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlN0YXRlVmlldyNhZGQoKSwgaW52YWxpZCBvYmplY3Q6XCIsIG9iaik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghY2hhbmdlVHJlZS5wYXJlbnQgJiZcbiAgICAgICAgICAgICAgICBjaGFuZ2VUcmVlLnJlZklkICE9PSAwIC8vIGFsbG93IHJvb3Qgb2JqZWN0XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUT0RPOiBjYW4gd2UgYXZvaWQgdGhpcz9cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIFdoZW4gdGhlIFwicGFyZW50XCIgc3RydWN0dXJlIGhhcyB0aGUgQHZpZXcoKSB0YWcsIGl0IGlzIGN1cnJlbnRseVxuICAgICAgICAgICAgICAgICAqIG5vdCBwb3NzaWJsZSB0byBpZGVudGlmeSBpdCBoYXMgdG8gYmUgYWRkZWQgdG8gdGhlIHZpZXcgYXMgd2VsbFxuICAgICAgICAgICAgICAgICAqICh0aGlzLmFkZFBhcmVudE9mKCkgaXMgbm90IGNhbGxlZCkuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgYWRkIGEgZGV0YWNoZWQgaW5zdGFuY2UgdG8gdGhlIFN0YXRlVmlldy4gTWFrZSBzdXJlIHRvIGFzc2lnbiB0aGUgXCIke2NoYW5nZVRyZWUucmVmLmNvbnN0cnVjdG9yLm5hbWV9XCIgaW5zdGFuY2UgdG8gdGhlIHN0YXRlIGJlZm9yZSBjYWxsaW5nIHZpZXcuYWRkKClgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZJWE1FOiBBcnJheVNjaGVtYS9NYXBTY2hlbWEgZG8gbm90IGhhdmUgbWV0YWRhdGFcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gb2JqLmNvbnN0cnVjdG9yW1N5bWJvbC5tZXRhZGF0YV07XG4gICAgICAgICAgICB0aGlzLnZpc2libGUuYWRkKGNoYW5nZVRyZWUpO1xuICAgICAgICAgICAgLy8gYWRkIHRvIGl0ZXJhYmxlIGxpc3QgKG9ubHkgdGhlIGV4cGxpY2l0bHkgYWRkZWQgaXRlbXMpXG4gICAgICAgICAgICBpZiAodGhpcy5pdGVyYWJsZSAmJiBjaGVja0luY2x1ZGVQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2gob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFkZCBwYXJlbnQgQ2hhbmdlVHJlZSdzXG4gICAgICAgICAgICAvLyAtIGlmIGl0IHdhcyBpbnZpc2libGUgdG8gdGhpcyB2aWV3XG4gICAgICAgICAgICAvLyAtIGlmIGl0IHdlcmUgcHJldmlvdXNseSBmaWx0ZXJlZCBvdXRcbiAgICAgICAgICAgIGlmIChjaGVja0luY2x1ZGVQYXJlbnQgJiYgY2hhbmdlVHJlZS5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFBhcmVudE9mKGNoYW5nZVRyZWUsIHRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVE9ETzogd2hlbiBhZGRpbmcgYW4gaXRlbSBvZiBhIE1hcFNjaGVtYSwgdGhlIGNoYW5nZXMgbWF5IG5vdFxuICAgICAgICAgICAgLy8gYmUgc2V0IChvbmx5IHRoZSBwYXJlbnQncyBjaGFuZ2VzIGFyZSBzZXQpXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgbGV0IGNoYW5nZXMgPSB0aGlzLmNoYW5nZXMuZ2V0KGNoYW5nZVRyZWUucmVmSWQpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMgPSB7fTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZXMuc2V0KGNoYW5nZVRyZWUucmVmSWQsIGNoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IHRhZ1xuICAgICAgICAgICAgaWYgKHRhZyAhPT0gREVGQVVMVF9WSUVXX1RBRykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy50YWdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFncyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCB0YWdzO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy50YWdzLmhhcyhjaGFuZ2VUcmVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0YWdzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhZ3Muc2V0KGNoYW5nZVRyZWUsIHRhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFncyA9IHRoaXMudGFncy5nZXQoY2hhbmdlVHJlZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhZ3MuYWRkKHRhZyk7XG4gICAgICAgICAgICAgICAgLy8gUmVmOiBhZGQgdGFnZ2VkIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICBtZXRhZGF0YT8uWyRmaWVsZEluZGV4ZXNCeVZpZXdUYWddPy5bdGFnXT8uZm9yRWFjaCgoaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZVRyZWUuZ2V0Q2hhbmdlKGluZGV4KSAhPT0gZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzW2luZGV4XSA9IGV4cG9ydHMuT1BFUkFUSU9OLkFERDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNJbnZpc2libGUgPSB0aGlzLmludmlzaWJsZS5oYXMoY2hhbmdlVHJlZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlU2V0ID0gKGNoYW5nZVRyZWUuZmlsdGVyZWRDaGFuZ2VzICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgID8gY2hhbmdlVHJlZS5hbGxGaWx0ZXJlZENoYW5nZXNcbiAgICAgICAgICAgICAgICAgICAgOiBjaGFuZ2VUcmVlLmFsbENoYW5nZXM7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNoYW5nZVNldC5vcGVyYXRpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY2hhbmdlU2V0Lm9wZXJhdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfSAvLyBza2lwIFwidW5kZWZpbmVkXCIgaW5kZXhlc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcCA9IGNoYW5nZVRyZWUuaW5kZXhlZE9wZXJhdGlvbnNbaW5kZXhdID8/IGV4cG9ydHMuT1BFUkFUSU9OLkFERDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFnQXRJbmRleCA9IG1ldGFkYXRhPy5baW5kZXhdLnRhZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGFuZ2VUcmVlLmlzTmV3ICYmIC8vIG5ldyBzdHJ1Y3R1cmVzIHdpbGwgYmUgYWRkZWQgYXMgcGFydCBvZiAuZW5jb2RlKCkgY2FsbCwgbm8gbmVlZCB0byBmb3JjZSBpdCB0byAuZW5jb2RlVmlldygpXG4gICAgICAgICAgICAgICAgICAgICAgICAoaXNJbnZpc2libGUgfHwgLy8gaWYgXCJpbnZpc2libGVcIiwgaW5jbHVkZSBhbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdBdEluZGV4ID09PSB1bmRlZmluZWQgfHwgLy8gXCJhbGwgY2hhbmdlXCIgd2l0aCBubyB0YWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdBdEluZGV4ID09PSB0YWcgLy8gdGFnZ2VkIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgICAgICApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBvcCAhPT0gZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzW2luZGV4XSA9IG9wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIGNoaWxkcmVuIG9mIHRoaXMgQ2hhbmdlVHJlZSB0byB0aGlzIHZpZXdcbiAgICAgICAgICAgIGNoYW5nZVRyZWUuZm9yRWFjaENoaWxkKChjaGFuZ2UsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IEFERCBjaGlsZHJlbiB0aGF0IGRvbid0IGhhdmUgdGhlIHNhbWUgdGFnXG4gICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhICYmXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhW2luZGV4XS50YWcgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YVtpbmRleF0udGFnICE9PSB0YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmFkZChjaGFuZ2UucmVmLCB0YWcsIGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgYWRkUGFyZW50T2YoY2hpbGRDaGFuZ2VUcmVlLCB0YWcpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZVRyZWUgPSBjaGlsZENoYW5nZVRyZWUucGFyZW50WyRjaGFuZ2VzXTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEluZGV4ID0gY2hpbGRDaGFuZ2VUcmVlLnBhcmVudEluZGV4O1xuICAgICAgICAgICAgaWYgKCF0aGlzLnZpc2libGUuaGFzKGNoYW5nZVRyZWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gdmlldyBtdXN0IGhhdmUgYWxsIFwiY2hhbmdlVHJlZVwiIHBhcmVudCB0cmVlXG4gICAgICAgICAgICAgICAgdGhpcy52aXNpYmxlLmFkZChjaGFuZ2VUcmVlKTtcbiAgICAgICAgICAgICAgICAvLyBhZGQgcGFyZW50J3MgcGFyZW50XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50Q2hhbmdlVHJlZSA9IGNoYW5nZVRyZWUucGFyZW50Py5bJGNoYW5nZXNdO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRDaGFuZ2VUcmVlICYmIChwYXJlbnRDaGFuZ2VUcmVlLmZpbHRlcmVkQ2hhbmdlcyAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFBhcmVudE9mKGNoYW5nZVRyZWUsIHRhZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIC8vIHBhcmVudCBpcyBhbHJlYWR5IGF2YWlsYWJsZSwgbm8gbmVlZCB0byBhZGQgaXQhXG4gICAgICAgICAgICAgICAgLy8gaWYgKCF0aGlzLmludmlzaWJsZS5oYXMoY2hhbmdlVHJlZSkpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhZGQgcGFyZW50J3MgdGFnIHByb3BlcnRpZXNcbiAgICAgICAgICAgIGlmIChjaGFuZ2VUcmVlLmdldENoYW5nZShwYXJlbnRJbmRleCkgIT09IGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURSkge1xuICAgICAgICAgICAgICAgIGxldCBjaGFuZ2VzID0gdGhpcy5jaGFuZ2VzLmdldChjaGFuZ2VUcmVlLnJlZklkKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VzLnNldChjaGFuZ2VUcmVlLnJlZklkLCBjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnRhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWdzID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHRhZ3M7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnRhZ3MuaGFzKGNoYW5nZVRyZWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhZ3MgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFncy5zZXQoY2hhbmdlVHJlZSwgdGFncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YWdzID0gdGhpcy50YWdzLmdldChjaGFuZ2VUcmVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFncy5hZGQodGFnKTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzW3BhcmVudEluZGV4XSA9IGV4cG9ydHMuT1BFUkFUSU9OLkFERDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZW1vdmUob2JqLCB0YWcgPSBERUZBVUxUX1ZJRVdfVEFHLCBfaXNDbGVhciA9IGZhbHNlKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VUcmVlID0gb2JqWyRjaGFuZ2VzXTtcbiAgICAgICAgICAgIGlmICghY2hhbmdlVHJlZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlN0YXRlVmlldyNyZW1vdmUoKSwgaW52YWxpZCBvYmplY3Q6XCIsIG9iaik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZpc2libGUuZGVsZXRlKGNoYW5nZVRyZWUpO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGZyb20gaXRlcmFibGUgbGlzdFxuICAgICAgICAgICAgaWYgKHRoaXMuaXRlcmFibGUgJiZcbiAgICAgICAgICAgICAgICAhX2lzQ2xlYXIgLy8gbm8gbmVlZCB0byByZW1vdmUgZHVyaW5nIGNsZWFyKCksIGFzIGl0IHdpbGwgYmUgY2xlYXJlZCBlbnRpcmVseVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgc3BsaWNlT25lKHRoaXMuaXRlbXMsIHRoaXMuaXRlbXMuaW5kZXhPZihvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlZiA9IGNoYW5nZVRyZWUucmVmO1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSByZWYuY29uc3RydWN0b3JbU3ltYm9sLm1ldGFkYXRhXTsgLy8gQXJyYXlTY2hlbWEvTWFwU2NoZW1hIGRvIG5vdCBoYXZlIG1ldGFkYXRhXG4gICAgICAgICAgICBsZXQgY2hhbmdlcyA9IHRoaXMuY2hhbmdlcy5nZXQoY2hhbmdlVHJlZS5yZWZJZCk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlcyA9IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlcy5zZXQoY2hhbmdlVHJlZS5yZWZJZCwgY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFnID09PSBERUZBVUxUX1ZJRVdfVEFHKSB7XG4gICAgICAgICAgICAgICAgLy8gcGFyZW50IGlzIGNvbGxlY3Rpb24gKE1hcC9BcnJheSlcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBjaGFuZ2VUcmVlLnBhcmVudDtcbiAgICAgICAgICAgICAgICBpZiAoIU1ldGFkYXRhLmlzVmFsaWRJbnN0YW5jZShwYXJlbnQpICYmIGNoYW5nZVRyZWUuaXNGaWx0ZXJlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRDaGFuZ2VUcmVlID0gcGFyZW50WyRjaGFuZ2VzXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoYW5nZXMgPSB0aGlzLmNoYW5nZXMuZ2V0KHBhcmVudENoYW5nZVRyZWUucmVmSWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZXMuc2V0KHBhcmVudENoYW5nZVRyZWUucmVmSWQsIGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIERFTEVURSAvIERFTEVURSBCWSBSRUYgSURcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlc1tjaGFuZ2VUcmVlLnBhcmVudEluZGV4XSA9IGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSBhbGwgXCJ0YWdnZWRcIiBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YT8uWyR2aWV3RmllbGRJbmRleGVzXT8uZm9yRWFjaCgoaW5kZXgpID0+IGNoYW5nZXNbaW5kZXhdID0gZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkZWxldGUgb25seSB0YWdnZWQgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhPy5bJGZpZWxkSW5kZXhlc0J5Vmlld1RhZ11bdGFnXS5mb3JFYWNoKChpbmRleCkgPT4gY2hhbmdlc1tpbmRleF0gPSBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRhZ1xuICAgICAgICAgICAgaWYgKHRoaXMudGFncyAmJiB0aGlzLnRhZ3MuaGFzKGNoYW5nZVRyZWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFncyA9IHRoaXMudGFncy5nZXQoY2hhbmdlVHJlZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRhZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSBhbGwgdGFnc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhZ3MuZGVsZXRlKGNoYW5nZVRyZWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVsZXRlIHNwZWNpZmljIHRhZ1xuICAgICAgICAgICAgICAgICAgICB0YWdzLmRlbGV0ZSh0YWcpO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0YWcgc2V0IGlzIGVtcHR5LCBkZWxldGUgaXQgZW50aXJlbHlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZ3Muc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YWdzLmRlbGV0ZShjaGFuZ2VUcmVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGhhcyhvYmopIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2libGUuaGFzKG9ialskY2hhbmdlc10pO1xuICAgICAgICB9XG4gICAgICAgIGhhc1RhZyhvYiwgdGFnID0gREVGQVVMVF9WSUVXX1RBRykge1xuICAgICAgICAgICAgY29uc3QgdGFncyA9IHRoaXMudGFncz8uZ2V0KG9iWyRjaGFuZ2VzXSk7XG4gICAgICAgICAgICByZXR1cm4gdGFncz8uaGFzKHRhZykgPz8gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXIoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXRlcmFibGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGF0ZVZpZXcjY2xlYXIoKSBpcyBvbmx5IGF2YWlsYWJsZSBmb3IgaXRlcmFibGUgU3RhdGVWaWV3J3MuIFVzZSBTdGF0ZVZpZXcoaXRlcmFibGU6IHRydWUpIGNvbnN0cnVjdG9yLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5pdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZSh0aGlzLml0ZW1zW2ldLCBERUZBVUxUX1ZJRVdfVEFHLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNsZWFyIGl0ZW1zIGFycmF5XG4gICAgICAgICAgICB0aGlzLml0ZW1zLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaXNDaGFuZ2VUcmVlVmlzaWJsZShjaGFuZ2VUcmVlKSB7XG4gICAgICAgICAgICBsZXQgaXNWaXNpYmxlID0gdGhpcy52aXNpYmxlLmhhcyhjaGFuZ2VUcmVlKTtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUT0RPOiBhdm9pZCBjaGVja2luZyBmb3IgcGFyZW50IHZpc2liaWxpdHksIG1vc3Qgb2YgdGhlIHRpbWUgaXQncyBub3QgbmVlZGVkXG4gICAgICAgICAgICAvLyBTZWUgdGVzdCBjYXNlOiAnc2hvdWxkIG5vdCBiZSByZXF1aXJlZCB0byBtYW51YWxseSBjYWxsIHZpZXcuYWRkKCkgaXRlbXMgdG8gY2hpbGQgYXJyYXlzIHdpdGhvdXQgQHZpZXcoKSB0YWcnXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgaWYgKCFpc1Zpc2libGUgJiYgY2hhbmdlVHJlZS5pc1Zpc2liaWxpdHlTaGFyZWRXaXRoUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJDSEVDSyBBR0FJTlNUIFBBUkVOVC4uLlwiLCB7XG4gICAgICAgICAgICAgICAgLy8gICAgIHJlZjogY2hhbmdlVHJlZS5yZWYuY29uc3RydWN0b3IubmFtZSxcbiAgICAgICAgICAgICAgICAvLyAgICAgcmVmSWQ6IGNoYW5nZVRyZWUucmVmSWQsXG4gICAgICAgICAgICAgICAgLy8gICAgIHBhcmVudDogY2hhbmdlVHJlZS5wYXJlbnQuY29uc3RydWN0b3IubmFtZSxcbiAgICAgICAgICAgICAgICAvLyB9KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52aXNpYmxlLmhhcyhjaGFuZ2VUcmVlLnBhcmVudFskY2hhbmdlc10pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaWJsZS5hZGQoY2hhbmdlVHJlZSk7XG4gICAgICAgICAgICAgICAgICAgIGlzVmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlzVmlzaWJsZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlZ2lzdGVyVHlwZShcIm1hcFwiLCB7IGNvbnN0cnVjdG9yOiBNYXBTY2hlbWEgfSk7XG4gICAgcmVnaXN0ZXJUeXBlKFwiYXJyYXlcIiwgeyBjb25zdHJ1Y3RvcjogQXJyYXlTY2hlbWEgfSk7XG4gICAgcmVnaXN0ZXJUeXBlKFwic2V0XCIsIHsgY29uc3RydWN0b3I6IFNldFNjaGVtYSB9KTtcbiAgICByZWdpc3RlclR5cGUoXCJjb2xsZWN0aW9uXCIsIHsgY29uc3RydWN0b3I6IENvbGxlY3Rpb25TY2hlbWEsIH0pO1xuXG4gICAgZXhwb3J0cy4kY2hhbmdlcyA9ICRjaGFuZ2VzO1xuICAgIGV4cG9ydHMuJGNoaWxkVHlwZSA9ICRjaGlsZFR5cGU7XG4gICAgZXhwb3J0cy4kZGVjb2RlciA9ICRkZWNvZGVyO1xuICAgIGV4cG9ydHMuJGRlbGV0ZUJ5SW5kZXggPSAkZGVsZXRlQnlJbmRleDtcbiAgICBleHBvcnRzLiRlbmNvZGVyID0gJGVuY29kZXI7XG4gICAgZXhwb3J0cy4kZmlsdGVyID0gJGZpbHRlcjtcbiAgICBleHBvcnRzLiRnZXRCeUluZGV4ID0gJGdldEJ5SW5kZXg7XG4gICAgZXhwb3J0cy4kdHJhY2sgPSAkdHJhY2s7XG4gICAgZXhwb3J0cy5BcnJheVNjaGVtYSA9IEFycmF5U2NoZW1hO1xuICAgIGV4cG9ydHMuQ2hhbmdlVHJlZSA9IENoYW5nZVRyZWU7XG4gICAgZXhwb3J0cy5Db2xsZWN0aW9uU2NoZW1hID0gQ29sbGVjdGlvblNjaGVtYTtcbiAgICBleHBvcnRzLkRlY29kZXIgPSBEZWNvZGVyO1xuICAgIGV4cG9ydHMuRW5jb2RlciA9IEVuY29kZXI7XG4gICAgZXhwb3J0cy5NYXBTY2hlbWEgPSBNYXBTY2hlbWE7XG4gICAgZXhwb3J0cy5NZXRhZGF0YSA9IE1ldGFkYXRhO1xuICAgIGV4cG9ydHMuUmVmbGVjdGlvbiA9IFJlZmxlY3Rpb247XG4gICAgZXhwb3J0cy5SZWZsZWN0aW9uRmllbGQgPSBSZWZsZWN0aW9uRmllbGQ7XG4gICAgZXhwb3J0cy5SZWZsZWN0aW9uVHlwZSA9IFJlZmxlY3Rpb25UeXBlO1xuICAgIGV4cG9ydHMuU2NoZW1hID0gU2NoZW1hO1xuICAgIGV4cG9ydHMuU2V0U2NoZW1hID0gU2V0U2NoZW1hO1xuICAgIGV4cG9ydHMuU3RhdGVWaWV3ID0gU3RhdGVWaWV3O1xuICAgIGV4cG9ydHMuVHlwZUNvbnRleHQgPSBUeXBlQ29udGV4dDtcbiAgICBleHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbiAgICBleHBvcnRzLmRlY29kZUtleVZhbHVlT3BlcmF0aW9uID0gZGVjb2RlS2V5VmFsdWVPcGVyYXRpb247XG4gICAgZXhwb3J0cy5kZWNvZGVTY2hlbWFPcGVyYXRpb24gPSBkZWNvZGVTY2hlbWFPcGVyYXRpb247XG4gICAgZXhwb3J0cy5kZWZpbmVDdXN0b21UeXBlcyA9IGRlZmluZUN1c3RvbVR5cGVzO1xuICAgIGV4cG9ydHMuZGVmaW5lVHlwZXMgPSBkZWZpbmVUeXBlcztcbiAgICBleHBvcnRzLmRlcHJlY2F0ZWQgPSBkZXByZWNhdGVkO1xuICAgIGV4cG9ydHMuZHVtcENoYW5nZXMgPSBkdW1wQ2hhbmdlcztcbiAgICBleHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbiAgICBleHBvcnRzLmVuY29kZUFycmF5ID0gZW5jb2RlQXJyYXk7XG4gICAgZXhwb3J0cy5lbmNvZGVLZXlWYWx1ZU9wZXJhdGlvbiA9IGVuY29kZUtleVZhbHVlT3BlcmF0aW9uO1xuICAgIGV4cG9ydHMuZW5jb2RlU2NoZW1hT3BlcmF0aW9uID0gZW5jb2RlU2NoZW1hT3BlcmF0aW9uO1xuICAgIGV4cG9ydHMuZW50aXR5ID0gZW50aXR5O1xuICAgIGV4cG9ydHMuZ2V0RGVjb2RlclN0YXRlQ2FsbGJhY2tzID0gZ2V0RGVjb2RlclN0YXRlQ2FsbGJhY2tzO1xuICAgIGV4cG9ydHMuZ2V0UmF3Q2hhbmdlc0NhbGxiYWNrID0gZ2V0UmF3Q2hhbmdlc0NhbGxiYWNrO1xuICAgIGV4cG9ydHMucmVnaXN0ZXJUeXBlID0gcmVnaXN0ZXJUeXBlO1xuICAgIGV4cG9ydHMuc2NoZW1hID0gc2NoZW1hO1xuICAgIGV4cG9ydHMudHlwZSA9IHR5cGU7XG4gICAgZXhwb3J0cy52aWV3ID0gdmlldztcblxufSkpO1xuIiwiLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9hc3NlcnQuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMmE1MWFlNDI0YTUxM2VjOWE2YWEzNDY2YmFhMGNjMWQ1NWRkNGYzYlxuXG4vLyBPcmlnaW5hbGx5IGZyb20gbmFyd2hhbC5qcyAoaHR0cDovL25hcndoYWxqcy5vcmcpXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDkgVGhvbWFzIFJvYmluc29uIDwyODBub3J0aC5jb20+XG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgJ1NvZnR3YXJlJyksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuLy8gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuLy8gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gX3R5cGVvZihrZXkpID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAoX3R5cGVvZihyZXMpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2ludGVybmFsL2Vycm9ycycpLFxuICBfcmVxdWlyZSRjb2RlcyA9IF9yZXF1aXJlLmNvZGVzLFxuICBFUlJfQU1CSUdVT1VTX0FSR1VNRU5UID0gX3JlcXVpcmUkY29kZXMuRVJSX0FNQklHVU9VU19BUkdVTUVOVCxcbiAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgRVJSX0lOVkFMSURfQVJHX1ZBTFVFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1ZBTFVFLFxuICBFUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUsXG4gIEVSUl9NSVNTSU5HX0FSR1MgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUlTU0lOR19BUkdTO1xudmFyIEFzc2VydGlvbkVycm9yID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9hc3NlcnQvYXNzZXJ0aW9uX2Vycm9yJyk7XG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZSgndXRpbC8nKSxcbiAgaW5zcGVjdCA9IF9yZXF1aXJlMi5pbnNwZWN0O1xudmFyIF9yZXF1aXJlJHR5cGVzID0gcmVxdWlyZSgndXRpbC8nKS50eXBlcyxcbiAgaXNQcm9taXNlID0gX3JlcXVpcmUkdHlwZXMuaXNQcm9taXNlLFxuICBpc1JlZ0V4cCA9IF9yZXF1aXJlJHR5cGVzLmlzUmVnRXhwO1xudmFyIG9iamVjdEFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC5hc3NpZ24vcG9seWZpbGwnKSgpO1xudmFyIG9iamVjdElzID0gcmVxdWlyZSgnb2JqZWN0LWlzL3BvbHlmaWxsJykoKTtcbnZhciBSZWdFeHBQcm90b3R5cGVUZXN0ID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpKCdSZWdFeHAucHJvdG90eXBlLnRlc3QnKTtcbnZhciBlcnJvckNhY2hlID0gbmV3IE1hcCgpO1xudmFyIGlzRGVlcEVxdWFsO1xudmFyIGlzRGVlcFN0cmljdEVxdWFsO1xudmFyIHBhcnNlRXhwcmVzc2lvbkF0O1xudmFyIGZpbmROb2RlQXJvdW5kO1xudmFyIGRlY29kZXI7XG5mdW5jdGlvbiBsYXp5TG9hZENvbXBhcmlzb24oKSB7XG4gIHZhciBjb21wYXJpc29uID0gcmVxdWlyZSgnLi9pbnRlcm5hbC91dGlsL2NvbXBhcmlzb25zJyk7XG4gIGlzRGVlcEVxdWFsID0gY29tcGFyaXNvbi5pc0RlZXBFcXVhbDtcbiAgaXNEZWVwU3RyaWN0RXF1YWwgPSBjb21wYXJpc29uLmlzRGVlcFN0cmljdEVxdWFsO1xufVxuXG4vLyBFc2NhcGUgY29udHJvbCBjaGFyYWN0ZXJzIGJ1dCBub3QgXFxuIGFuZCBcXHQgdG8ga2VlcCB0aGUgbGluZSBicmVha3MgYW5kXG4vLyBpbmRlbnRhdGlvbiBpbnRhY3QuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxudmFyIGVzY2FwZVNlcXVlbmNlc1JlZ0V4cCA9IC9bXFx4MDAtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZdL2c7XG52YXIgbWV0YSA9IFtcIlxcXFx1MDAwMFwiLCBcIlxcXFx1MDAwMVwiLCBcIlxcXFx1MDAwMlwiLCBcIlxcXFx1MDAwM1wiLCBcIlxcXFx1MDAwNFwiLCBcIlxcXFx1MDAwNVwiLCBcIlxcXFx1MDAwNlwiLCBcIlxcXFx1MDAwN1wiLCAnXFxcXGInLCAnJywgJycsIFwiXFxcXHUwMDBiXCIsICdcXFxcZicsICcnLCBcIlxcXFx1MDAwZVwiLCBcIlxcXFx1MDAwZlwiLCBcIlxcXFx1MDAxMFwiLCBcIlxcXFx1MDAxMVwiLCBcIlxcXFx1MDAxMlwiLCBcIlxcXFx1MDAxM1wiLCBcIlxcXFx1MDAxNFwiLCBcIlxcXFx1MDAxNVwiLCBcIlxcXFx1MDAxNlwiLCBcIlxcXFx1MDAxN1wiLCBcIlxcXFx1MDAxOFwiLCBcIlxcXFx1MDAxOVwiLCBcIlxcXFx1MDAxYVwiLCBcIlxcXFx1MDAxYlwiLCBcIlxcXFx1MDAxY1wiLCBcIlxcXFx1MDAxZFwiLCBcIlxcXFx1MDAxZVwiLCBcIlxcXFx1MDAxZlwiXTtcbnZhciBlc2NhcGVGbiA9IGZ1bmN0aW9uIGVzY2FwZUZuKHN0cikge1xuICByZXR1cm4gbWV0YVtzdHIuY2hhckNvZGVBdCgwKV07XG59O1xudmFyIHdhcm5lZCA9IGZhbHNlO1xuXG4vLyBUaGUgYXNzZXJ0IG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbnMgdGhhdCB0aHJvd1xuLy8gQXNzZXJ0aW9uRXJyb3IncyB3aGVuIHBhcnRpY3VsYXIgY29uZGl0aW9ucyBhcmUgbm90IG1ldC4gVGhlXG4vLyBhc3NlcnQgbW9kdWxlIG11c3QgY29uZm9ybSB0byB0aGUgZm9sbG93aW5nIGludGVyZmFjZS5cblxudmFyIGFzc2VydCA9IG1vZHVsZS5leHBvcnRzID0gb2s7XG52YXIgTk9fRVhDRVBUSU9OX1NFTlRJTkVMID0ge307XG5cbi8vIEFsbCBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IHRocm93IGFuIEFzc2VydGlvbkVycm9yXG4vLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxuLy8gbWF5IGJlIHVuZGVmaW5lZCBpZiBub3QgcHJvdmlkZWQuIEFsbCBhc3NlcnRpb24gbWV0aG9kcyBwcm92aWRlXG4vLyBib3RoIHRoZSBhY3R1YWwgYW5kIGV4cGVjdGVkIHZhbHVlcyB0byB0aGUgYXNzZXJ0aW9uIGVycm9yIGZvclxuLy8gZGlzcGxheSBwdXJwb3Nlcy5cblxuZnVuY3Rpb24gaW5uZXJGYWlsKG9iaikge1xuICBpZiAob2JqLm1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgb2JqLm1lc3NhZ2U7XG4gIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihvYmopO1xufVxuZnVuY3Rpb24gZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBvcGVyYXRvciwgc3RhY2tTdGFydEZuKSB7XG4gIHZhciBhcmdzTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGludGVybmFsTWVzc2FnZTtcbiAgaWYgKGFyZ3NMZW4gPT09IDApIHtcbiAgICBpbnRlcm5hbE1lc3NhZ2UgPSAnRmFpbGVkJztcbiAgfSBlbHNlIGlmIChhcmdzTGVuID09PSAxKSB7XG4gICAgbWVzc2FnZSA9IGFjdHVhbDtcbiAgICBhY3R1YWwgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHdhcm5lZCA9PT0gZmFsc2UpIHtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICB2YXIgd2FybiA9IHByb2Nlc3MuZW1pdFdhcm5pbmcgPyBwcm9jZXNzLmVtaXRXYXJuaW5nIDogY29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7XG4gICAgICB3YXJuKCdhc3NlcnQuZmFpbCgpIHdpdGggbW9yZSB0aGFuIG9uZSBhcmd1bWVudCBpcyBkZXByZWNhdGVkLiAnICsgJ1BsZWFzZSB1c2UgYXNzZXJ0LnN0cmljdEVxdWFsKCkgaW5zdGVhZCBvciBvbmx5IHBhc3MgYSBtZXNzYWdlLicsICdEZXByZWNhdGlvbldhcm5pbmcnLCAnREVQMDA5NCcpO1xuICAgIH1cbiAgICBpZiAoYXJnc0xlbiA9PT0gMikgb3BlcmF0b3IgPSAnIT0nO1xuICB9XG4gIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHRocm93IG1lc3NhZ2U7XG4gIHZhciBlcnJBcmdzID0ge1xuICAgIGFjdHVhbDogYWN0dWFsLFxuICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICBvcGVyYXRvcjogb3BlcmF0b3IgPT09IHVuZGVmaW5lZCA/ICdmYWlsJyA6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGbjogc3RhY2tTdGFydEZuIHx8IGZhaWxcbiAgfTtcbiAgaWYgKG1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgIGVyckFyZ3MubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH1cbiAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcihlcnJBcmdzKTtcbiAgaWYgKGludGVybmFsTWVzc2FnZSkge1xuICAgIGVyci5tZXNzYWdlID0gaW50ZXJuYWxNZXNzYWdlO1xuICAgIGVyci5nZW5lcmF0ZWRNZXNzYWdlID0gdHJ1ZTtcbiAgfVxuICB0aHJvdyBlcnI7XG59XG5hc3NlcnQuZmFpbCA9IGZhaWw7XG5cbi8vIFRoZSBBc3NlcnRpb25FcnJvciBpcyBkZWZpbmVkIGluIGludGVybmFsL2Vycm9yLlxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gQXNzZXJ0aW9uRXJyb3I7XG5mdW5jdGlvbiBpbm5lck9rKGZuLCBhcmdMZW4sIHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICB2YXIgZ2VuZXJhdGVkTWVzc2FnZSA9IGZhbHNlO1xuICAgIGlmIChhcmdMZW4gPT09IDApIHtcbiAgICAgIGdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICAgICAgbWVzc2FnZSA9ICdObyB2YWx1ZSBhcmd1bWVudCBwYXNzZWQgdG8gYGFzc2VydC5vaygpYCc7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IG1lc3NhZ2U7XG4gICAgfVxuICAgIHZhciBlcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgYWN0dWFsOiB2YWx1ZSxcbiAgICAgIGV4cGVjdGVkOiB0cnVlLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnPT0nLFxuICAgICAgc3RhY2tTdGFydEZuOiBmblxuICAgIH0pO1xuICAgIGVyci5nZW5lcmF0ZWRNZXNzYWdlID0gZ2VuZXJhdGVkTWVzc2FnZTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbn1cblxuLy8gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISF2YWx1ZS5cbmZ1bmN0aW9uIG9rKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIGlubmVyT2suYXBwbHkodm9pZCAwLCBbb2ssIGFyZ3MubGVuZ3RoXS5jb25jYXQoYXJncykpO1xufVxuYXNzZXJ0Lm9rID0gb2s7XG5cbi8vIFRoZSBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc2hhbGxvdywgY29lcmNpdmUgZXF1YWxpdHkgd2l0aCA9PS5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllcyAqL1xuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnPT0nLFxuICAgICAgc3RhY2tTdGFydEZuOiBlcXVhbFxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90XG4vLyBlcXVhbCB3aXRoICE9LlxuYXNzZXJ0Lm5vdEVxdWFsID0gZnVuY3Rpb24gbm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICBpZiAoYWN0dWFsID09IGV4cGVjdGVkKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnIT0nLFxuICAgICAgc3RhY2tTdGFydEZuOiBub3RFcXVhbFxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBUaGUgZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGEgZGVlcCBlcXVhbGl0eSByZWxhdGlvbi5cbmFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cbiAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xuICBpZiAoIWlzRGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnZGVlcEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogZGVlcEVxdWFsXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIG5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG4gIGlmIChpc0RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ25vdERlZXBFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IG5vdERlZXBFcXVhbFxuICAgIH0pO1xuICB9XG59O1xuLyogZXNsaW50LWVuYWJsZSAqL1xuXG5hc3NlcnQuZGVlcFN0cmljdEVxdWFsID0gZnVuY3Rpb24gZGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG4gIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKTtcbiAgaWYgKCFpc0RlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ2RlZXBTdHJpY3RFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IGRlZXBTdHJpY3RFcXVhbFxuICAgIH0pO1xuICB9XG59O1xuYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbCA9IG5vdERlZXBTdHJpY3RFcXVhbDtcbmZ1bmN0aW9uIG5vdERlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG4gIGlmIChpc0RlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ25vdERlZXBTdHJpY3RFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IG5vdERlZXBTdHJpY3RFcXVhbFxuICAgIH0pO1xuICB9XG59XG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuICBpZiAoIW9iamVjdElzKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnc3RyaWN0RXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBzdHJpY3RFcXVhbFxuICAgIH0pO1xuICB9XG59O1xuYXNzZXJ0Lm5vdFN0cmljdEVxdWFsID0gZnVuY3Rpb24gbm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cbiAgaWYgKG9iamVjdElzKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnbm90U3RyaWN0RXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBub3RTdHJpY3RFcXVhbFxuICAgIH0pO1xuICB9XG59O1xudmFyIENvbXBhcmlzb24gPSAvKiNfX1BVUkVfXyovX2NyZWF0ZUNsYXNzKGZ1bmN0aW9uIENvbXBhcmlzb24ob2JqLCBrZXlzLCBhY3R1YWwpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbXBhcmlzb24pO1xuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoYWN0dWFsICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGFjdHVhbFtrZXldID09PSAnc3RyaW5nJyAmJiBpc1JlZ0V4cChvYmpba2V5XSkgJiYgUmVnRXhwUHJvdG90eXBlVGVzdChvYmpba2V5XSwgYWN0dWFsW2tleV0pKSB7XG4gICAgICAgIF90aGlzW2tleV0gPSBhY3R1YWxba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzW2tleV0gPSBvYmpba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufSk7XG5mdW5jdGlvbiBjb21wYXJlRXhjZXB0aW9uS2V5KGFjdHVhbCwgZXhwZWN0ZWQsIGtleSwgbWVzc2FnZSwga2V5cywgZm4pIHtcbiAgaWYgKCEoa2V5IGluIGFjdHVhbCkgfHwgIWlzRGVlcFN0cmljdEVxdWFsKGFjdHVhbFtrZXldLCBleHBlY3RlZFtrZXldKSkge1xuICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgLy8gQ3JlYXRlIHBsYWNlaG9sZGVyIG9iamVjdHMgdG8gY3JlYXRlIGEgbmljZSBvdXRwdXQuXG4gICAgICB2YXIgYSA9IG5ldyBDb21wYXJpc29uKGFjdHVhbCwga2V5cyk7XG4gICAgICB2YXIgYiA9IG5ldyBDb21wYXJpc29uKGV4cGVjdGVkLCBrZXlzLCBhY3R1YWwpO1xuICAgICAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XG4gICAgICAgIGFjdHVhbDogYSxcbiAgICAgICAgZXhwZWN0ZWQ6IGIsXG4gICAgICAgIG9wZXJhdG9yOiAnZGVlcFN0cmljdEVxdWFsJyxcbiAgICAgICAgc3RhY2tTdGFydEZuOiBmblxuICAgICAgfSk7XG4gICAgICBlcnIuYWN0dWFsID0gYWN0dWFsO1xuICAgICAgZXJyLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gICAgICBlcnIub3BlcmF0b3IgPSBmbi5uYW1lO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6IGZuLm5hbWUsXG4gICAgICBzdGFja1N0YXJ0Rm46IGZuXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQsIG1zZywgZm4pIHtcbiAgaWYgKHR5cGVvZiBleHBlY3RlZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChpc1JlZ0V4cChleHBlY3RlZCkpIHJldHVybiBSZWdFeHBQcm90b3R5cGVUZXN0KGV4cGVjdGVkLCBhY3R1YWwpO1xuICAgIC8vIGFzc2VydC5kb2VzTm90VGhyb3cgZG9lcyBub3QgYWNjZXB0IG9iamVjdHMuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZXhwZWN0ZWQnLCBbJ0Z1bmN0aW9uJywgJ1JlZ0V4cCddLCBleHBlY3RlZCk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHByaW1pdGl2ZXMgcHJvcGVybHkuXG4gICAgaWYgKF90eXBlb2YoYWN0dWFsKSAhPT0gJ29iamVjdCcgfHwgYWN0dWFsID09PSBudWxsKSB7XG4gICAgICB2YXIgZXJyID0gbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgICBvcGVyYXRvcjogJ2RlZXBTdHJpY3RFcXVhbCcsXG4gICAgICAgIHN0YWNrU3RhcnRGbjogZm5cbiAgICAgIH0pO1xuICAgICAgZXJyLm9wZXJhdG9yID0gZm4ubmFtZTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhleHBlY3RlZCk7XG4gICAgLy8gU3BlY2lhbCBoYW5kbGUgZXJyb3JzIHRvIG1ha2Ugc3VyZSB0aGUgbmFtZSBhbmQgdGhlIG1lc3NhZ2UgYXJlIGNvbXBhcmVkXG4gICAgLy8gYXMgd2VsbC5cbiAgICBpZiAoZXhwZWN0ZWQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAga2V5cy5wdXNoKCduYW1lJywgJ21lc3NhZ2UnKTtcbiAgICB9IGVsc2UgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKCdlcnJvcicsIGV4cGVjdGVkLCAnbWF5IG5vdCBiZSBhbiBlbXB0eSBvYmplY3QnKTtcbiAgICB9XG4gICAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGFjdHVhbFtrZXldID09PSAnc3RyaW5nJyAmJiBpc1JlZ0V4cChleHBlY3RlZFtrZXldKSAmJiBSZWdFeHBQcm90b3R5cGVUZXN0KGV4cGVjdGVkW2tleV0sIGFjdHVhbFtrZXldKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb21wYXJlRXhjZXB0aW9uS2V5KGFjdHVhbCwgZXhwZWN0ZWQsIGtleSwgbXNnLCBrZXlzLCBmbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gR3VhcmQgaW5zdGFuY2VvZiBhZ2FpbnN0IGFycm93IGZ1bmN0aW9ucyBhcyB0aGV5IGRvbid0IGhhdmUgYSBwcm90b3R5cGUuXG4gIGlmIChleHBlY3RlZC5wcm90b3R5cGUgIT09IHVuZGVmaW5lZCAmJiBhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChFcnJvci5pc1Byb3RvdHlwZU9mKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldEFjdHVhbChmbikge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdmbicsICdGdW5jdGlvbicsIGZuKTtcbiAgfVxuICB0cnkge1xuICAgIGZuKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZTtcbiAgfVxuICByZXR1cm4gTk9fRVhDRVBUSU9OX1NFTlRJTkVMO1xufVxuZnVuY3Rpb24gY2hlY2tJc1Byb21pc2Uob2JqKSB7XG4gIC8vIEFjY2VwdCBuYXRpdmUgRVM2IHByb21pc2VzIGFuZCBwcm9taXNlcyB0aGF0IGFyZSBpbXBsZW1lbnRlZCBpbiBhIHNpbWlsYXJcbiAgLy8gd2F5LiBEbyBub3QgYWNjZXB0IHRoZW5hYmxlcyB0aGF0IHVzZSBhIGZ1bmN0aW9uIGFzIGBvYmpgIGFuZCB0aGF0IGhhdmUgbm9cbiAgLy8gYGNhdGNoYCBoYW5kbGVyLlxuXG4gIC8vIFRPRE86IHRoZW5hYmxlcyBhcmUgY2hlY2tlZCB1cCB1bnRpbCB0aGV5IGhhdmUgdGhlIGNvcnJlY3QgbWV0aG9kcyxcbiAgLy8gYnV0IGFjY29yZGluZyB0byBkb2N1bWVudGF0aW9uLCB0aGUgYHRoZW5gIG1ldGhvZCBzaG91bGQgcmVjZWl2ZVxuICAvLyB0aGUgYGZ1bGZpbGxgIGFuZCBgcmVqZWN0YCBhcmd1bWVudHMgYXMgd2VsbCBvciBpdCBtYXkgYmUgbmV2ZXIgcmVzb2x2ZWQuXG5cbiAgcmV0dXJuIGlzUHJvbWlzZShvYmopIHx8IG9iaiAhPT0gbnVsbCAmJiBfdHlwZW9mKG9iaikgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmoudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLmNhdGNoID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gd2FpdEZvckFjdHVhbChwcm9taXNlRm4pIHtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHRQcm9taXNlO1xuICAgIGlmICh0eXBlb2YgcHJvbWlzZUZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBSZXR1cm4gYSByZWplY3RlZCBwcm9taXNlIGlmIGBwcm9taXNlRm5gIHRocm93cyBzeW5jaHJvbm91c2x5LlxuICAgICAgcmVzdWx0UHJvbWlzZSA9IHByb21pc2VGbigpO1xuICAgICAgLy8gRmFpbCBpbiBjYXNlIG5vIHByb21pc2UgaXMgcmV0dXJuZWQuXG4gICAgICBpZiAoIWNoZWNrSXNQcm9taXNlKHJlc3VsdFByb21pc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUoJ2luc3RhbmNlIG9mIFByb21pc2UnLCAncHJvbWlzZUZuJywgcmVzdWx0UHJvbWlzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaGVja0lzUHJvbWlzZShwcm9taXNlRm4pKSB7XG4gICAgICByZXN1bHRQcm9taXNlID0gcHJvbWlzZUZuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ3Byb21pc2VGbicsIFsnRnVuY3Rpb24nLCAnUHJvbWlzZSddLCBwcm9taXNlRm4pO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVzdWx0UHJvbWlzZTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBOT19FWENFUFRJT05fU0VOVElORUw7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBlO1xuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGV4cGVjdHNFcnJvcihzdGFja1N0YXJ0Rm4sIGFjdHVhbCwgZXJyb3IsIG1lc3NhZ2UpIHtcbiAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdlcnJvcicsIFsnT2JqZWN0JywgJ0Vycm9yJywgJ0Z1bmN0aW9uJywgJ1JlZ0V4cCddLCBlcnJvcik7XG4gICAgfVxuICAgIGlmIChfdHlwZW9mKGFjdHVhbCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGFjdHVhbC5tZXNzYWdlID09PSBlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRVJSX0FNQklHVU9VU19BUkdVTUVOVCgnZXJyb3IvbWVzc2FnZScsIFwiVGhlIGVycm9yIG1lc3NhZ2UgXFxcIlwiLmNvbmNhdChhY3R1YWwubWVzc2FnZSwgXCJcXFwiIGlzIGlkZW50aWNhbCB0byB0aGUgbWVzc2FnZS5cIikpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYWN0dWFsID09PSBlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVSUl9BTUJJR1VPVVNfQVJHVU1FTlQoJ2Vycm9yL21lc3NhZ2UnLCBcIlRoZSBlcnJvciBcXFwiXCIuY29uY2F0KGFjdHVhbCwgXCJcXFwiIGlzIGlkZW50aWNhbCB0byB0aGUgbWVzc2FnZS5cIikpO1xuICAgIH1cbiAgICBtZXNzYWdlID0gZXJyb3I7XG4gICAgZXJyb3IgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAoZXJyb3IgIT0gbnVsbCAmJiBfdHlwZW9mKGVycm9yKSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdlcnJvcicsIFsnT2JqZWN0JywgJ0Vycm9yJywgJ0Z1bmN0aW9uJywgJ1JlZ0V4cCddLCBlcnJvcik7XG4gIH1cbiAgaWYgKGFjdHVhbCA9PT0gTk9fRVhDRVBUSU9OX1NFTlRJTkVMKSB7XG4gICAgdmFyIGRldGFpbHMgPSAnJztcbiAgICBpZiAoZXJyb3IgJiYgZXJyb3IubmFtZSkge1xuICAgICAgZGV0YWlscyArPSBcIiAoXCIuY29uY2F0KGVycm9yLm5hbWUsIFwiKVwiKTtcbiAgICB9XG4gICAgZGV0YWlscyArPSBtZXNzYWdlID8gXCI6IFwiLmNvbmNhdChtZXNzYWdlKSA6ICcuJztcbiAgICB2YXIgZm5UeXBlID0gc3RhY2tTdGFydEZuLm5hbWUgPT09ICdyZWplY3RzJyA/ICdyZWplY3Rpb24nIDogJ2V4Y2VwdGlvbic7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogdW5kZWZpbmVkLFxuICAgICAgZXhwZWN0ZWQ6IGVycm9yLFxuICAgICAgb3BlcmF0b3I6IHN0YWNrU3RhcnRGbi5uYW1lLFxuICAgICAgbWVzc2FnZTogXCJNaXNzaW5nIGV4cGVjdGVkIFwiLmNvbmNhdChmblR5cGUpLmNvbmNhdChkZXRhaWxzKSxcbiAgICAgIHN0YWNrU3RhcnRGbjogc3RhY2tTdGFydEZuXG4gICAgfSk7XG4gIH1cbiAgaWYgKGVycm9yICYmICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGVycm9yLCBtZXNzYWdlLCBzdGFja1N0YXJ0Rm4pKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5mdW5jdGlvbiBleHBlY3RzTm9FcnJvcihzdGFja1N0YXJ0Rm4sIGFjdHVhbCwgZXJyb3IsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gTk9fRVhDRVBUSU9OX1NFTlRJTkVMKSByZXR1cm47XG4gIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgbWVzc2FnZSA9IGVycm9yO1xuICAgIGVycm9yID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmICghZXJyb3IgfHwgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBlcnJvcikpIHtcbiAgICB2YXIgZGV0YWlscyA9IG1lc3NhZ2UgPyBcIjogXCIuY29uY2F0KG1lc3NhZ2UpIDogJy4nO1xuICAgIHZhciBmblR5cGUgPSBzdGFja1N0YXJ0Rm4ubmFtZSA9PT0gJ2RvZXNOb3RSZWplY3QnID8gJ3JlamVjdGlvbicgOiAnZXhjZXB0aW9uJztcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXJyb3IsXG4gICAgICBvcGVyYXRvcjogc3RhY2tTdGFydEZuLm5hbWUsXG4gICAgICBtZXNzYWdlOiBcIkdvdCB1bndhbnRlZCBcIi5jb25jYXQoZm5UeXBlKS5jb25jYXQoZGV0YWlscywgXCJcXG5cIikgKyBcIkFjdHVhbCBtZXNzYWdlOiBcXFwiXCIuY29uY2F0KGFjdHVhbCAmJiBhY3R1YWwubWVzc2FnZSwgXCJcXFwiXCIpLFxuICAgICAgc3RhY2tTdGFydEZuOiBzdGFja1N0YXJ0Rm5cbiAgICB9KTtcbiAgfVxuICB0aHJvdyBhY3R1YWw7XG59XG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24gdGhyb3dzKHByb21pc2VGbikge1xuICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cbiAgZXhwZWN0c0Vycm9yLmFwcGx5KHZvaWQgMCwgW3Rocm93cywgZ2V0QWN0dWFsKHByb21pc2VGbildLmNvbmNhdChhcmdzKSk7XG59O1xuYXNzZXJ0LnJlamVjdHMgPSBmdW5jdGlvbiByZWplY3RzKHByb21pc2VGbikge1xuICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMgPiAxID8gX2xlbjMgLSAxIDogMCksIF9rZXkzID0gMTsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgIGFyZ3NbX2tleTMgLSAxXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gIH1cbiAgcmV0dXJuIHdhaXRGb3JBY3R1YWwocHJvbWlzZUZuKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICByZXR1cm4gZXhwZWN0c0Vycm9yLmFwcGx5KHZvaWQgMCwgW3JlamVjdHMsIHJlc3VsdF0uY29uY2F0KGFyZ3MpKTtcbiAgfSk7XG59O1xuYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGZ1bmN0aW9uIGRvZXNOb3RUaHJvdyhmbikge1xuICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQgPiAxID8gX2xlbjQgLSAxIDogMCksIF9rZXk0ID0gMTsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgIGFyZ3NbX2tleTQgLSAxXSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gIH1cbiAgZXhwZWN0c05vRXJyb3IuYXBwbHkodm9pZCAwLCBbZG9lc05vdFRocm93LCBnZXRBY3R1YWwoZm4pXS5jb25jYXQoYXJncykpO1xufTtcbmFzc2VydC5kb2VzTm90UmVqZWN0ID0gZnVuY3Rpb24gZG9lc05vdFJlamVjdChmbikge1xuICBmb3IgKHZhciBfbGVuNSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUgPiAxID8gX2xlbjUgLSAxIDogMCksIF9rZXk1ID0gMTsgX2tleTUgPCBfbGVuNTsgX2tleTUrKykge1xuICAgIGFyZ3NbX2tleTUgLSAxXSA9IGFyZ3VtZW50c1tfa2V5NV07XG4gIH1cbiAgcmV0dXJuIHdhaXRGb3JBY3R1YWwoZm4pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHJldHVybiBleHBlY3RzTm9FcnJvci5hcHBseSh2b2lkIDAsIFtkb2VzTm90UmVqZWN0LCByZXN1bHRdLmNvbmNhdChhcmdzKSk7XG4gIH0pO1xufTtcbmFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24gaWZFcnJvcihlcnIpIHtcbiAgaWYgKGVyciAhPT0gbnVsbCAmJiBlcnIgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBtZXNzYWdlID0gJ2lmRXJyb3IgZ290IHVud2FudGVkIGV4Y2VwdGlvbjogJztcbiAgICBpZiAoX3R5cGVvZihlcnIpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZXJyLm1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoZXJyLm1lc3NhZ2UubGVuZ3RoID09PSAwICYmIGVyci5jb25zdHJ1Y3Rvcikge1xuICAgICAgICBtZXNzYWdlICs9IGVyci5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVzc2FnZSArPSBlcnIubWVzc2FnZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZSArPSBpbnNwZWN0KGVycik7XG4gICAgfVxuICAgIHZhciBuZXdFcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgYWN0dWFsOiBlcnIsXG4gICAgICBleHBlY3RlZDogbnVsbCxcbiAgICAgIG9wZXJhdG9yOiAnaWZFcnJvcicsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgc3RhY2tTdGFydEZuOiBpZkVycm9yXG4gICAgfSk7XG5cbiAgICAvLyBNYWtlIHN1cmUgd2UgYWN0dWFsbHkgaGF2ZSBhIHN0YWNrIHRyYWNlIVxuICAgIHZhciBvcmlnU3RhY2sgPSBlcnIuc3RhY2s7XG4gICAgaWYgKHR5cGVvZiBvcmlnU3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIHdpbGwgcmVtb3ZlIGFueSBkdXBsaWNhdGVkIGZyYW1lcyBmcm9tIHRoZSBlcnJvciBmcmFtZXMgdGFrZW5cbiAgICAgIC8vIGZyb20gd2l0aGluIGBpZkVycm9yYCBhbmQgYWRkIHRoZSBvcmlnaW5hbCBlcnJvciBmcmFtZXMgdG8gdGhlIG5ld2x5XG4gICAgICAvLyBjcmVhdGVkIG9uZXMuXG4gICAgICB2YXIgdG1wMiA9IG9yaWdTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB0bXAyLnNoaWZ0KCk7XG4gICAgICAvLyBGaWx0ZXIgYWxsIGZyYW1lcyBleGlzdGluZyBpbiBlcnIuc3RhY2suXG4gICAgICB2YXIgdG1wMSA9IG5ld0Vyci5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRtcDIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRmluZCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiB0aGUgZnJhbWUuXG4gICAgICAgIHZhciBwb3MgPSB0bXAxLmluZGV4T2YodG1wMltpXSk7XG4gICAgICAgIGlmIChwb3MgIT09IC0xKSB7XG4gICAgICAgICAgLy8gT25seSBrZWVwIG5ldyBmcmFtZXMuXG4gICAgICAgICAgdG1wMSA9IHRtcDEuc2xpY2UoMCwgcG9zKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV3RXJyLnN0YWNrID0gXCJcIi5jb25jYXQodG1wMS5qb2luKCdcXG4nKSwgXCJcXG5cIikuY29uY2F0KHRtcDIuam9pbignXFxuJykpO1xuICAgIH1cbiAgICB0aHJvdyBuZXdFcnI7XG4gIH1cbn07XG5cbi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvYXNzZXJ0LmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzJhODcxZGYzZGZiOGVhNjYzZWY1ZTFmOGY2MjcwMWVjNTEzODRlY2JcbmZ1bmN0aW9uIGludGVybmFsTWF0Y2goc3RyaW5nLCByZWdleHAsIG1lc3NhZ2UsIGZuLCBmbk5hbWUpIHtcbiAgaWYgKCFpc1JlZ0V4cChyZWdleHApKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdyZWdleHAnLCAnUmVnRXhwJywgcmVnZXhwKTtcbiAgfVxuICB2YXIgbWF0Y2ggPSBmbk5hbWUgPT09ICdtYXRjaCc7XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJyB8fCBSZWdFeHBQcm90b3R5cGVUZXN0KHJlZ2V4cCwgc3RyaW5nKSAhPT0gbWF0Y2gpIHtcbiAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBtZXNzYWdlO1xuICAgIH1cbiAgICB2YXIgZ2VuZXJhdGVkTWVzc2FnZSA9ICFtZXNzYWdlO1xuXG4gICAgLy8gJ1RoZSBpbnB1dCB3YXMgZXhwZWN0ZWQgdG8gbm90IG1hdGNoIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gJyArXG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnID8gJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgJyArIFwiXCIuY29uY2F0KF90eXBlb2Yoc3RyaW5nKSwgXCIgKFwiKS5jb25jYXQoaW5zcGVjdChzdHJpbmcpLCBcIilcIikgOiAobWF0Y2ggPyAnVGhlIGlucHV0IGRpZCBub3QgbWF0Y2ggdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiAnIDogJ1RoZSBpbnB1dCB3YXMgZXhwZWN0ZWQgdG8gbm90IG1hdGNoIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gJykgKyBcIlwiLmNvbmNhdChpbnNwZWN0KHJlZ2V4cCksIFwiLiBJbnB1dDpcXG5cXG5cIikuY29uY2F0KGluc3BlY3Qoc3RyaW5nKSwgXCJcXG5cIikpO1xuICAgIHZhciBlcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgYWN0dWFsOiBzdHJpbmcsXG4gICAgICBleHBlY3RlZDogcmVnZXhwLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiBmbk5hbWUsXG4gICAgICBzdGFja1N0YXJ0Rm46IGZuXG4gICAgfSk7XG4gICAgZXJyLmdlbmVyYXRlZE1lc3NhZ2UgPSBnZW5lcmF0ZWRNZXNzYWdlO1xuICAgIHRocm93IGVycjtcbiAgfVxufVxuYXNzZXJ0Lm1hdGNoID0gZnVuY3Rpb24gbWF0Y2goc3RyaW5nLCByZWdleHAsIG1lc3NhZ2UpIHtcbiAgaW50ZXJuYWxNYXRjaChzdHJpbmcsIHJlZ2V4cCwgbWVzc2FnZSwgbWF0Y2gsICdtYXRjaCcpO1xufTtcbmFzc2VydC5kb2VzTm90TWF0Y2ggPSBmdW5jdGlvbiBkb2VzTm90TWF0Y2goc3RyaW5nLCByZWdleHAsIG1lc3NhZ2UpIHtcbiAgaW50ZXJuYWxNYXRjaChzdHJpbmcsIHJlZ2V4cCwgbWVzc2FnZSwgZG9lc05vdE1hdGNoLCAnZG9lc05vdE1hdGNoJyk7XG59O1xuXG4vLyBFeHBvc2UgYSBzdHJpY3Qgb25seSB2YXJpYW50IG9mIGFzc2VydFxuZnVuY3Rpb24gc3RyaWN0KCkge1xuICBmb3IgKHZhciBfbGVuNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjYpLCBfa2V5NiA9IDA7IF9rZXk2IDwgX2xlbjY7IF9rZXk2KyspIHtcbiAgICBhcmdzW19rZXk2XSA9IGFyZ3VtZW50c1tfa2V5Nl07XG4gIH1cbiAgaW5uZXJPay5hcHBseSh2b2lkIDAsIFtzdHJpY3QsIGFyZ3MubGVuZ3RoXS5jb25jYXQoYXJncykpO1xufVxuYXNzZXJ0LnN0cmljdCA9IG9iamVjdEFzc2lnbihzdHJpY3QsIGFzc2VydCwge1xuICBlcXVhbDogYXNzZXJ0LnN0cmljdEVxdWFsLFxuICBkZWVwRXF1YWw6IGFzc2VydC5kZWVwU3RyaWN0RXF1YWwsXG4gIG5vdEVxdWFsOiBhc3NlcnQubm90U3RyaWN0RXF1YWwsXG4gIG5vdERlZXBFcXVhbDogYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbFxufSk7XG5hc3NlcnQuc3RyaWN0LnN0cmljdCA9IGFzc2VydC5zdHJpY3Q7IiwiLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC9hc3NlcnQvYXNzZXJ0aW9uX2Vycm9yLmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzA4MTc4NDBmNzc1MDMyMTY5ZGRkNzBjODVhYzA1OWYxOGZmY2M4MWNcblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gX3R5cGVvZihrZXkpID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAoX3R5cGVvZihyZXMpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDsgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzczsgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikgeyBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTsgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7IH0gZnVuY3Rpb24gV3JhcHBlcigpIHsgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTsgfSBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBXcmFwcGVyLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTsgfTsgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpOyB9XG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgaWYgKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkgeyBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3QuYmluZCgpOyB9IGVsc2UgeyBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IHZhciBhID0gW251bGxdOyBhLnB1c2guYXBwbHkoYSwgYXJncyk7IHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTsgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7IGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpOyByZXR1cm4gaW5zdGFuY2U7IH07IH0gcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikgeyByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xOyB9XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJ3V0aWwvJyksXG4gIGluc3BlY3QgPSBfcmVxdWlyZS5pbnNwZWN0O1xudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLFxuICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlMi5jb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRTtcblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2VuZHNXaXRoXG5mdW5jdGlvbiBlbmRzV2l0aChzdHIsIHNlYXJjaCwgdGhpc19sZW4pIHtcbiAgaWYgKHRoaXNfbGVuID09PSB1bmRlZmluZWQgfHwgdGhpc19sZW4gPiBzdHIubGVuZ3RoKSB7XG4gICAgdGhpc19sZW4gPSBzdHIubGVuZ3RoO1xuICB9XG4gIHJldHVybiBzdHIuc3Vic3RyaW5nKHRoaXNfbGVuIC0gc2VhcmNoLmxlbmd0aCwgdGhpc19sZW4pID09PSBzZWFyY2g7XG59XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9yZXBlYXRcbmZ1bmN0aW9uIHJlcGVhdChzdHIsIGNvdW50KSB7XG4gIGNvdW50ID0gTWF0aC5mbG9vcihjb3VudCk7XG4gIGlmIChzdHIubGVuZ3RoID09IDAgfHwgY291bnQgPT0gMCkgcmV0dXJuICcnO1xuICB2YXIgbWF4Q291bnQgPSBzdHIubGVuZ3RoICogY291bnQ7XG4gIGNvdW50ID0gTWF0aC5mbG9vcihNYXRoLmxvZyhjb3VudCkgLyBNYXRoLmxvZygyKSk7XG4gIHdoaWxlIChjb3VudCkge1xuICAgIHN0ciArPSBzdHI7XG4gICAgY291bnQtLTtcbiAgfVxuICBzdHIgKz0gc3RyLnN1YnN0cmluZygwLCBtYXhDb3VudCAtIHN0ci5sZW5ndGgpO1xuICByZXR1cm4gc3RyO1xufVxudmFyIGJsdWUgPSAnJztcbnZhciBncmVlbiA9ICcnO1xudmFyIHJlZCA9ICcnO1xudmFyIHdoaXRlID0gJyc7XG52YXIga1JlYWRhYmxlT3BlcmF0b3IgPSB7XG4gIGRlZXBTdHJpY3RFcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBzdHJpY3RseSBkZWVwLWVxdWFsOicsXG4gIHN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIHN0cmljdGx5IGVxdWFsOicsXG4gIHN0cmljdEVxdWFsT2JqZWN0OiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSByZWZlcmVuY2UtZXF1YWwgdG8gXCJleHBlY3RlZFwiOicsXG4gIGRlZXBFcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBsb29zZWx5IGRlZXAtZXF1YWw6JyxcbiAgZXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgbG9vc2VseSBlcXVhbDonLFxuICBub3REZWVwU3RyaWN0RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSBzdHJpY3RseSBkZWVwLWVxdWFsIHRvOicsXG4gIG5vdFN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSBzdHJpY3RseSB1bmVxdWFsIHRvOicsXG4gIG5vdFN0cmljdEVxdWFsT2JqZWN0OiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiBub3QgdG8gYmUgcmVmZXJlbmNlLWVxdWFsIHRvIFwiZXhwZWN0ZWRcIjonLFxuICBub3REZWVwRXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSBsb29zZWx5IGRlZXAtZXF1YWwgdG86JyxcbiAgbm90RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIHRvIGJlIGxvb3NlbHkgdW5lcXVhbCB0bzonLFxuICBub3RJZGVudGljYWw6ICdWYWx1ZXMgaWRlbnRpY2FsIGJ1dCBub3QgcmVmZXJlbmNlLWVxdWFsOidcbn07XG5cbi8vIENvbXBhcmluZyBzaG9ydCBwcmltaXRpdmVzIHNob3VsZCBqdXN0IHNob3cgPT09IC8gIT09IGluc3RlYWQgb2YgdXNpbmcgdGhlXG4vLyBkaWZmLlxudmFyIGtNYXhTaG9ydExlbmd0aCA9IDEwO1xuZnVuY3Rpb24gY29weUVycm9yKHNvdXJjZSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciB0YXJnZXQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihzb3VyY2UpKTtcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgJ21lc3NhZ2UnLCB7XG4gICAgdmFsdWU6IHNvdXJjZS5tZXNzYWdlXG4gIH0pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gaW5zcGVjdFZhbHVlKHZhbCkge1xuICAvLyBUaGUgdXRpbC5pbnNwZWN0IGRlZmF1bHQgdmFsdWVzIGNvdWxkIGJlIGNoYW5nZWQuIFRoaXMgbWFrZXMgc3VyZSB0aGVcbiAgLy8gZXJyb3IgbWVzc2FnZXMgY29udGFpbiB0aGUgbmVjZXNzYXJ5IGluZm9ybWF0aW9uIG5ldmVydGhlbGVzcy5cbiAgcmV0dXJuIGluc3BlY3QodmFsLCB7XG4gICAgY29tcGFjdDogZmFsc2UsXG4gICAgY3VzdG9tSW5zcGVjdDogZmFsc2UsXG4gICAgZGVwdGg6IDEwMDAsXG4gICAgbWF4QXJyYXlMZW5ndGg6IEluZmluaXR5LFxuICAgIC8vIEFzc2VydCBjb21wYXJlcyBvbmx5IGVudW1lcmFibGUgcHJvcGVydGllcyAod2l0aCBhIGZldyBleGNlcHRpb25zKS5cbiAgICBzaG93SGlkZGVuOiBmYWxzZSxcbiAgICAvLyBIYXZpbmcgYSBsb25nIGxpbmUgYXMgZXJyb3IgaXMgYmV0dGVyIHRoYW4gd3JhcHBpbmcgdGhlIGxpbmUgZm9yXG4gICAgLy8gY29tcGFyaXNvbiBmb3Igbm93LlxuICAgIC8vIFRPRE8oQnJpZGdlQVIpOiBgYnJlYWtMZW5ndGhgIHNob3VsZCBiZSBsaW1pdGVkIGFzIHNvb24gYXMgc29vbiBhcyB3ZVxuICAgIC8vIGhhdmUgbWV0YSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaW5zcGVjdGVkIHByb3BlcnRpZXMgKGkuZS4sIGtub3cgd2hlcmVcbiAgICAvLyBpbiB3aGF0IGxpbmUgdGhlIHByb3BlcnR5IHN0YXJ0cyBhbmQgZW5kcykuXG4gICAgYnJlYWtMZW5ndGg6IEluZmluaXR5LFxuICAgIC8vIEFzc2VydCBkb2VzIG5vdCBkZXRlY3QgcHJveGllcyBjdXJyZW50bHkuXG4gICAgc2hvd1Byb3h5OiBmYWxzZSxcbiAgICBzb3J0ZWQ6IHRydWUsXG4gICAgLy8gSW5zcGVjdCBnZXR0ZXJzIGFzIHdlIGFsc28gY2hlY2sgdGhlbSB3aGVuIGNvbXBhcmluZyBlbnRyaWVzLlxuICAgIGdldHRlcnM6IHRydWVcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVFcnJEaWZmKGFjdHVhbCwgZXhwZWN0ZWQsIG9wZXJhdG9yKSB7XG4gIHZhciBvdGhlciA9ICcnO1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBsYXN0UG9zID0gMDtcbiAgdmFyIGVuZCA9ICcnO1xuICB2YXIgc2tpcHBlZCA9IGZhbHNlO1xuICB2YXIgYWN0dWFsSW5zcGVjdGVkID0gaW5zcGVjdFZhbHVlKGFjdHVhbCk7XG4gIHZhciBhY3R1YWxMaW5lcyA9IGFjdHVhbEluc3BlY3RlZC5zcGxpdCgnXFxuJyk7XG4gIHZhciBleHBlY3RlZExpbmVzID0gaW5zcGVjdFZhbHVlKGV4cGVjdGVkKS5zcGxpdCgnXFxuJyk7XG4gIHZhciBpID0gMDtcbiAgdmFyIGluZGljYXRvciA9ICcnO1xuXG4gIC8vIEluIGNhc2UgYm90aCB2YWx1ZXMgYXJlIG9iamVjdHMgZXhwbGljaXRseSBtYXJrIHRoZW0gYXMgbm90IHJlZmVyZW5jZSBlcXVhbFxuICAvLyBmb3IgdGhlIGBzdHJpY3RFcXVhbGAgb3BlcmF0b3IuXG4gIGlmIChvcGVyYXRvciA9PT0gJ3N0cmljdEVxdWFsJyAmJiBfdHlwZW9mKGFjdHVhbCkgPT09ICdvYmplY3QnICYmIF90eXBlb2YoZXhwZWN0ZWQpID09PSAnb2JqZWN0JyAmJiBhY3R1YWwgIT09IG51bGwgJiYgZXhwZWN0ZWQgIT09IG51bGwpIHtcbiAgICBvcGVyYXRvciA9ICdzdHJpY3RFcXVhbE9iamVjdCc7XG4gIH1cblxuICAvLyBJZiBcImFjdHVhbFwiIGFuZCBcImV4cGVjdGVkXCIgZml0IG9uIGEgc2luZ2xlIGxpbmUgYW5kIHRoZXkgYXJlIG5vdCBzdHJpY3RseVxuICAvLyBlcXVhbCwgY2hlY2sgZnVydGhlciBzcGVjaWFsIGhhbmRsaW5nLlxuICBpZiAoYWN0dWFsTGluZXMubGVuZ3RoID09PSAxICYmIGV4cGVjdGVkTGluZXMubGVuZ3RoID09PSAxICYmIGFjdHVhbExpbmVzWzBdICE9PSBleHBlY3RlZExpbmVzWzBdKSB7XG4gICAgdmFyIGlucHV0TGVuZ3RoID0gYWN0dWFsTGluZXNbMF0ubGVuZ3RoICsgZXhwZWN0ZWRMaW5lc1swXS5sZW5ndGg7XG4gICAgLy8gSWYgdGhlIGNoYXJhY3RlciBsZW5ndGggb2YgXCJhY3R1YWxcIiBhbmQgXCJleHBlY3RlZFwiIHRvZ2V0aGVyIGlzIGxlc3MgdGhhblxuICAgIC8vIGtNYXhTaG9ydExlbmd0aCBhbmQgaWYgbmVpdGhlciBpcyBhbiBvYmplY3QgYW5kIGF0IGxlYXN0IG9uZSBvZiB0aGVtIGlzXG4gICAgLy8gbm90IGB6ZXJvYCwgdXNlIHRoZSBzdHJpY3QgZXF1YWwgY29tcGFyaXNvbiB0byB2aXN1YWxpemUgdGhlIG91dHB1dC5cbiAgICBpZiAoaW5wdXRMZW5ndGggPD0ga01heFNob3J0TGVuZ3RoKSB7XG4gICAgICBpZiAoKF90eXBlb2YoYWN0dWFsKSAhPT0gJ29iamVjdCcgfHwgYWN0dWFsID09PSBudWxsKSAmJiAoX3R5cGVvZihleHBlY3RlZCkgIT09ICdvYmplY3QnIHx8IGV4cGVjdGVkID09PSBudWxsKSAmJiAoYWN0dWFsICE9PSAwIHx8IGV4cGVjdGVkICE9PSAwKSkge1xuICAgICAgICAvLyAtMCA9PT0gKzBcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXSwgXCJcXG5cXG5cIikgKyBcIlwiLmNvbmNhdChhY3R1YWxMaW5lc1swXSwgXCIgIT09IFwiKS5jb25jYXQoZXhwZWN0ZWRMaW5lc1swXSwgXCJcXG5cIik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcGVyYXRvciAhPT0gJ3N0cmljdEVxdWFsT2JqZWN0Jykge1xuICAgICAgLy8gSWYgdGhlIHN0ZGVyciBpcyBhIHR0eSBhbmQgdGhlIGlucHV0IGxlbmd0aCBpcyBsb3dlciB0aGFuIHRoZSBjdXJyZW50XG4gICAgICAvLyBjb2x1bW5zIHBlciBsaW5lLCBhZGQgYSBtaXNtYXRjaCBpbmRpY2F0b3IgYmVsb3cgdGhlIG91dHB1dC4gSWYgaXQgaXNcbiAgICAgIC8vIG5vdCBhIHR0eSwgdXNlIGEgZGVmYXVsdCB2YWx1ZSBvZiA4MCBjaGFyYWN0ZXJzLlxuICAgICAgdmFyIG1heExlbmd0aCA9IHByb2Nlc3Muc3RkZXJyICYmIHByb2Nlc3Muc3RkZXJyLmlzVFRZID8gcHJvY2Vzcy5zdGRlcnIuY29sdW1ucyA6IDgwO1xuICAgICAgaWYgKGlucHV0TGVuZ3RoIDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgIHdoaWxlIChhY3R1YWxMaW5lc1swXVtpXSA9PT0gZXhwZWN0ZWRMaW5lc1swXVtpXSkge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpcnN0IGNoYXJhY3RlcnMuXG4gICAgICAgIGlmIChpID4gMikge1xuICAgICAgICAgIC8vIEFkZCBwb3NpdGlvbiBpbmRpY2F0b3IgZm9yIHRoZSBmaXJzdCBtaXNtYXRjaCBpbiBjYXNlIGl0IGlzIGFcbiAgICAgICAgICAvLyBzaW5nbGUgbGluZSBhbmQgdGhlIGlucHV0IGxlbmd0aCBpcyBsZXNzIHRoYW4gdGhlIGNvbHVtbiBsZW5ndGguXG4gICAgICAgICAgaW5kaWNhdG9yID0gXCJcXG4gIFwiLmNvbmNhdChyZXBlYXQoJyAnLCBpKSwgXCJeXCIpO1xuICAgICAgICAgIGkgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmVtb3ZlIGFsbCBlbmRpbmcgbGluZXMgdGhhdCBtYXRjaCAodGhpcyBvcHRpbWl6ZXMgdGhlIG91dHB1dCBmb3JcbiAgLy8gcmVhZGFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIG51bWJlciBvZiB0b3RhbCBjaGFuZ2VkIGxpbmVzKS5cbiAgdmFyIGEgPSBhY3R1YWxMaW5lc1thY3R1YWxMaW5lcy5sZW5ndGggLSAxXTtcbiAgdmFyIGIgPSBleHBlY3RlZExpbmVzW2V4cGVjdGVkTGluZXMubGVuZ3RoIC0gMV07XG4gIHdoaWxlIChhID09PSBiKSB7XG4gICAgaWYgKGkrKyA8IDIpIHtcbiAgICAgIGVuZCA9IFwiXFxuICBcIi5jb25jYXQoYSkuY29uY2F0KGVuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG90aGVyID0gYTtcbiAgICB9XG4gICAgYWN0dWFsTGluZXMucG9wKCk7XG4gICAgZXhwZWN0ZWRMaW5lcy5wb3AoKTtcbiAgICBpZiAoYWN0dWFsTGluZXMubGVuZ3RoID09PSAwIHx8IGV4cGVjdGVkTGluZXMubGVuZ3RoID09PSAwKSBicmVhaztcbiAgICBhID0gYWN0dWFsTGluZXNbYWN0dWFsTGluZXMubGVuZ3RoIC0gMV07XG4gICAgYiA9IGV4cGVjdGVkTGluZXNbZXhwZWN0ZWRMaW5lcy5sZW5ndGggLSAxXTtcbiAgfVxuICB2YXIgbWF4TGluZXMgPSBNYXRoLm1heChhY3R1YWxMaW5lcy5sZW5ndGgsIGV4cGVjdGVkTGluZXMubGVuZ3RoKTtcbiAgLy8gU3RyaWN0IGVxdWFsIHdpdGggaWRlbnRpY2FsIG9iamVjdHMgdGhhdCBhcmUgbm90IGlkZW50aWNhbCBieSByZWZlcmVuY2UuXG4gIC8vIEUuZy4sIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoeyBhOiBTeW1ib2woKSB9LCB7IGE6IFN5bWJvbCgpIH0pXG4gIGlmIChtYXhMaW5lcyA9PT0gMCkge1xuICAgIC8vIFdlIGhhdmUgdG8gZ2V0IHRoZSByZXN1bHQgYWdhaW4uIFRoZSBsaW5lcyB3ZXJlIGFsbCByZW1vdmVkIGJlZm9yZS5cbiAgICB2YXIgX2FjdHVhbExpbmVzID0gYWN0dWFsSW5zcGVjdGVkLnNwbGl0KCdcXG4nKTtcblxuICAgIC8vIE9ubHkgcmVtb3ZlIGxpbmVzIGluIGNhc2UgaXQgbWFrZXMgc2Vuc2UgdG8gY29sbGFwc2UgdGhvc2UuXG4gICAgLy8gVE9ETzogQWNjZXB0IGVudiB0byBhbHdheXMgc2hvdyB0aGUgZnVsbCBlcnJvci5cbiAgICBpZiAoX2FjdHVhbExpbmVzLmxlbmd0aCA+IDMwKSB7XG4gICAgICBfYWN0dWFsTGluZXNbMjZdID0gXCJcIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKTtcbiAgICAgIHdoaWxlIChfYWN0dWFsTGluZXMubGVuZ3RoID4gMjcpIHtcbiAgICAgICAgX2FjdHVhbExpbmVzLnBvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCJcIi5jb25jYXQoa1JlYWRhYmxlT3BlcmF0b3Iubm90SWRlbnRpY2FsLCBcIlxcblxcblwiKS5jb25jYXQoX2FjdHVhbExpbmVzLmpvaW4oJ1xcbicpLCBcIlxcblwiKTtcbiAgfVxuICBpZiAoaSA+IDMpIHtcbiAgICBlbmQgPSBcIlxcblwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpLmNvbmNhdChlbmQpO1xuICAgIHNraXBwZWQgPSB0cnVlO1xuICB9XG4gIGlmIChvdGhlciAhPT0gJycpIHtcbiAgICBlbmQgPSBcIlxcbiAgXCIuY29uY2F0KG90aGVyKS5jb25jYXQoZW5kKTtcbiAgICBvdGhlciA9ICcnO1xuICB9XG4gIHZhciBwcmludGVkTGluZXMgPSAwO1xuICB2YXIgbXNnID0ga1JlYWRhYmxlT3BlcmF0b3Jbb3BlcmF0b3JdICsgXCJcXG5cIi5jb25jYXQoZ3JlZW4sIFwiKyBhY3R1YWxcIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KHJlZCwgXCItIGV4cGVjdGVkXCIpLmNvbmNhdCh3aGl0ZSk7XG4gIHZhciBza2lwcGVkTXNnID0gXCIgXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSwgXCIgTGluZXMgc2tpcHBlZFwiKTtcbiAgZm9yIChpID0gMDsgaSA8IG1heExpbmVzOyBpKyspIHtcbiAgICAvLyBPbmx5IGV4dHJhIGV4cGVjdGVkIGxpbmVzIGV4aXN0XG4gICAgdmFyIGN1ciA9IGkgLSBsYXN0UG9zO1xuICAgIGlmIChhY3R1YWxMaW5lcy5sZW5ndGggPCBpICsgMSkge1xuICAgICAgLy8gSWYgdGhlIGxhc3QgZGl2ZXJnaW5nIGxpbmUgaXMgbW9yZSB0aGFuIG9uZSBsaW5lIGFib3ZlIGFuZCB0aGVcbiAgICAgIC8vIGN1cnJlbnQgbGluZSBpcyBhdCBsZWFzdCBsaW5lIHRocmVlLCBhZGQgc29tZSBvZiB0aGUgZm9ybWVyIGxpbmVzIGFuZFxuICAgICAgLy8gYWxzbyBhZGQgZG90cyB0byBpbmRpY2F0ZSBza2lwcGVkIGVudHJpZXMuXG4gICAgICBpZiAoY3VyID4gMSAmJiBpID4gMikge1xuICAgICAgICBpZiAoY3VyID4gNCkge1xuICAgICAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuICAgICAgICAgIHNraXBwZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGN1ciA+IDMpIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChleHBlY3RlZExpbmVzW2kgLSAyXSk7XG4gICAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICAgIH1cbiAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoZXhwZWN0ZWRMaW5lc1tpIC0gMV0pO1xuICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgIH1cbiAgICAgIC8vIE1hcmsgdGhlIGN1cnJlbnQgbGluZSBhcyB0aGUgbGFzdCBkaXZlcmdpbmcgb25lLlxuICAgICAgbGFzdFBvcyA9IGk7XG4gICAgICAvLyBBZGQgdGhlIGV4cGVjdGVkIGxpbmUgdG8gdGhlIGNhY2hlLlxuICAgICAgb3RoZXIgKz0gXCJcXG5cIi5jb25jYXQocmVkLCBcIi1cIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkTGluZXNbaV0pO1xuICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICAvLyBPbmx5IGV4dHJhIGFjdHVhbCBsaW5lcyBleGlzdFxuICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWRMaW5lcy5sZW5ndGggPCBpICsgMSkge1xuICAgICAgLy8gSWYgdGhlIGxhc3QgZGl2ZXJnaW5nIGxpbmUgaXMgbW9yZSB0aGFuIG9uZSBsaW5lIGFib3ZlIGFuZCB0aGVcbiAgICAgIC8vIGN1cnJlbnQgbGluZSBpcyBhdCBsZWFzdCBsaW5lIHRocmVlLCBhZGQgc29tZSBvZiB0aGUgZm9ybWVyIGxpbmVzIGFuZFxuICAgICAgLy8gYWxzbyBhZGQgZG90cyB0byBpbmRpY2F0ZSBza2lwcGVkIGVudHJpZXMuXG4gICAgICBpZiAoY3VyID4gMSAmJiBpID4gMikge1xuICAgICAgICBpZiAoY3VyID4gNCkge1xuICAgICAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuICAgICAgICAgIHNraXBwZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGN1ciA+IDMpIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMl0pO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9XG4gICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGFjdHVhbExpbmVzW2kgLSAxXSk7XG4gICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgfVxuICAgICAgLy8gTWFyayB0aGUgY3VycmVudCBsaW5lIGFzIHRoZSBsYXN0IGRpdmVyZ2luZyBvbmUuXG4gICAgICBsYXN0UG9zID0gaTtcbiAgICAgIC8vIEFkZCB0aGUgYWN0dWFsIGxpbmUgdG8gdGhlIHJlc3VsdC5cbiAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChncmVlbiwgXCIrXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChhY3R1YWxMaW5lc1tpXSk7XG4gICAgICBwcmludGVkTGluZXMrKztcbiAgICAgIC8vIExpbmVzIGRpdmVyZ2VcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGV4cGVjdGVkTGluZSA9IGV4cGVjdGVkTGluZXNbaV07XG4gICAgICB2YXIgYWN0dWFsTGluZSA9IGFjdHVhbExpbmVzW2ldO1xuICAgICAgLy8gSWYgdGhlIGxpbmVzIGRpdmVyZ2UsIHNwZWNpZmljYWxseSBjaGVjayBmb3IgbGluZXMgdGhhdCBvbmx5IGRpdmVyZ2UgYnlcbiAgICAgIC8vIGEgdHJhaWxpbmcgY29tbWEuIEluIHRoYXQgY2FzZSBpdCBpcyBhY3R1YWxseSBpZGVudGljYWwgYW5kIHdlIHNob3VsZFxuICAgICAgLy8gbWFyayBpdCBhcyBzdWNoLlxuICAgICAgdmFyIGRpdmVyZ2luZ0xpbmVzID0gYWN0dWFsTGluZSAhPT0gZXhwZWN0ZWRMaW5lICYmICghZW5kc1dpdGgoYWN0dWFsTGluZSwgJywnKSB8fCBhY3R1YWxMaW5lLnNsaWNlKDAsIC0xKSAhPT0gZXhwZWN0ZWRMaW5lKTtcbiAgICAgIC8vIElmIHRoZSBleHBlY3RlZCBsaW5lIGhhcyBhIHRyYWlsaW5nIGNvbW1hIGJ1dCBpcyBvdGhlcndpc2UgaWRlbnRpY2FsLFxuICAgICAgLy8gYWRkIGEgY29tbWEgYXQgdGhlIGVuZCBvZiB0aGUgYWN0dWFsIGxpbmUuIE90aGVyd2lzZSB0aGUgb3V0cHV0IGNvdWxkXG4gICAgICAvLyBsb29rIHdlaXJkIGFzIGluOlxuICAgICAgLy9cbiAgICAgIC8vICAgW1xuICAgICAgLy8gICAgIDEgICAgICAgICAvLyBObyBjb21tYSBhdCB0aGUgZW5kIVxuICAgICAgLy8gKyAgIDJcbiAgICAgIC8vICAgXVxuICAgICAgLy9cbiAgICAgIGlmIChkaXZlcmdpbmdMaW5lcyAmJiBlbmRzV2l0aChleHBlY3RlZExpbmUsICcsJykgJiYgZXhwZWN0ZWRMaW5lLnNsaWNlKDAsIC0xKSA9PT0gYWN0dWFsTGluZSkge1xuICAgICAgICBkaXZlcmdpbmdMaW5lcyA9IGZhbHNlO1xuICAgICAgICBhY3R1YWxMaW5lICs9ICcsJztcbiAgICAgIH1cbiAgICAgIGlmIChkaXZlcmdpbmdMaW5lcykge1xuICAgICAgICAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBtb3JlIHRoYW4gb25lIGxpbmUgYWJvdmUgYW5kIHRoZVxuICAgICAgICAvLyBjdXJyZW50IGxpbmUgaXMgYXQgbGVhc3QgbGluZSB0aHJlZSwgYWRkIHNvbWUgb2YgdGhlIGZvcm1lciBsaW5lcyBhbmRcbiAgICAgICAgLy8gYWxzbyBhZGQgZG90cyB0byBpbmRpY2F0ZSBza2lwcGVkIGVudHJpZXMuXG4gICAgICAgIGlmIChjdXIgPiAxICYmIGkgPiAyKSB7XG4gICAgICAgICAgaWYgKGN1ciA+IDQpIHtcbiAgICAgICAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuICAgICAgICAgICAgc2tpcHBlZCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjdXIgPiAzKSB7XG4gICAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMl0pO1xuICAgICAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGFjdHVhbExpbmVzW2kgLSAxXSk7XG4gICAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFyayB0aGUgY3VycmVudCBsaW5lIGFzIHRoZSBsYXN0IGRpdmVyZ2luZyBvbmUuXG4gICAgICAgIGxhc3RQb3MgPSBpO1xuICAgICAgICAvLyBBZGQgdGhlIGFjdHVhbCBsaW5lIHRvIHRoZSByZXN1bHQgYW5kIGNhY2hlIHRoZSBleHBlY3RlZCBkaXZlcmdpbmdcbiAgICAgICAgLy8gbGluZSBzbyBjb25zZWN1dGl2ZSBkaXZlcmdpbmcgbGluZXMgc2hvdyB1cCBhcyArKystLS0gYW5kIG5vdCArLSstKy0uXG4gICAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChncmVlbiwgXCIrXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChhY3R1YWxMaW5lKTtcbiAgICAgICAgb3RoZXIgKz0gXCJcXG5cIi5jb25jYXQocmVkLCBcIi1cIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkTGluZSk7XG4gICAgICAgIHByaW50ZWRMaW5lcyArPSAyO1xuICAgICAgICAvLyBMaW5lcyBhcmUgaWRlbnRpY2FsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBZGQgYWxsIGNhY2hlZCBpbmZvcm1hdGlvbiB0byB0aGUgcmVzdWx0IGJlZm9yZSBhZGRpbmcgb3RoZXIgdGhpbmdzXG4gICAgICAgIC8vIGFuZCByZXNldCB0aGUgY2FjaGUuXG4gICAgICAgIHJlcyArPSBvdGhlcjtcbiAgICAgICAgb3RoZXIgPSAnJztcbiAgICAgICAgLy8gSWYgdGhlIGxhc3QgZGl2ZXJnaW5nIGxpbmUgaXMgZXhhY3RseSBvbmUgbGluZSBhYm92ZSBvciBpZiBpdCBpcyB0aGVcbiAgICAgICAgLy8gdmVyeSBmaXJzdCBsaW5lLCBhZGQgdGhlIGxpbmUgdG8gdGhlIHJlc3VsdC5cbiAgICAgICAgaWYgKGN1ciA9PT0gMSB8fCBpID09PSAwKSB7XG4gICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZSk7XG4gICAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gSW5zcGVjdGVkIG9iamVjdCB0byBiaWcgKFNob3cgfjIwIHJvd3MgbWF4KVxuICAgIGlmIChwcmludGVkTGluZXMgPiAyMCAmJiBpIDwgbWF4TGluZXMgLSAyKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQobXNnKS5jb25jYXQoc2tpcHBlZE1zZywgXCJcXG5cIikuY29uY2F0KHJlcywgXCJcXG5cIikuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSkuY29uY2F0KG90aGVyLCBcIlxcblwiKSArIFwiXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBcIlwiLmNvbmNhdChtc2cpLmNvbmNhdChza2lwcGVkID8gc2tpcHBlZE1zZyA6ICcnLCBcIlxcblwiKS5jb25jYXQocmVzKS5jb25jYXQob3RoZXIpLmNvbmNhdChlbmQpLmNvbmNhdChpbmRpY2F0b3IpO1xufVxudmFyIEFzc2VydGlvbkVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IsIF9pbnNwZWN0JGN1c3RvbSkge1xuICBfaW5oZXJpdHMoQXNzZXJ0aW9uRXJyb3IsIF9FcnJvcik7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQXNzZXJ0aW9uRXJyb3IpO1xuICBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBc3NlcnRpb25FcnJvcik7XG4gICAgaWYgKF90eXBlb2Yob3B0aW9ucykgIT09ICdvYmplY3QnIHx8IG9wdGlvbnMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnb3B0aW9ucycsICdPYmplY3QnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgdmFyIG1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UsXG4gICAgICBvcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3IsXG4gICAgICBzdGFja1N0YXJ0Rm4gPSBvcHRpb25zLnN0YWNrU3RhcnRGbjtcbiAgICB2YXIgYWN0dWFsID0gb3B0aW9ucy5hY3R1YWwsXG4gICAgICBleHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gICAgdmFyIGxpbWl0ID0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0O1xuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IDA7XG4gICAgaWYgKG1lc3NhZ2UgIT0gbnVsbCkge1xuICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBTdHJpbmcobWVzc2FnZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5zdGRlcnIgJiYgcHJvY2Vzcy5zdGRlcnIuaXNUVFkpIHtcbiAgICAgICAgLy8gUmVzZXQgb24gZWFjaCBjYWxsIHRvIG1ha2Ugc3VyZSB3ZSBoYW5kbGUgZHluYW1pY2FsbHkgc2V0IGVudmlyb25tZW50XG4gICAgICAgIC8vIHZhcmlhYmxlcyBjb3JyZWN0LlxuICAgICAgICBpZiAocHJvY2Vzcy5zdGRlcnIgJiYgcHJvY2Vzcy5zdGRlcnIuZ2V0Q29sb3JEZXB0aCAmJiBwcm9jZXNzLnN0ZGVyci5nZXRDb2xvckRlcHRoKCkgIT09IDEpIHtcbiAgICAgICAgICBibHVlID0gXCJcXHgxQlszNG1cIjtcbiAgICAgICAgICBncmVlbiA9IFwiXFx4MUJbMzJtXCI7XG4gICAgICAgICAgd2hpdGUgPSBcIlxceDFCWzM5bVwiO1xuICAgICAgICAgIHJlZCA9IFwiXFx4MUJbMzFtXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmx1ZSA9ICcnO1xuICAgICAgICAgIGdyZWVuID0gJyc7XG4gICAgICAgICAgd2hpdGUgPSAnJztcbiAgICAgICAgICByZWQgPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gUHJldmVudCB0aGUgZXJyb3Igc3RhY2sgZnJvbSBiZWluZyB2aXNpYmxlIGJ5IGR1cGxpY2F0aW5nIHRoZSBlcnJvclxuICAgICAgLy8gaW4gYSB2ZXJ5IGNsb3NlIHdheSB0byB0aGUgb3JpZ2luYWwgaW4gY2FzZSBib3RoIHNpZGVzIGFyZSBhY3R1YWxseVxuICAgICAgLy8gaW5zdGFuY2VzIG9mIEVycm9yLlxuICAgICAgaWYgKF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgYWN0dWFsICE9PSBudWxsICYmIF90eXBlb2YoZXhwZWN0ZWQpID09PSAnb2JqZWN0JyAmJiBleHBlY3RlZCAhPT0gbnVsbCAmJiAnc3RhY2snIGluIGFjdHVhbCAmJiBhY3R1YWwgaW5zdGFuY2VvZiBFcnJvciAmJiAnc3RhY2snIGluIGV4cGVjdGVkICYmIGV4cGVjdGVkIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgYWN0dWFsID0gY29weUVycm9yKGFjdHVhbCk7XG4gICAgICAgIGV4cGVjdGVkID0gY29weUVycm9yKGV4cGVjdGVkKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcGVyYXRvciA9PT0gJ2RlZXBTdHJpY3RFcXVhbCcgfHwgb3BlcmF0b3IgPT09ICdzdHJpY3RFcXVhbCcpIHtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjcmVhdGVFcnJEaWZmKGFjdHVhbCwgZXhwZWN0ZWQsIG9wZXJhdG9yKSk7XG4gICAgICB9IGVsc2UgaWYgKG9wZXJhdG9yID09PSAnbm90RGVlcFN0cmljdEVxdWFsJyB8fCBvcGVyYXRvciA9PT0gJ25vdFN0cmljdEVxdWFsJykge1xuICAgICAgICAvLyBJbiBjYXNlIHRoZSBvYmplY3RzIGFyZSBlcXVhbCBidXQgdGhlIG9wZXJhdG9yIHJlcXVpcmVzIHVuZXF1YWwsIHNob3dcbiAgICAgICAgLy8gdGhlIGZpcnN0IG9iamVjdCBhbmQgc2F5IEEgZXF1YWxzIEJcbiAgICAgICAgdmFyIGJhc2UgPSBrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl07XG4gICAgICAgIHZhciByZXMgPSBpbnNwZWN0VmFsdWUoYWN0dWFsKS5zcGxpdCgnXFxuJyk7XG5cbiAgICAgICAgLy8gSW4gY2FzZSBcImFjdHVhbFwiIGlzIGFuIG9iamVjdCwgaXQgc2hvdWxkIG5vdCBiZSByZWZlcmVuY2UgZXF1YWwuXG4gICAgICAgIGlmIChvcGVyYXRvciA9PT0gJ25vdFN0cmljdEVxdWFsJyAmJiBfdHlwZW9mKGFjdHVhbCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCkge1xuICAgICAgICAgIGJhc2UgPSBrUmVhZGFibGVPcGVyYXRvci5ub3RTdHJpY3RFcXVhbE9iamVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9ubHkgcmVtb3ZlIGxpbmVzIGluIGNhc2UgaXQgbWFrZXMgc2Vuc2UgdG8gY29sbGFwc2UgdGhvc2UuXG4gICAgICAgIC8vIFRPRE86IEFjY2VwdCBlbnYgdG8gYWx3YXlzIHNob3cgdGhlIGZ1bGwgZXJyb3IuXG4gICAgICAgIGlmIChyZXMubGVuZ3RoID4gMzApIHtcbiAgICAgICAgICByZXNbMjZdID0gXCJcIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKTtcbiAgICAgICAgICB3aGlsZSAocmVzLmxlbmd0aCA+IDI3KSB7XG4gICAgICAgICAgICByZXMucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gT25seSBwcmludCBhIHNpbmdsZSBpbnB1dC5cbiAgICAgICAgaWYgKHJlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFwiXCIuY29uY2F0KGJhc2UsIFwiIFwiKS5jb25jYXQocmVzWzBdKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBcIlwiLmNvbmNhdChiYXNlLCBcIlxcblxcblwiKS5jb25jYXQocmVzLmpvaW4oJ1xcbicpLCBcIlxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfcmVzID0gaW5zcGVjdFZhbHVlKGFjdHVhbCk7XG4gICAgICAgIHZhciBvdGhlciA9ICcnO1xuICAgICAgICB2YXIga25vd25PcGVyYXRvcnMgPSBrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl07XG4gICAgICAgIGlmIChvcGVyYXRvciA9PT0gJ25vdERlZXBFcXVhbCcgfHwgb3BlcmF0b3IgPT09ICdub3RFcXVhbCcpIHtcbiAgICAgICAgICBfcmVzID0gXCJcIi5jb25jYXQoa1JlYWRhYmxlT3BlcmF0b3Jbb3BlcmF0b3JdLCBcIlxcblxcblwiKS5jb25jYXQoX3Jlcyk7XG4gICAgICAgICAgaWYgKF9yZXMubGVuZ3RoID4gMTAyNCkge1xuICAgICAgICAgICAgX3JlcyA9IFwiXCIuY29uY2F0KF9yZXMuc2xpY2UoMCwgMTAyMSksIFwiLi4uXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdGhlciA9IFwiXCIuY29uY2F0KGluc3BlY3RWYWx1ZShleHBlY3RlZCkpO1xuICAgICAgICAgIGlmIChfcmVzLmxlbmd0aCA+IDUxMikge1xuICAgICAgICAgICAgX3JlcyA9IFwiXCIuY29uY2F0KF9yZXMuc2xpY2UoMCwgNTA5KSwgXCIuLi5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvdGhlci5sZW5ndGggPiA1MTIpIHtcbiAgICAgICAgICAgIG90aGVyID0gXCJcIi5jb25jYXQob3RoZXIuc2xpY2UoMCwgNTA5KSwgXCIuLi5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcGVyYXRvciA9PT0gJ2RlZXBFcXVhbCcgfHwgb3BlcmF0b3IgPT09ICdlcXVhbCcpIHtcbiAgICAgICAgICAgIF9yZXMgPSBcIlwiLmNvbmNhdChrbm93bk9wZXJhdG9ycywgXCJcXG5cXG5cIikuY29uY2F0KF9yZXMsIFwiXFxuXFxuc2hvdWxkIGVxdWFsXFxuXFxuXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdGhlciA9IFwiIFwiLmNvbmNhdChvcGVyYXRvciwgXCIgXCIpLmNvbmNhdChvdGhlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgXCJcIi5jb25jYXQoX3JlcykuY29uY2F0KG90aGVyKSk7XG4gICAgICB9XG4gICAgfVxuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IGxpbWl0O1xuICAgIF90aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSAhbWVzc2FnZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksICduYW1lJywge1xuICAgICAgdmFsdWU6ICdBc3NlcnRpb25FcnJvciBbRVJSX0FTU0VSVElPTl0nLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIF90aGlzLmNvZGUgPSAnRVJSX0FTU0VSVElPTic7XG4gICAgX3RoaXMuYWN0dWFsID0gYWN0dWFsO1xuICAgIF90aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gICAgX3RoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIHN0YWNrU3RhcnRGbik7XG4gICAgfVxuICAgIC8vIENyZWF0ZSBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyB0aGUgZXJyb3IgY29kZSBpbiB0aGUgbmFtZS5cbiAgICBfdGhpcy5zdGFjaztcbiAgICAvLyBSZXNldCB0aGUgbmFtZS5cbiAgICBfdGhpcy5uYW1lID0gJ0Fzc2VydGlvbkVycm9yJztcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhBc3NlcnRpb25FcnJvciwgW3tcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5uYW1lLCBcIiBbXCIpLmNvbmNhdCh0aGlzLmNvZGUsIFwiXTogXCIpLmNvbmNhdCh0aGlzLm1lc3NhZ2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogX2luc3BlY3QkY3VzdG9tLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShyZWN1cnNlVGltZXMsIGN0eCkge1xuICAgICAgLy8gVGhpcyBsaW1pdHMgdGhlIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgIHByb3BlcnR5IGRlZmF1bHQgaW5zcGVjdGlvbiB0b1xuICAgICAgLy8gdGhlIG1pbmltdW0gZGVwdGguIE90aGVyd2lzZSB0aG9zZSB2YWx1ZXMgd291bGQgYmUgdG9vIHZlcmJvc2UgY29tcGFyZWRcbiAgICAgIC8vIHRvIHRoZSBhY3R1YWwgZXJyb3IgbWVzc2FnZSB3aGljaCBjb250YWlucyBhIGNvbWJpbmVkIHZpZXcgb2YgdGhlc2UgdHdvXG4gICAgICAvLyBpbnB1dCB2YWx1ZXMuXG4gICAgICByZXR1cm4gaW5zcGVjdCh0aGlzLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGN0eCksIHt9LCB7XG4gICAgICAgIGN1c3RvbUluc3BlY3Q6IGZhbHNlLFxuICAgICAgICBkZXB0aDogMFxuICAgICAgfSkpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQXNzZXJ0aW9uRXJyb3I7XG59KCAvKiNfX1BVUkVfXyovX3dyYXBOYXRpdmVTdXBlcihFcnJvciksIGluc3BlY3QuY3VzdG9tKTtcbm1vZHVsZS5leHBvcnRzID0gQXNzZXJ0aW9uRXJyb3I7IiwiLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC9lcnJvcnMuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvM2IwNDQ5NjJjNDhmZTMxMzkwNTg3N2E5NmI1ZDA4OTRhNTQwNGY2ZlxuXG4vKiBlc2xpbnQgbm9kZS1jb3JlL2RvY3VtZW50ZWQtZXJyb3JzOiBcImVycm9yXCIgKi9cbi8qIGVzbGludCBub2RlLWNvcmUvYWxwaGFiZXRpemUtZXJyb3JzOiBcImVycm9yXCIgKi9cbi8qIGVzbGludCBub2RlLWNvcmUvcHJlZmVyLXV0aWwtZm9ybWF0LWVycm9yczogXCJlcnJvclwiICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIHdob2xlIHBvaW50IGJlaGluZCB0aGlzIGludGVybmFsIG1vZHVsZSBpcyB0byBhbGxvdyBOb2RlLmpzIHRvIG5vXG4vLyBsb25nZXIgYmUgZm9yY2VkIHRvIHRyZWF0IGV2ZXJ5IGVycm9yIG1lc3NhZ2UgY2hhbmdlIGFzIGEgc2VtdmVyLW1ham9yXG4vLyBjaGFuZ2UuIFRoZSBOb2RlRXJyb3IgY2xhc3NlcyBoZXJlIGFsbCBleHBvc2UgYSBgY29kZWAgcHJvcGVydHkgd2hvc2Vcbi8vIHZhbHVlIHN0YXRpY2FsbHkgYW5kIHBlcm1hbmVudGx5IGlkZW50aWZpZXMgdGhlIGVycm9yLiBXaGlsZSB0aGUgZXJyb3Jcbi8vIG1lc3NhZ2UgbWF5IGNoYW5nZSwgdGhlIGNvZGUgc2hvdWxkIG5vdC5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTsgcmV0dXJuIF90eXBlb2Yoa2V5KSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHsgaWYgKF90eXBlb2YoaW5wdXQpICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7IHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkgeyB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTsgaWYgKF90eXBlb2YocmVzKSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlczsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cbnZhciBjb2RlcyA9IHt9O1xuXG4vLyBMYXp5IGxvYWRlZFxudmFyIGFzc2VydDtcbnZhciB1dGlsO1xuZnVuY3Rpb24gY3JlYXRlRXJyb3JUeXBlKGNvZGUsIG1lc3NhZ2UsIEJhc2UpIHtcbiAgaWYgKCFCYXNlKSB7XG4gICAgQmFzZSA9IEVycm9yO1xuICB9XG4gIGZ1bmN0aW9uIGdldE1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9XG4gIH1cbiAgdmFyIE5vZGVFcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2UpIHtcbiAgICBfaW5oZXJpdHMoTm9kZUVycm9yLCBfQmFzZSk7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihOb2RlRXJyb3IpO1xuICAgIGZ1bmN0aW9uIE5vZGVFcnJvcihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICB2YXIgX3RoaXM7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZUVycm9yKTtcbiAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSk7XG4gICAgICBfdGhpcy5jb2RlID0gY29kZTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhOb2RlRXJyb3IpO1xuICB9KEJhc2UpO1xuICBjb2Rlc1tjb2RlXSA9IE5vZGVFcnJvcjtcbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEwLjguMC9saWIvaW50ZXJuYWwvZXJyb3JzLmpzXG5mdW5jdGlvbiBvbmVPZihleHBlY3RlZCwgdGhpbmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0ZWQpKSB7XG4gICAgdmFyIGxlbiA9IGV4cGVjdGVkLmxlbmd0aDtcbiAgICBleHBlY3RlZCA9IGV4cGVjdGVkLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpKTtcbiAgICB9KTtcbiAgICBpZiAobGVuID4gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZC5zbGljZSgwLCBsZW4gLSAxKS5qb2luKCcsICcpLCBcIiwgb3IgXCIpICsgZXhwZWN0ZWRbbGVuIC0gMV07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0sIFwiIG9yIFwiKS5jb25jYXQoZXhwZWN0ZWRbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoU3RyaW5nKGV4cGVjdGVkKSk7XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3N0YXJ0c1dpdGhcbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyLCBzZWFyY2gsIHBvcykge1xuICByZXR1cm4gc3RyLnN1YnN0cighcG9zIHx8IHBvcyA8IDAgPyAwIDogK3Bvcywgc2VhcmNoLmxlbmd0aCkgPT09IHNlYXJjaDtcbn1cblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2VuZHNXaXRoXG5mdW5jdGlvbiBlbmRzV2l0aChzdHIsIHNlYXJjaCwgdGhpc19sZW4pIHtcbiAgaWYgKHRoaXNfbGVuID09PSB1bmRlZmluZWQgfHwgdGhpc19sZW4gPiBzdHIubGVuZ3RoKSB7XG4gICAgdGhpc19sZW4gPSBzdHIubGVuZ3RoO1xuICB9XG4gIHJldHVybiBzdHIuc3Vic3RyaW5nKHRoaXNfbGVuIC0gc2VhcmNoLmxlbmd0aCwgdGhpc19sZW4pID09PSBzZWFyY2g7XG59XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9pbmNsdWRlc1xuZnVuY3Rpb24gaW5jbHVkZXMoc3RyLCBzZWFyY2gsIHN0YXJ0KSB7XG4gIGlmICh0eXBlb2Ygc3RhcnQgIT09ICdudW1iZXInKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG4gIGlmIChzdGFydCArIHNlYXJjaC5sZW5ndGggPiBzdHIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHIuaW5kZXhPZihzZWFyY2gsIHN0YXJ0KSAhPT0gLTE7XG4gIH1cbn1cbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0FNQklHVU9VU19BUkdVTUVOVCcsICdUaGUgXCIlc1wiIGFyZ3VtZW50IGlzIGFtYmlndW91cy4gJXMnLCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9BUkdfVFlQRScsIGZ1bmN0aW9uIChuYW1lLCBleHBlY3RlZCwgYWN0dWFsKSB7XG4gIGlmIChhc3NlcnQgPT09IHVuZGVmaW5lZCkgYXNzZXJ0ID0gcmVxdWlyZSgnLi4vYXNzZXJ0Jyk7XG4gIGFzc2VydCh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycsIFwiJ25hbWUnIG11c3QgYmUgYSBzdHJpbmdcIik7XG5cbiAgLy8gZGV0ZXJtaW5lcjogJ211c3QgYmUnIG9yICdtdXN0IG5vdCBiZSdcbiAgdmFyIGRldGVybWluZXI7XG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnICYmIHN0YXJ0c1dpdGgoZXhwZWN0ZWQsICdub3QgJykpIHtcbiAgICBkZXRlcm1pbmVyID0gJ211c3Qgbm90IGJlJztcbiAgICBleHBlY3RlZCA9IGV4cGVjdGVkLnJlcGxhY2UoL15ub3QgLywgJycpO1xuICB9IGVsc2Uge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBiZSc7XG4gIH1cbiAgdmFyIG1zZztcbiAgaWYgKGVuZHNXaXRoKG5hbWUsICcgYXJndW1lbnQnKSkge1xuICAgIC8vIEZvciBjYXNlcyBsaWtlICdmaXJzdCBhcmd1bWVudCdcbiAgICBtc2cgPSBcIlRoZSBcIi5jb25jYXQobmFtZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdHlwZSA9IGluY2x1ZGVzKG5hbWUsICcuJykgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50JztcbiAgICBtc2cgPSBcIlRoZSBcXFwiXCIuY29uY2F0KG5hbWUsIFwiXFxcIiBcIikuY29uY2F0KHR5cGUsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSk7XG4gIH1cblxuICAvLyBUT0RPKEJyaWRnZUFSKTogSW1wcm92ZSB0aGUgb3V0cHV0IGJ5IHNob3dpbmcgYG51bGxgIGFuZCBzaW1pbGFyLlxuICBtc2cgKz0gXCIuIFJlY2VpdmVkIHR5cGUgXCIuY29uY2F0KF90eXBlb2YoYWN0dWFsKSk7XG4gIHJldHVybiBtc2c7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9BUkdfVkFMVUUnLCBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgdmFyIHJlYXNvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ2lzIGludmFsaWQnO1xuICBpZiAodXRpbCA9PT0gdW5kZWZpbmVkKSB1dGlsID0gcmVxdWlyZSgndXRpbC8nKTtcbiAgdmFyIGluc3BlY3RlZCA9IHV0aWwuaW5zcGVjdCh2YWx1ZSk7XG4gIGlmIChpbnNwZWN0ZWQubGVuZ3RoID4gMTI4KSB7XG4gICAgaW5zcGVjdGVkID0gXCJcIi5jb25jYXQoaW5zcGVjdGVkLnNsaWNlKDAsIDEyOCksIFwiLi4uXCIpO1xuICB9XG4gIHJldHVybiBcIlRoZSBhcmd1bWVudCAnXCIuY29uY2F0KG5hbWUsIFwiJyBcIikuY29uY2F0KHJlYXNvbiwgXCIuIFJlY2VpdmVkIFwiKS5jb25jYXQoaW5zcGVjdGVkKTtcbn0sIFR5cGVFcnJvciwgUmFuZ2VFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX1JFVFVSTl9WQUxVRScsIGZ1bmN0aW9uIChpbnB1dCwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIHR5cGU7XG4gIGlmICh2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgdHlwZSA9IFwiaW5zdGFuY2Ugb2YgXCIuY29uY2F0KHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpO1xuICB9IGVsc2Uge1xuICAgIHR5cGUgPSBcInR5cGUgXCIuY29uY2F0KF90eXBlb2YodmFsdWUpKTtcbiAgfVxuICByZXR1cm4gXCJFeHBlY3RlZCBcIi5jb25jYXQoaW5wdXQsIFwiIHRvIGJlIHJldHVybmVkIGZyb20gdGhlIFxcXCJcIikuY29uY2F0KG5hbWUsIFwiXFxcIlwiKSArIFwiIGZ1bmN0aW9uIGJ1dCBnb3QgXCIuY29uY2F0KHR5cGUsIFwiLlwiKTtcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9NSVNTSU5HX0FSR1MnLCBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgaWYgKGFzc2VydCA9PT0gdW5kZWZpbmVkKSBhc3NlcnQgPSByZXF1aXJlKCcuLi9hc3NlcnQnKTtcbiAgYXNzZXJ0KGFyZ3MubGVuZ3RoID4gMCwgJ0F0IGxlYXN0IG9uZSBhcmcgbmVlZHMgdG8gYmUgc3BlY2lmaWVkJyk7XG4gIHZhciBtc2cgPSAnVGhlICc7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgYXJncyA9IGFyZ3MubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIFwiXFxcIlwiLmNvbmNhdChhLCBcIlxcXCJcIik7XG4gIH0pO1xuICBzd2l0Y2ggKGxlbikge1xuICAgIGNhc2UgMTpcbiAgICAgIG1zZyArPSBcIlwiLmNvbmNhdChhcmdzWzBdLCBcIiBhcmd1bWVudFwiKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIG1zZyArPSBcIlwiLmNvbmNhdChhcmdzWzBdLCBcIiBhbmQgXCIpLmNvbmNhdChhcmdzWzFdLCBcIiBhcmd1bWVudHNcIik7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbXNnICs9IGFyZ3Muc2xpY2UoMCwgbGVuIC0gMSkuam9pbignLCAnKTtcbiAgICAgIG1zZyArPSBcIiwgYW5kIFwiLmNvbmNhdChhcmdzW2xlbiAtIDFdLCBcIiBhcmd1bWVudHNcIik7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gXCJcIi5jb25jYXQobXNnLCBcIiBtdXN0IGJlIHNwZWNpZmllZFwiKTtcbn0sIFR5cGVFcnJvcik7XG5tb2R1bGUuZXhwb3J0cy5jb2RlcyA9IGNvZGVzOyIsIi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvaW50ZXJuYWwvdXRpbC9jb21wYXJpc29ucy5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8xMTJjYzdjMjc1NTEyNTRhYTJiMTcwOThmYjc3NDg2N2YwNWVkMGQ5XG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7IHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmIChudWxsICE9IHQpIHsgdmFyIGUsIG4sIGksIHUsIGEgPSBbXSwgZiA9ICEwLCBvID0gITE7IHRyeSB7IGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHsgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuOyBmID0gITE7IH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTsgfSBjYXRjaCAocikgeyBvID0gITAsIG4gPSByOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIWYgJiYgbnVsbCAhPSB0LnJldHVybiAmJiAodSA9IHQucmV0dXJuKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjsgfSBmaW5hbGx5IHsgaWYgKG8pIHRocm93IG47IH0gfSByZXR1cm4gYTsgfSB9XG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbnZhciByZWdleEZsYWdzU3VwcG9ydGVkID0gL2EvZy5mbGFncyAhPT0gdW5kZWZpbmVkO1xudmFyIGFycmF5RnJvbVNldCA9IGZ1bmN0aW9uIGFycmF5RnJvbVNldChzZXQpIHtcbiAgdmFyIGFycmF5ID0gW107XG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBhcnJheS5wdXNoKHZhbHVlKTtcbiAgfSk7XG4gIHJldHVybiBhcnJheTtcbn07XG52YXIgYXJyYXlGcm9tTWFwID0gZnVuY3Rpb24gYXJyYXlGcm9tTWFwKG1hcCkge1xuICB2YXIgYXJyYXkgPSBbXTtcbiAgbWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICByZXR1cm4gYXJyYXkucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9KTtcbiAgcmV0dXJuIGFycmF5O1xufTtcbnZhciBvYmplY3RJcyA9IE9iamVjdC5pcyA/IE9iamVjdC5pcyA6IHJlcXVpcmUoJ29iamVjdC1pcycpO1xudmFyIG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gW107XG59O1xudmFyIG51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOID8gTnVtYmVyLmlzTmFOIDogcmVxdWlyZSgnaXMtbmFuJyk7XG5mdW5jdGlvbiB1bmN1cnJ5VGhpcyhmKSB7XG4gIHJldHVybiBmLmNhbGwuYmluZChmKTtcbn1cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSk7XG52YXIgb2JqZWN0VG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTtcbnZhciBfcmVxdWlyZSR0eXBlcyA9IHJlcXVpcmUoJ3V0aWwvJykudHlwZXMsXG4gIGlzQW55QXJyYXlCdWZmZXIgPSBfcmVxdWlyZSR0eXBlcy5pc0FueUFycmF5QnVmZmVyLFxuICBpc0FycmF5QnVmZmVyVmlldyA9IF9yZXF1aXJlJHR5cGVzLmlzQXJyYXlCdWZmZXJWaWV3LFxuICBpc0RhdGUgPSBfcmVxdWlyZSR0eXBlcy5pc0RhdGUsXG4gIGlzTWFwID0gX3JlcXVpcmUkdHlwZXMuaXNNYXAsXG4gIGlzUmVnRXhwID0gX3JlcXVpcmUkdHlwZXMuaXNSZWdFeHAsXG4gIGlzU2V0ID0gX3JlcXVpcmUkdHlwZXMuaXNTZXQsXG4gIGlzTmF0aXZlRXJyb3IgPSBfcmVxdWlyZSR0eXBlcy5pc05hdGl2ZUVycm9yLFxuICBpc0JveGVkUHJpbWl0aXZlID0gX3JlcXVpcmUkdHlwZXMuaXNCb3hlZFByaW1pdGl2ZSxcbiAgaXNOdW1iZXJPYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc051bWJlck9iamVjdCxcbiAgaXNTdHJpbmdPYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc1N0cmluZ09iamVjdCxcbiAgaXNCb29sZWFuT2JqZWN0ID0gX3JlcXVpcmUkdHlwZXMuaXNCb29sZWFuT2JqZWN0LFxuICBpc0JpZ0ludE9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzQmlnSW50T2JqZWN0LFxuICBpc1N5bWJvbE9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzU3ltYm9sT2JqZWN0LFxuICBpc0Zsb2F0MzJBcnJheSA9IF9yZXF1aXJlJHR5cGVzLmlzRmxvYXQzMkFycmF5LFxuICBpc0Zsb2F0NjRBcnJheSA9IF9yZXF1aXJlJHR5cGVzLmlzRmxvYXQ2NEFycmF5O1xuZnVuY3Rpb24gaXNOb25JbmRleChrZXkpIHtcbiAgaWYgKGtleS5sZW5ndGggPT09IDAgfHwga2V5Lmxlbmd0aCA+IDEwKSByZXR1cm4gdHJ1ZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29kZSA9IGtleS5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlIDwgNDggfHwgY29kZSA+IDU3KSByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBUaGUgbWF4aW11bSBzaXplIGZvciBhbiBhcnJheSBpcyAyICoqIDMyIC0xLlxuICByZXR1cm4ga2V5Lmxlbmd0aCA9PT0gMTAgJiYga2V5ID49IE1hdGgucG93KDIsIDMyKTtcbn1cbmZ1bmN0aW9uIGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLmZpbHRlcihpc05vbkluZGV4KS5jb25jYXQob2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzKHZhbHVlKS5maWx0ZXIoT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5iaW5kKHZhbHVlKSkpO1xufVxuXG4vLyBUYWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2Jsb2IvNjgwZTllNWU0ODhmMjJhYWMyNzU5OWE1N2RjODQ0YTYzMTU5MjhkZC9pbmRleC5qc1xuLy8gb3JpZ2luYWwgbm90aWNlOlxuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIHggPSBhLmxlbmd0aDtcbiAgdmFyIHkgPSBiLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV07XG4gICAgICB5ID0gYltpXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoeCA8IHkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKHkgPCB4KSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG52YXIgT05MWV9FTlVNRVJBQkxFID0gdW5kZWZpbmVkO1xudmFyIGtTdHJpY3QgPSB0cnVlO1xudmFyIGtMb29zZSA9IGZhbHNlO1xudmFyIGtOb0l0ZXJhdG9yID0gMDtcbnZhciBrSXNBcnJheSA9IDE7XG52YXIga0lzU2V0ID0gMjtcbnZhciBrSXNNYXAgPSAzO1xuXG4vLyBDaGVjayBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgc291cmNlIGFuZCBmbGFnc1xuZnVuY3Rpb24gYXJlU2ltaWxhclJlZ0V4cHMoYSwgYikge1xuICByZXR1cm4gcmVnZXhGbGFnc1N1cHBvcnRlZCA/IGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzIDogUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpID09PSBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYik7XG59XG5mdW5jdGlvbiBhcmVTaW1pbGFyRmxvYXRBcnJheXMoYSwgYikge1xuICBpZiAoYS5ieXRlTGVuZ3RoICE9PSBiLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgYS5ieXRlTGVuZ3RoOyBvZmZzZXQrKykge1xuICAgIGlmIChhW29mZnNldF0gIT09IGJbb2Zmc2V0XSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGFyZVNpbWlsYXJUeXBlZEFycmF5cyhhLCBiKSB7XG4gIGlmIChhLmJ5dGVMZW5ndGggIT09IGIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gY29tcGFyZShuZXcgVWludDhBcnJheShhLmJ1ZmZlciwgYS5ieXRlT2Zmc2V0LCBhLmJ5dGVMZW5ndGgpLCBuZXcgVWludDhBcnJheShiLmJ1ZmZlciwgYi5ieXRlT2Zmc2V0LCBiLmJ5dGVMZW5ndGgpKSA9PT0gMDtcbn1cbmZ1bmN0aW9uIGFyZUVxdWFsQXJyYXlCdWZmZXJzKGJ1ZjEsIGJ1ZjIpIHtcbiAgcmV0dXJuIGJ1ZjEuYnl0ZUxlbmd0aCA9PT0gYnVmMi5ieXRlTGVuZ3RoICYmIGNvbXBhcmUobmV3IFVpbnQ4QXJyYXkoYnVmMSksIG5ldyBVaW50OEFycmF5KGJ1ZjIpKSA9PT0gMDtcbn1cbmZ1bmN0aW9uIGlzRXF1YWxCb3hlZFByaW1pdGl2ZSh2YWwxLCB2YWwyKSB7XG4gIGlmIChpc051bWJlck9iamVjdCh2YWwxKSkge1xuICAgIHJldHVybiBpc051bWJlck9iamVjdCh2YWwyKSAmJiBvYmplY3RJcyhOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSwgTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMikpO1xuICB9XG4gIGlmIChpc1N0cmluZ09iamVjdCh2YWwxKSkge1xuICAgIHJldHVybiBpc1N0cmluZ09iamVjdCh2YWwyKSAmJiBTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSA9PT0gU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMik7XG4gIH1cbiAgaWYgKGlzQm9vbGVhbk9iamVjdCh2YWwxKSkge1xuICAgIHJldHVybiBpc0Jvb2xlYW5PYmplY3QodmFsMikgJiYgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PSBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMik7XG4gIH1cbiAgaWYgKGlzQmlnSW50T2JqZWN0KHZhbDEpKSB7XG4gICAgcmV0dXJuIGlzQmlnSW50T2JqZWN0KHZhbDIpICYmIEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PSBCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKTtcbiAgfVxuICByZXR1cm4gaXNTeW1ib2xPYmplY3QodmFsMikgJiYgU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMSkgPT09IFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpO1xufVxuXG4vLyBOb3RlczogVHlwZSB0YWdzIGFyZSBoaXN0b3JpY2FsIFtbQ2xhc3NdXSBwcm9wZXJ0aWVzIHRoYXQgY2FuIGJlIHNldCBieVxuLy8gRnVuY3Rpb25UZW1wbGF0ZTo6U2V0Q2xhc3NOYW1lKCkgaW4gQysrIG9yIFN5bWJvbC50b1N0cmluZ1RhZyBpbiBKU1xuLy8gYW5kIHJldHJpZXZlZCB1c2luZyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSBpbiBKU1xuLy8gU2VlIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmdcbi8vIGZvciBhIGxpc3Qgb2YgdGFncyBwcmUtZGVmaW5lZCBpbiB0aGUgc3BlYy5cbi8vIFRoZXJlIGFyZSBzb21lIHVuc3BlY2lmaWVkIHRhZ3MgaW4gdGhlIHdpbGQgdG9vIChlLmcuIHR5cGVkIGFycmF5IHRhZ3MpLlxuLy8gU2luY2UgdGFncyBjYW4gYmUgYWx0ZXJlZCwgdGhleSBvbmx5IHNlcnZlIGZhc3QgZmFpbHVyZXNcbi8vXG4vLyBUeXBlZCBhcnJheXMgYW5kIGJ1ZmZlcnMgYXJlIGNoZWNrZWQgYnkgY29tcGFyaW5nIHRoZSBjb250ZW50IGluIHRoZWlyXG4vLyB1bmRlcmx5aW5nIEFycmF5QnVmZmVyLiBUaGlzIG9wdGltaXphdGlvbiByZXF1aXJlcyB0aGF0IGl0J3Ncbi8vIHJlYXNvbmFibGUgdG8gaW50ZXJwcmV0IHRoZWlyIHVuZGVybHlpbmcgbWVtb3J5IGluIHRoZSBzYW1lIHdheSxcbi8vIHdoaWNoIGlzIGNoZWNrZWQgYnkgY29tcGFyaW5nIHRoZWlyIHR5cGUgdGFncy5cbi8vIChlLmcuIGEgVWludDhBcnJheSBhbmQgYSBVaW50MTZBcnJheSB3aXRoIHRoZSBzYW1lIG1lbW9yeSBjb250ZW50XG4vLyBjb3VsZCBzdGlsbCBiZSBkaWZmZXJlbnQgYmVjYXVzZSB0aGV5IHdpbGwgYmUgaW50ZXJwcmV0ZWQgZGlmZmVyZW50bHkpLlxuLy9cbi8vIEZvciBzdHJpY3QgY29tcGFyaXNvbiwgb2JqZWN0cyBzaG91bGQgaGF2ZVxuLy8gYSkgVGhlIHNhbWUgYnVpbHQtaW4gdHlwZSB0YWdzXG4vLyBiKSBUaGUgc2FtZSBwcm90b3R5cGVzLlxuXG5mdW5jdGlvbiBpbm5lckRlZXBFcXVhbCh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zKSB7XG4gIC8vIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKHZhbDEgPT09IHZhbDIpIHtcbiAgICBpZiAodmFsMSAhPT0gMCkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHN0cmljdCA/IG9iamVjdElzKHZhbDEsIHZhbDIpIDogdHJ1ZTtcbiAgfVxuXG4gIC8vIENoZWNrIG1vcmUgY2xvc2VseSBpZiB2YWwxIGFuZCB2YWwyIGFyZSBlcXVhbC5cbiAgaWYgKHN0cmljdCkge1xuICAgIGlmIChfdHlwZW9mKHZhbDEpICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWwxID09PSAnbnVtYmVyJyAmJiBudW1iZXJJc05hTih2YWwxKSAmJiBudW1iZXJJc05hTih2YWwyKTtcbiAgICB9XG4gICAgaWYgKF90eXBlb2YodmFsMikgIT09ICdvYmplY3QnIHx8IHZhbDEgPT09IG51bGwgfHwgdmFsMiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbDEpICE9PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbDEgPT09IG51bGwgfHwgX3R5cGVvZih2YWwxKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICh2YWwyID09PSBudWxsIHx8IF90eXBlb2YodmFsMikgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcbiAgICAgICAgcmV0dXJuIHZhbDEgPT0gdmFsMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHZhbDIgPT09IG51bGwgfHwgX3R5cGVvZih2YWwyKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgdmFyIHZhbDFUYWcgPSBvYmplY3RUb1N0cmluZyh2YWwxKTtcbiAgdmFyIHZhbDJUYWcgPSBvYmplY3RUb1N0cmluZyh2YWwyKTtcbiAgaWYgKHZhbDFUYWcgIT09IHZhbDJUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsMSkpIHtcbiAgICAvLyBDaGVjayBmb3Igc3BhcnNlIGFycmF5cyBhbmQgZ2VuZXJhbCBmYXN0IHBhdGhcbiAgICBpZiAodmFsMS5sZW5ndGggIT09IHZhbDIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBrZXlzMSA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwxLCBPTkxZX0VOVU1FUkFCTEUpO1xuICAgIHZhciBrZXlzMiA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwyLCBPTkxZX0VOVU1FUkFCTEUpO1xuICAgIGlmIChrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywga0lzQXJyYXksIGtleXMxKTtcbiAgfVxuICAvLyBbYnJvd3NlcmlmeV0gVGhpcyB0cmlnZ2VycyBvbiBjZXJ0YWluIHR5cGVzIGluIElFIChNYXAvU2V0KSBzbyB3ZSBkb24ndFxuICAvLyB3YW4ndCB0byBlYXJseSByZXR1cm4gb3V0IG9mIHRoZSByZXN0IG9mIHRoZSBjaGVja3MuIEhvd2V2ZXIgd2UgY2FuIGNoZWNrXG4gIC8vIGlmIHRoZSBzZWNvbmQgdmFsdWUgaXMgb25lIG9mIHRoZXNlIHZhbHVlcyBhbmQgdGhlIGZpcnN0IGlzbid0LlxuICBpZiAodmFsMVRhZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAvLyByZXR1cm4ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywga05vSXRlcmF0b3IpO1xuICAgIGlmICghaXNNYXAodmFsMSkgJiYgaXNNYXAodmFsMikgfHwgIWlzU2V0KHZhbDEpICYmIGlzU2V0KHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChpc0RhdGUodmFsMSkpIHtcbiAgICBpZiAoIWlzRGF0ZSh2YWwyKSB8fCBEYXRlLnByb3RvdHlwZS5nZXRUaW1lLmNhbGwodmFsMSkgIT09IERhdGUucHJvdG90eXBlLmdldFRpbWUuY2FsbCh2YWwyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1JlZ0V4cCh2YWwxKSkge1xuICAgIGlmICghaXNSZWdFeHAodmFsMikgfHwgIWFyZVNpbWlsYXJSZWdFeHBzKHZhbDEsIHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzTmF0aXZlRXJyb3IodmFsMSkgfHwgdmFsMSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgLy8gRG8gbm90IGNvbXBhcmUgdGhlIHN0YWNrIGFzIGl0IG1pZ2h0IGRpZmZlciBldmVuIHRob3VnaCB0aGUgZXJyb3IgaXRzZWxmXG4gICAgLy8gaXMgb3RoZXJ3aXNlIGlkZW50aWNhbC5cbiAgICBpZiAodmFsMS5tZXNzYWdlICE9PSB2YWwyLm1lc3NhZ2UgfHwgdmFsMS5uYW1lICE9PSB2YWwyLm5hbWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlclZpZXcodmFsMSkpIHtcbiAgICBpZiAoIXN0cmljdCAmJiAoaXNGbG9hdDMyQXJyYXkodmFsMSkgfHwgaXNGbG9hdDY0QXJyYXkodmFsMSkpKSB7XG4gICAgICBpZiAoIWFyZVNpbWlsYXJGbG9hdEFycmF5cyh2YWwxLCB2YWwyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYXJlU2ltaWxhclR5cGVkQXJyYXlzKHZhbDEsIHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEJ1ZmZlci5jb21wYXJlIHJldHVybnMgdHJ1ZSwgc28gdmFsMS5sZW5ndGggPT09IHZhbDIubGVuZ3RoLiBJZiB0aGV5IGJvdGhcbiAgICAvLyBvbmx5IGNvbnRhaW4gbnVtZXJpYyBrZXlzLCB3ZSBkb24ndCBuZWVkIHRvIGV4YW0gZnVydGhlciB0aGFuIGNoZWNraW5nXG4gICAgLy8gdGhlIHN5bWJvbHMuXG4gICAgdmFyIF9rZXlzID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbDEsIE9OTFlfRU5VTUVSQUJMRSk7XG4gICAgdmFyIF9rZXlzMiA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwyLCBPTkxZX0VOVU1FUkFCTEUpO1xuICAgIGlmIChfa2V5cy5sZW5ndGggIT09IF9rZXlzMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtOb0l0ZXJhdG9yLCBfa2V5cyk7XG4gIH0gZWxzZSBpZiAoaXNTZXQodmFsMSkpIHtcbiAgICBpZiAoIWlzU2V0KHZhbDIpIHx8IHZhbDEuc2l6ZSAhPT0gdmFsMi5zaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrSXNTZXQpO1xuICB9IGVsc2UgaWYgKGlzTWFwKHZhbDEpKSB7XG4gICAgaWYgKCFpc01hcCh2YWwyKSB8fCB2YWwxLnNpemUgIT09IHZhbDIuc2l6ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywga0lzTWFwKTtcbiAgfSBlbHNlIGlmIChpc0FueUFycmF5QnVmZmVyKHZhbDEpKSB7XG4gICAgaWYgKCFhcmVFcXVhbEFycmF5QnVmZmVycyh2YWwxLCB2YWwyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0JveGVkUHJpbWl0aXZlKHZhbDEpICYmICFpc0VxdWFsQm94ZWRQcmltaXRpdmUodmFsMSwgdmFsMikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtOb0l0ZXJhdG9yKTtcbn1cbmZ1bmN0aW9uIGdldEVudW1lcmFibGVzKHZhbCwga2V5cykge1xuICByZXR1cm4ga2V5cy5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUodmFsLCBrKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBpdGVyYXRpb25UeXBlLCBhS2V5cykge1xuICAvLyBGb3IgYWxsIHJlbWFpbmluZyBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSwgb2JqZWN0cyBhbmQgTWFwcyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSBoYXZpbmc6XG4gIC8vIGEpIFRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBlbnVtZXJhYmxlIHByb3BlcnRpZXNcbiAgLy8gYikgVGhlIHNhbWUgc2V0IG9mIGtleXMvaW5kZXhlcyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKVxuICAvLyBjKSBFcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXkvaW5kZXhcbiAgLy8gZCkgRm9yIFNldHMgYW5kIE1hcHMsIGVxdWFsIGNvbnRlbnRzXG4gIC8vIE5vdGU6IHRoaXMgYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA1KSB7XG4gICAgYUtleXMgPSBPYmplY3Qua2V5cyh2YWwxKTtcbiAgICB2YXIgYktleXMgPSBPYmplY3Qua2V5cyh2YWwyKTtcblxuICAgIC8vIFRoZSBwYWlyIG11c3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcy5cbiAgICBpZiAoYUtleXMubGVuZ3RoICE9PSBiS2V5cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBDaGVhcCBrZXkgdGVzdFxuICB2YXIgaSA9IDA7XG4gIGZvciAoOyBpIDwgYUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5KHZhbDIsIGFLZXlzW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoc3RyaWN0ICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDUpIHtcbiAgICB2YXIgc3ltYm9sS2V5c0EgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsMSk7XG4gICAgaWYgKHN5bWJvbEtleXNBLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzeW1ib2xLZXlzQS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0gc3ltYm9sS2V5c0FbaV07XG4gICAgICAgIGlmIChwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwxLCBrZXkpKSB7XG4gICAgICAgICAgaWYgKCFwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwyLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICBjb3VudCsrO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnR5SXNFbnVtZXJhYmxlKHZhbDIsIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBzeW1ib2xLZXlzQiA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWwyKTtcbiAgICAgIGlmIChzeW1ib2xLZXlzQS5sZW5ndGggIT09IHN5bWJvbEtleXNCLmxlbmd0aCAmJiBnZXRFbnVtZXJhYmxlcyh2YWwyLCBzeW1ib2xLZXlzQikubGVuZ3RoICE9PSBjb3VudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfc3ltYm9sS2V5c0IgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsMik7XG4gICAgICBpZiAoX3N5bWJvbEtleXNCLmxlbmd0aCAhPT0gMCAmJiBnZXRFbnVtZXJhYmxlcyh2YWwyLCBfc3ltYm9sS2V5c0IpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChhS2V5cy5sZW5ndGggPT09IDAgJiYgKGl0ZXJhdGlvblR5cGUgPT09IGtOb0l0ZXJhdG9yIHx8IGl0ZXJhdGlvblR5cGUgPT09IGtJc0FycmF5ICYmIHZhbDEubGVuZ3RoID09PSAwIHx8IHZhbDEuc2l6ZSA9PT0gMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFVzZSBtZW1vcyB0byBoYW5kbGUgY3ljbGVzLlxuICBpZiAobWVtb3MgPT09IHVuZGVmaW5lZCkge1xuICAgIG1lbW9zID0ge1xuICAgICAgdmFsMTogbmV3IE1hcCgpLFxuICAgICAgdmFsMjogbmV3IE1hcCgpLFxuICAgICAgcG9zaXRpb246IDBcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIHByZXZlbnQgdXAgdG8gdHdvIG1hcC5oYXMoeCkgY2FsbHMgYnkgZGlyZWN0bHkgcmV0cmlldmluZyB0aGUgdmFsdWVcbiAgICAvLyBhbmQgY2hlY2tpbmcgZm9yIHVuZGVmaW5lZC4gVGhlIG1hcCBjYW4gb25seSBjb250YWluIG51bWJlcnMsIHNvIGl0IGlzXG4gICAgLy8gc2FmZSB0byBjaGVjayBmb3IgdW5kZWZpbmVkIG9ubHkuXG4gICAgdmFyIHZhbDJNZW1vQSA9IG1lbW9zLnZhbDEuZ2V0KHZhbDEpO1xuICAgIGlmICh2YWwyTWVtb0EgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHZhbDJNZW1vQiA9IG1lbW9zLnZhbDIuZ2V0KHZhbDIpO1xuICAgICAgaWYgKHZhbDJNZW1vQiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWwyTWVtb0EgPT09IHZhbDJNZW1vQjtcbiAgICAgIH1cbiAgICB9XG4gICAgbWVtb3MucG9zaXRpb24rKztcbiAgfVxuICBtZW1vcy52YWwxLnNldCh2YWwxLCBtZW1vcy5wb3NpdGlvbik7XG4gIG1lbW9zLnZhbDIuc2V0KHZhbDIsIG1lbW9zLnBvc2l0aW9uKTtcbiAgdmFyIGFyZUVxID0gb2JqRXF1aXYodmFsMSwgdmFsMiwgc3RyaWN0LCBhS2V5cywgbWVtb3MsIGl0ZXJhdGlvblR5cGUpO1xuICBtZW1vcy52YWwxLmRlbGV0ZSh2YWwxKTtcbiAgbWVtb3MudmFsMi5kZWxldGUodmFsMik7XG4gIHJldHVybiBhcmVFcTtcbn1cbmZ1bmN0aW9uIHNldEhhc0VxdWFsRWxlbWVudChzZXQsIHZhbDEsIHN0cmljdCwgbWVtbykge1xuICAvLyBHbyBsb29raW5nLlxuICB2YXIgc2V0VmFsdWVzID0gYXJyYXlGcm9tU2V0KHNldCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0VmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHZhbDIgPSBzZXRWYWx1ZXNbaV07XG4gICAgaWYgKGlubmVyRGVlcEVxdWFsKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtbykpIHtcbiAgICAgIC8vIFJlbW92ZSB0aGUgbWF0Y2hpbmcgZWxlbWVudCB0byBtYWtlIHN1cmUgd2UgZG8gbm90IGNoZWNrIHRoYXQgYWdhaW4uXG4gICAgICBzZXQuZGVsZXRlKHZhbDIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvRXF1YWxpdHlfY29tcGFyaXNvbnNfYW5kX3NhbWVuZXNzI0xvb3NlX2VxdWFsaXR5X3VzaW5nXG4vLyBTYWRseSBpdCBpcyBub3QgcG9zc2libGUgdG8gZGV0ZWN0IGNvcnJlc3BvbmRpbmcgdmFsdWVzIHByb3Blcmx5IGluIGNhc2UgdGhlXG4vLyB0eXBlIGlzIGEgc3RyaW5nLCBudW1iZXIsIGJpZ2ludCBvciBib29sZWFuLiBUaGUgcmVhc29uIGlzIHRoYXQgdGhvc2UgdmFsdWVzXG4vLyBjYW4gbWF0Y2ggbG90cyBvZiBkaWZmZXJlbnQgc3RyaW5nIHZhbHVlcyAoZS5nLiwgMW4gPT0gJyswMDAwMScpLlxuZnVuY3Rpb24gZmluZExvb3NlTWF0Y2hpbmdQcmltaXRpdmVzKHByaW0pIHtcbiAgc3dpdGNoIChfdHlwZW9mKHByaW0pKSB7XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAvLyBPbmx5IHBhc3MgaW4gbnVsbCBhcyBvYmplY3QhXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHByaW0gPSArcHJpbTtcbiAgICAvLyBMb29zZSBlcXVhbCBlbnRyaWVzIGV4aXN0IG9ubHkgaWYgdGhlIHN0cmluZyBpcyBwb3NzaWJsZSB0byBjb252ZXJ0IHRvXG4gICAgLy8gYSByZWd1bGFyIG51bWJlciBhbmQgbm90IE5hTi5cbiAgICAvLyBGYWxsIHRocm91Z2hcbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgaWYgKG51bWJlcklzTmFOKHByaW0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNldE1pZ2h0SGF2ZUxvb3NlUHJpbShhLCBiLCBwcmltKSB7XG4gIHZhciBhbHRWYWx1ZSA9IGZpbmRMb29zZU1hdGNoaW5nUHJpbWl0aXZlcyhwcmltKTtcbiAgaWYgKGFsdFZhbHVlICE9IG51bGwpIHJldHVybiBhbHRWYWx1ZTtcbiAgcmV0dXJuIGIuaGFzKGFsdFZhbHVlKSAmJiAhYS5oYXMoYWx0VmFsdWUpO1xufVxuZnVuY3Rpb24gbWFwTWlnaHRIYXZlTG9vc2VQcmltKGEsIGIsIHByaW0sIGl0ZW0sIG1lbW8pIHtcbiAgdmFyIGFsdFZhbHVlID0gZmluZExvb3NlTWF0Y2hpbmdQcmltaXRpdmVzKHByaW0pO1xuICBpZiAoYWx0VmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBhbHRWYWx1ZTtcbiAgfVxuICB2YXIgY3VyQiA9IGIuZ2V0KGFsdFZhbHVlKTtcbiAgaWYgKGN1ckIgPT09IHVuZGVmaW5lZCAmJiAhYi5oYXMoYWx0VmFsdWUpIHx8ICFpbm5lckRlZXBFcXVhbChpdGVtLCBjdXJCLCBmYWxzZSwgbWVtbykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuICFhLmhhcyhhbHRWYWx1ZSkgJiYgaW5uZXJEZWVwRXF1YWwoaXRlbSwgY3VyQiwgZmFsc2UsIG1lbW8pO1xufVxuZnVuY3Rpb24gc2V0RXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vKSB7XG4gIC8vIFRoaXMgaXMgYSBsYXppbHkgaW5pdGlhdGVkIFNldCBvZiBlbnRyaWVzIHdoaWNoIGhhdmUgdG8gYmUgY29tcGFyZWRcbiAgLy8gcGFpcndpc2UuXG4gIHZhciBzZXQgPSBudWxsO1xuICB2YXIgYVZhbHVlcyA9IGFycmF5RnJvbVNldChhKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHZhbCA9IGFWYWx1ZXNbaV07XG4gICAgLy8gTm90ZTogQ2hlY2tpbmcgZm9yIHRoZSBvYmplY3RzIGZpcnN0IGltcHJvdmVzIHRoZSBwZXJmb3JtYW5jZSBmb3Igb2JqZWN0XG4gICAgLy8gaGVhdnkgc2V0cyBidXQgaXQgaXMgYSBtaW5vciBzbG93IGRvd24gZm9yIHByaW1pdGl2ZXMuIEFzIHRoZXkgYXJlIGZhc3RcbiAgICAvLyB0byBjaGVjayB0aGlzIGltcHJvdmVzIHRoZSB3b3JzdCBjYXNlIHNjZW5hcmlvIGluc3RlYWQuXG4gICAgaWYgKF90eXBlb2YodmFsKSA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICBpZiAoc2V0ID09PSBudWxsKSB7XG4gICAgICAgIHNldCA9IG5ldyBTZXQoKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZSBzcGVjaWZpZWQgdmFsdWUgZG9lc24ndCBleGlzdCBpbiB0aGUgc2Vjb25kIHNldCBpdHMgYW4gbm90IG51bGxcbiAgICAgIC8vIG9iamVjdCAob3Igbm9uIHN0cmljdCBvbmx5OiBhIG5vdCBtYXRjaGluZyBwcmltaXRpdmUpIHdlJ2xsIG5lZWQgdG8gZ29cbiAgICAgIC8vIGh1bnRpbmcgZm9yIHNvbWV0aGluZyB0aGF0cyBkZWVwLShzdHJpY3QtKWVxdWFsIHRvIGl0LiBUbyBtYWtlIHRoaXNcbiAgICAgIC8vIE8obiBsb2cgbikgY29tcGxleGl0eSB3ZSBoYXZlIHRvIGNvcHkgdGhlc2UgdmFsdWVzIGluIGEgbmV3IHNldCBmaXJzdC5cbiAgICAgIHNldC5hZGQodmFsKTtcbiAgICB9IGVsc2UgaWYgKCFiLmhhcyh2YWwpKSB7XG4gICAgICBpZiAoc3RyaWN0KSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vIEZhc3QgcGF0aCB0byBkZXRlY3QgbWlzc2luZyBzdHJpbmcsIHN5bWJvbCwgdW5kZWZpbmVkIGFuZCBudWxsIHZhbHVlcy5cbiAgICAgIGlmICghc2V0TWlnaHRIYXZlTG9vc2VQcmltKGEsIGIsIHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHNldCA9PT0gbnVsbCkge1xuICAgICAgICBzZXQgPSBuZXcgU2V0KCk7XG4gICAgICB9XG4gICAgICBzZXQuYWRkKHZhbCk7XG4gICAgfVxuICB9XG4gIGlmIChzZXQgIT09IG51bGwpIHtcbiAgICB2YXIgYlZhbHVlcyA9IGFycmF5RnJvbVNldChiKTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYlZhbHVlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfdmFsID0gYlZhbHVlc1tfaV07XG4gICAgICAvLyBXZSBoYXZlIHRvIGNoZWNrIGlmIGEgcHJpbWl0aXZlIHZhbHVlIGlzIGFscmVhZHlcbiAgICAgIC8vIG1hdGNoaW5nIGFuZCBvbmx5IGlmIGl0J3Mgbm90LCBnbyBodW50aW5nIGZvciBpdC5cbiAgICAgIGlmIChfdHlwZW9mKF92YWwpID09PSAnb2JqZWN0JyAmJiBfdmFsICE9PSBudWxsKSB7XG4gICAgICAgIGlmICghc2V0SGFzRXF1YWxFbGVtZW50KHNldCwgX3ZhbCwgc3RyaWN0LCBtZW1vKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmICFhLmhhcyhfdmFsKSAmJiAhc2V0SGFzRXF1YWxFbGVtZW50KHNldCwgX3ZhbCwgc3RyaWN0LCBtZW1vKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXQuc2l6ZSA9PT0gMDtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG1hcEhhc0VxdWFsRW50cnkoc2V0LCBtYXAsIGtleTEsIGl0ZW0xLCBzdHJpY3QsIG1lbW8pIHtcbiAgLy8gVG8gYmUgYWJsZSB0byBoYW5kbGUgY2FzZXMgbGlrZTpcbiAgLy8gICBNYXAoW1t7fSwgJ2EnXSwgW3t9LCAnYiddXSkgdnMgTWFwKFtbe30sICdiJ10sIFt7fSwgJ2EnXV0pXG4gIC8vIC4uLiB3ZSBuZWVkIHRvIGNvbnNpZGVyICphbGwqIG1hdGNoaW5nIGtleXMsIG5vdCBqdXN0IHRoZSBmaXJzdCB3ZSBmaW5kLlxuICB2YXIgc2V0VmFsdWVzID0gYXJyYXlGcm9tU2V0KHNldCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0VmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleTIgPSBzZXRWYWx1ZXNbaV07XG4gICAgaWYgKGlubmVyRGVlcEVxdWFsKGtleTEsIGtleTIsIHN0cmljdCwgbWVtbykgJiYgaW5uZXJEZWVwRXF1YWwoaXRlbTEsIG1hcC5nZXQoa2V5MiksIHN0cmljdCwgbWVtbykpIHtcbiAgICAgIHNldC5kZWxldGUoa2V5Mik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gbWFwRXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vKSB7XG4gIHZhciBzZXQgPSBudWxsO1xuICB2YXIgYUVudHJpZXMgPSBhcnJheUZyb21NYXAoYSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYUVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX2FFbnRyaWVzJGkgPSBfc2xpY2VkVG9BcnJheShhRW50cmllc1tpXSwgMiksXG4gICAgICBrZXkgPSBfYUVudHJpZXMkaVswXSxcbiAgICAgIGl0ZW0xID0gX2FFbnRyaWVzJGlbMV07XG4gICAgaWYgKF90eXBlb2Yoa2V5KSA9PT0gJ29iamVjdCcgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICBpZiAoc2V0ID09PSBudWxsKSB7XG4gICAgICAgIHNldCA9IG5ldyBTZXQoKTtcbiAgICAgIH1cbiAgICAgIHNldC5hZGQoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQnkgZGlyZWN0bHkgcmV0cmlldmluZyB0aGUgdmFsdWUgd2UgcHJldmVudCBhbm90aGVyIGIuaGFzKGtleSkgY2hlY2sgaW5cbiAgICAgIC8vIGFsbW9zdCBhbGwgcG9zc2libGUgY2FzZXMuXG4gICAgICB2YXIgaXRlbTIgPSBiLmdldChrZXkpO1xuICAgICAgaWYgKGl0ZW0yID09PSB1bmRlZmluZWQgJiYgIWIuaGFzKGtleSkgfHwgIWlubmVyRGVlcEVxdWFsKGl0ZW0xLCBpdGVtMiwgc3RyaWN0LCBtZW1vKSkge1xuICAgICAgICBpZiAoc3RyaWN0KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIEZhc3QgcGF0aCB0byBkZXRlY3QgbWlzc2luZyBzdHJpbmcsIHN5bWJvbCwgdW5kZWZpbmVkIGFuZCBudWxsXG4gICAgICAgIC8vIGtleXMuXG4gICAgICAgIGlmICghbWFwTWlnaHRIYXZlTG9vc2VQcmltKGEsIGIsIGtleSwgaXRlbTEsIG1lbW8pKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChzZXQgPT09IG51bGwpIHtcbiAgICAgICAgICBzZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0LmFkZChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoc2V0ICE9PSBudWxsKSB7XG4gICAgdmFyIGJFbnRyaWVzID0gYXJyYXlGcm9tTWFwKGIpO1xuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGJFbnRyaWVzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIHZhciBfYkVudHJpZXMkX2kgPSBfc2xpY2VkVG9BcnJheShiRW50cmllc1tfaTJdLCAyKSxcbiAgICAgICAgX2tleSA9IF9iRW50cmllcyRfaVswXSxcbiAgICAgICAgaXRlbSA9IF9iRW50cmllcyRfaVsxXTtcbiAgICAgIGlmIChfdHlwZW9mKF9rZXkpID09PSAnb2JqZWN0JyAmJiBfa2V5ICE9PSBudWxsKSB7XG4gICAgICAgIGlmICghbWFwSGFzRXF1YWxFbnRyeShzZXQsIGEsIF9rZXksIGl0ZW0sIHN0cmljdCwgbWVtbykpIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiAoIWEuaGFzKF9rZXkpIHx8ICFpbm5lckRlZXBFcXVhbChhLmdldChfa2V5KSwgaXRlbSwgZmFsc2UsIG1lbW8pKSAmJiAhbWFwSGFzRXF1YWxFbnRyeShzZXQsIGEsIF9rZXksIGl0ZW0sIGZhbHNlLCBtZW1vKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXQuc2l6ZSA9PT0gMDtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIHN0cmljdCwga2V5cywgbWVtb3MsIGl0ZXJhdGlvblR5cGUpIHtcbiAgLy8gU2V0cyBhbmQgbWFwcyBkb24ndCBoYXZlIHRoZWlyIGVudHJpZXMgYWNjZXNzaWJsZSB2aWEgbm9ybWFsIG9iamVjdFxuICAvLyBwcm9wZXJ0aWVzLlxuICB2YXIgaSA9IDA7XG4gIGlmIChpdGVyYXRpb25UeXBlID09PSBrSXNTZXQpIHtcbiAgICBpZiAoIXNldEVxdWl2KGEsIGIsIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGl0ZXJhdGlvblR5cGUgPT09IGtJc01hcCkge1xuICAgIGlmICghbWFwRXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXRlcmF0aW9uVHlwZSA9PT0ga0lzQXJyYXkpIHtcbiAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShhLCBpKSkge1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5KGIsIGkpIHx8ICFpbm5lckRlZXBFcXVhbChhW2ldLCBiW2ldLCBzdHJpY3QsIG1lbW9zKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChoYXNPd25Qcm9wZXJ0eShiLCBpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBcnJheSBpcyBzcGFyc2UuXG4gICAgICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgICBmb3IgKDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNBW2ldO1xuICAgICAgICAgIGlmICghaGFzT3duUHJvcGVydHkoYiwga2V5KSB8fCAhaW5uZXJEZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChrZXlzQS5sZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBUaGUgcGFpciBtdXN0IGhhdmUgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LlxuICAvLyBQb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0OlxuICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfa2V5MiA9IGtleXNbaV07XG4gICAgaWYgKCFpbm5lckRlZXBFcXVhbChhW19rZXkyXSwgYltfa2V5Ml0sIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaXNEZWVwRXF1YWwodmFsMSwgdmFsMikge1xuICByZXR1cm4gaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwga0xvb3NlKTtcbn1cbmZ1bmN0aW9uIGlzRGVlcFN0cmljdEVxdWFsKHZhbDEsIHZhbDIpIHtcbiAgcmV0dXJuIGlubmVyRGVlcEVxdWFsKHZhbDEsIHZhbDIsIGtTdHJpY3QpO1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzRGVlcEVxdWFsOiBpc0RlZXBFcXVhbCxcbiAgaXNEZWVwU3RyaWN0RXF1YWw6IGlzRGVlcFN0cmljdEVxdWFsXG59OyIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbmNvbnN0IGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbmNvbnN0IGN1c3RvbUluc3BlY3RTeW1ib2wgPVxuICAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sWydmb3InXSA9PT0gJ2Z1bmN0aW9uJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICA/IFN5bWJvbFsnZm9yJ10oJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICA6IG51bGxcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG5jb25zdCBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGNvbnN0IHByb3RvID0geyBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihwcm90bywgVWludDhBcnJheS5wcm90b3R5cGUpXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGFyciwgcHJvdG8pXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheVZpZXcodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIChpc0luc3RhbmNlKHZhbHVlLCBTaGFyZWRBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgU2hhcmVkQXJyYXlCdWZmZXIpKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgY29uc3QgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgY29uc3QgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLnByb3RvdHlwZSwgVWludDhBcnJheS5wcm90b3R5cGUpXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLCBVaW50OEFycmF5KVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICBjb25zdCBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICBsZXQgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICBjb25zdCBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICBjb25zdCBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheVZpZXcgKGFycmF5Vmlldykge1xuICBpZiAoaXNJbnN0YW5jZShhcnJheVZpZXcsIFVpbnQ4QXJyYXkpKSB7XG4gICAgY29uc3QgY29weSA9IG5ldyBVaW50OEFycmF5KGFycmF5VmlldylcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKGNvcHkuYnVmZmVyLCBjb3B5LmJ5dGVPZmZzZXQsIGNvcHkuYnl0ZUxlbmd0aClcbiAgfVxuICByZXR1cm4gZnJvbUFycmF5TGlrZShhcnJheVZpZXcpXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBsZXQgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIGNvbnN0IGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIGxldCB4ID0gYS5sZW5ndGhcbiAgbGV0IHkgPSBiLmxlbmd0aFxuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgbGV0IGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICBsZXQgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIGxldCBidWYgPSBsaXN0W2ldXG4gICAgaWYgKGlzSW5zdGFuY2UoYnVmLCBVaW50OEFycmF5KSkge1xuICAgICAgaWYgKHBvcyArIGJ1Zi5sZW5ndGggPiBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgYnVmLFxuICAgICAgICAgIHBvc1xuICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIH1cbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgY29uc3QgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJjaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgY29uc3QgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgbGV0IHN0ciA9ICcnXG4gIGNvbnN0IG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5pZiAoY3VzdG9tSW5zcGVjdFN5bWJvbCkge1xuICBCdWZmZXIucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdID0gQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIGxldCB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICBsZXQgeSA9IGVuZCAtIHN0YXJ0XG4gIGNvbnN0IGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgY29uc3QgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgY29uc3QgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgW3ZhbF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIGxldCBpbmRleFNpemUgPSAxXG4gIGxldCBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIGxldCB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIGxldCBpXG4gIGlmIChkaXIpIHtcbiAgICBsZXQgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBsZXQgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIGNvbnN0IHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBsZXQgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICBjb25zdCByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgY29uc3QgcmVzID0gW11cblxuICBsZXQgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgY29uc3QgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgbGV0IGNvZGVQb2ludCA9IG51bGxcbiAgICBsZXQgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKVxuICAgICAgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKVxuICAgICAgICAgID8gM1xuICAgICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpXG4gICAgICAgICAgICAgID8gMlxuICAgICAgICAgICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIGxldCBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbmNvbnN0IE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICBjb25zdCBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIGxldCByZXMgPSAnJ1xuICBsZXQgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGxldCByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICBsZXQgb3V0ID0gJydcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gaGV4U2xpY2VMb29rdXBUYWJsZVtidWZbaV1dXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBjb25zdCBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICBsZXQgcmVzID0gJydcbiAgLy8gSWYgYnl0ZXMubGVuZ3RoIGlzIG9kZCwgdGhlIGxhc3QgOCBiaXRzIG11c3QgYmUgaWdub3JlZCAoc2FtZSBhcyBub2RlLmpzKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICBjb25zdCBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihuZXdCdWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludExFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0XVxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50QkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIGxldCBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDggPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2TEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTZCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDMyQkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnVUludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ1VJbnQ2NExFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgbG8gPSBmaXJzdCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDI0XG5cbiAgY29uc3QgaGkgPSB0aGlzWysrb2Zmc2V0XSArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgbGFzdCAqIDIgKiogMjRcblxuICByZXR1cm4gQmlnSW50KGxvKSArIChCaWdJbnQoaGkpIDw8IEJpZ0ludCgzMikpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdVSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnVUludDY0QkUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCBoaSA9IGZpcnN0ICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF1cblxuICBjb25zdCBsbyA9IHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgbGFzdFxuXG4gIHJldHVybiAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKSArIEJpZ0ludChsbylcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldF1cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgaSA9IGJ5dGVMZW5ndGhcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnSW50NjRMRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgNF0gK1xuICAgIHRoaXNbb2Zmc2V0ICsgNV0gKiAyICoqIDggK1xuICAgIHRoaXNbb2Zmc2V0ICsgNl0gKiAyICoqIDE2ICtcbiAgICAobGFzdCA8PCAyNCkgLy8gT3ZlcmZsb3dcblxuICByZXR1cm4gKEJpZ0ludCh2YWwpIDw8IEJpZ0ludCgzMikpICtcbiAgICBCaWdJbnQoZmlyc3QgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNClcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0QkUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCB2YWwgPSAoZmlyc3QgPDwgMjQpICsgLy8gT3ZlcmZsb3dcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XVxuXG4gIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgK1xuICAgIEJpZ0ludCh0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIGxhc3QpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludEJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgbGV0IG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50OCA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNkxFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTZCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyTEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMkJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIHdydEJpZ1VJbnQ2NExFIChidWYsIHZhbHVlLCBvZmZzZXQsIG1pbiwgbWF4KSB7XG4gIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNylcblxuICBsZXQgbG8gPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsZXQgaGkgPSBOdW1iZXIodmFsdWUgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIHJldHVybiBvZmZzZXRcbn1cblxuZnVuY3Rpb24gd3J0QmlnVUludDY0QkUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbWluLCBtYXgpIHtcbiAgY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCA3KVxuXG4gIGxldCBsbyA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCArIDddID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA2XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNV0gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDRdID0gbG9cbiAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQgKyAzXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0ICsgMl0gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCArIDFdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXRdID0gaGlcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnVUludDY0TEUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdVSW50NjRCRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NEJFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIEJpZ0ludCgwKSwgQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgbGV0IGkgPSAwXG4gIGxldCBtdWwgPSAxXG4gIGxldCBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoIC0gMVxuICBsZXQgbXVsID0gMVxuICBsZXQgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdJbnQ2NExFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0TEUodGhpcywgdmFsdWUsIG9mZnNldCwgLUJpZ0ludCgnMHg4MDAwMDAwMDAwMDAwMDAwJyksIEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ0ludDY0QkUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCcweDgwMDAwMDAwMDAwMDAwMDAnKSwgQmlnSW50KCcweDdmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICBjb25zdCBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICB2YWwgPSBOdW1iZXIodmFsKVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIGxldCBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIENVU1RPTSBFUlJPUlNcbi8vID09PT09PT09PT09PT1cblxuLy8gU2ltcGxpZmllZCB2ZXJzaW9ucyBmcm9tIE5vZGUsIGNoYW5nZWQgZm9yIEJ1ZmZlci1vbmx5IHVzYWdlXG5jb25zdCBlcnJvcnMgPSB7fVxuZnVuY3Rpb24gRSAoc3ltLCBnZXRNZXNzYWdlLCBCYXNlKSB7XG4gIGVycm9yc1tzeW1dID0gY2xhc3MgTm9kZUVycm9yIGV4dGVuZHMgQmFzZSB7XG4gICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgc3VwZXIoKVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ21lc3NhZ2UnLCB7XG4gICAgICAgIHZhbHVlOiBnZXRNZXNzYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pXG5cbiAgICAgIC8vIEFkZCB0aGUgZXJyb3IgY29kZSB0byB0aGUgbmFtZSB0byBpbmNsdWRlIGl0IGluIHRoZSBzdGFjayB0cmFjZS5cbiAgICAgIHRoaXMubmFtZSA9IGAke3RoaXMubmFtZX0gWyR7c3ltfV1gXG4gICAgICAvLyBBY2Nlc3MgdGhlIHN0YWNrIHRvIGdlbmVyYXRlIHRoZSBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyB0aGUgZXJyb3IgY29kZVxuICAgICAgLy8gZnJvbSB0aGUgbmFtZS5cbiAgICAgIHRoaXMuc3RhY2sgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbiAgICAgIC8vIFJlc2V0IHRoZSBuYW1lIHRvIHRoZSBhY3R1YWwgbmFtZS5cbiAgICAgIGRlbGV0ZSB0aGlzLm5hbWVcbiAgICB9XG5cbiAgICBnZXQgY29kZSAoKSB7XG4gICAgICByZXR1cm4gc3ltXG4gICAgfVxuXG4gICAgc2V0IGNvZGUgKHZhbHVlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NvZGUnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRvU3RyaW5nICgpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLm5hbWV9IFske3N5bX1dOiAke3RoaXMubWVzc2FnZX1gXG4gICAgfVxuICB9XG59XG5cbkUoJ0VSUl9CVUZGRVJfT1VUX09GX0JPVU5EUycsXG4gIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiBgJHtuYW1lfSBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHNgXG4gICAgfVxuXG4gICAgcmV0dXJuICdBdHRlbXB0IHRvIGFjY2VzcyBtZW1vcnkgb3V0c2lkZSBidWZmZXIgYm91bmRzJ1xuICB9LCBSYW5nZUVycm9yKVxuRSgnRVJSX0lOVkFMSURfQVJHX1RZUEUnLFxuICBmdW5jdGlvbiAobmFtZSwgYWN0dWFsKSB7XG4gICAgcmV0dXJuIGBUaGUgXCIke25hbWV9XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSAke3R5cGVvZiBhY3R1YWx9YFxuICB9LCBUeXBlRXJyb3IpXG5FKCdFUlJfT1VUX09GX1JBTkdFJyxcbiAgZnVuY3Rpb24gKHN0ciwgcmFuZ2UsIGlucHV0KSB7XG4gICAgbGV0IG1zZyA9IGBUaGUgdmFsdWUgb2YgXCIke3N0cn1cIiBpcyBvdXQgb2YgcmFuZ2UuYFxuICAgIGxldCByZWNlaXZlZCA9IGlucHV0XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIoaW5wdXQpICYmIE1hdGguYWJzKGlucHV0KSA+IDIgKiogMzIpIHtcbiAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKFN0cmluZyhpbnB1dCkpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdiaWdpbnQnKSB7XG4gICAgICByZWNlaXZlZCA9IFN0cmluZyhpbnB1dClcbiAgICAgIGlmIChpbnB1dCA+IEJpZ0ludCgyKSAqKiBCaWdJbnQoMzIpIHx8IGlucHV0IDwgLShCaWdJbnQoMikgKiogQmlnSW50KDMyKSkpIHtcbiAgICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IocmVjZWl2ZWQpXG4gICAgICB9XG4gICAgICByZWNlaXZlZCArPSAnbidcbiAgICB9XG4gICAgbXNnICs9IGAgSXQgbXVzdCBiZSAke3JhbmdlfS4gUmVjZWl2ZWQgJHtyZWNlaXZlZH1gXG4gICAgcmV0dXJuIG1zZ1xuICB9LCBSYW5nZUVycm9yKVxuXG5mdW5jdGlvbiBhZGROdW1lcmljYWxTZXBhcmF0b3IgKHZhbCkge1xuICBsZXQgcmVzID0gJydcbiAgbGV0IGkgPSB2YWwubGVuZ3RoXG4gIGNvbnN0IHN0YXJ0ID0gdmFsWzBdID09PSAnLScgPyAxIDogMFxuICBmb3IgKDsgaSA+PSBzdGFydCArIDQ7IGkgLT0gMykge1xuICAgIHJlcyA9IGBfJHt2YWwuc2xpY2UoaSAtIDMsIGkpfSR7cmVzfWBcbiAgfVxuICByZXR1cm4gYCR7dmFsLnNsaWNlKDAsIGkpfSR7cmVzfWBcbn1cblxuLy8gQ0hFQ0sgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gY2hlY2tCb3VuZHMgKGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGlmIChidWZbb2Zmc2V0XSA9PT0gdW5kZWZpbmVkIHx8IGJ1ZltvZmZzZXQgKyBieXRlTGVuZ3RoXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCBidWYubGVuZ3RoIC0gKGJ5dGVMZW5ndGggKyAxKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0ludEJJICh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikge1xuICAgIGNvbnN0IG4gPSB0eXBlb2YgbWluID09PSAnYmlnaW50JyA/ICduJyA6ICcnXG4gICAgbGV0IHJhbmdlXG4gICAgaWYgKGJ5dGVMZW5ndGggPiAzKSB7XG4gICAgICBpZiAobWluID09PSAwIHx8IG1pbiA9PT0gQmlnSW50KDApKSB7XG4gICAgICAgIHJhbmdlID0gYD49IDAke259IGFuZCA8IDIke259ICoqICR7KGJ5dGVMZW5ndGggKyAxKSAqIDh9JHtufWBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlID0gYD49IC0oMiR7bn0gKiogJHsoYnl0ZUxlbmd0aCArIDEpICogOCAtIDF9JHtufSkgYW5kIDwgMiAqKiBgICtcbiAgICAgICAgICAgICAgICBgJHsoYnl0ZUxlbmd0aCArIDEpICogOCAtIDF9JHtufWBcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2UgPSBgPj0gJHttaW59JHtufSBhbmQgPD0gJHttYXh9JHtufWBcbiAgICB9XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKCd2YWx1ZScsIHJhbmdlLCB2YWx1ZSlcbiAgfVxuICBjaGVja0JvdW5kcyhidWYsIG9mZnNldCwgYnl0ZUxlbmd0aClcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXIgKHZhbHVlLCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnbnVtYmVyJywgdmFsdWUpXG4gIH1cbn1cblxuZnVuY3Rpb24gYm91bmRzRXJyb3IgKHZhbHVlLCBsZW5ndGgsIHR5cGUpIHtcbiAgaWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSkge1xuICAgIHZhbGlkYXRlTnVtYmVyKHZhbHVlLCB0eXBlKVxuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSh0eXBlIHx8ICdvZmZzZXQnLCAnYW4gaW50ZWdlcicsIHZhbHVlKVxuICB9XG5cbiAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUygpXG4gIH1cblxuICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAnb2Zmc2V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGA+PSAke3R5cGUgPyAxIDogMH0gYW5kIDw9ICR7bGVuZ3RofWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSlcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG5jb25zdCBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgbGV0IGNvZGVQb2ludFxuICBjb25zdCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIGxldCBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICBjb25zdCBieXRlcyA9IFtdXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIGNvbnN0IGJ5dGVBcnJheSA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgbGV0IGMsIGhpLCBsb1xuICBjb25zdCBieXRlQXJyYXkgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGxldCBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG4vLyBDcmVhdGUgbG9va3VwIHRhYmxlIGZvciBgdG9TdHJpbmcoJ2hleCcpYFxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMjE5XG5jb25zdCBoZXhTbGljZUxvb2t1cFRhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgYWxwaGFiZXQgPSAnMDEyMzQ1Njc4OWFiY2RlZidcbiAgY29uc3QgdGFibGUgPSBuZXcgQXJyYXkoMjU2KVxuICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICBjb25zdCBpMTYgPSBpICogMTZcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIHRhYmxlW2kxNiArIGpdID0gYWxwaGFiZXRbaV0gKyBhbHBoYWJldFtqXVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFibGVcbn0pKClcblxuLy8gUmV0dXJuIG5vdCBmdW5jdGlvbiB3aXRoIEVycm9yIGlmIEJpZ0ludCBub3Qgc3VwcG9ydGVkXG5mdW5jdGlvbiBkZWZpbmVCaWdJbnRNZXRob2QgKGZuKSB7XG4gIHJldHVybiB0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJyA/IEJ1ZmZlckJpZ0ludE5vdERlZmluZWQgOiBmblxufVxuXG5mdW5jdGlvbiBCdWZmZXJCaWdJbnROb3REZWZpbmVkICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdCaWdJbnQgbm90IHN1cHBvcnRlZCcpXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xuXG52YXIgJGFwcGx5ID0gcmVxdWlyZSgnLi9mdW5jdGlvbkFwcGx5Jyk7XG52YXIgJGNhbGwgPSByZXF1aXJlKCcuL2Z1bmN0aW9uQ2FsbCcpO1xudmFyICRyZWZsZWN0QXBwbHkgPSByZXF1aXJlKCcuL3JlZmxlY3RBcHBseScpO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9hY3R1YWxBcHBseScpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSAkcmVmbGVjdEFwcGx5IHx8IGJpbmQuY2FsbCgkY2FsbCwgJGFwcGx5KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG52YXIgJGFwcGx5ID0gcmVxdWlyZSgnLi9mdW5jdGlvbkFwcGx5Jyk7XG52YXIgYWN0dWFsQXBwbHkgPSByZXF1aXJlKCcuL2FjdHVhbEFwcGx5Jyk7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL2FwcGx5QmluZCcpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhcHBseUJpbmQoKSB7XG5cdHJldHVybiBhY3R1YWxBcHBseShiaW5kLCAkYXBwbHksIGFyZ3VtZW50cyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9mdW5jdGlvbkFwcGx5Jyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vZnVuY3Rpb25DYWxsJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcbnZhciAkVHlwZUVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzL3R5cGUnKTtcblxudmFyICRjYWxsID0gcmVxdWlyZSgnLi9mdW5jdGlvbkNhbGwnKTtcbnZhciAkYWN0dWFsQXBwbHkgPSByZXF1aXJlKCcuL2FjdHVhbEFwcGx5Jyk7XG5cbi8qKiBAdHlwZSB7KGFyZ3M6IFtGdW5jdGlvbiwgdGhpc0FyZz86IHVua25vd24sIC4uLmFyZ3M6IHVua25vd25bXV0pID0+IEZ1bmN0aW9ufSBUT0RPIEZJWE1FLCBmaW5kIGEgd2F5IHRvIHVzZSBpbXBvcnQoJy4nKSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQmluZEJhc2ljKGFyZ3MpIHtcblx0aWYgKGFyZ3MubGVuZ3RoIDwgMSB8fCB0eXBlb2YgYXJnc1swXSAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdhIGZ1bmN0aW9uIGlzIHJlcXVpcmVkJyk7XG5cdH1cblx0cmV0dXJuICRhY3R1YWxBcHBseShiaW5kLCAkY2FsbCwgYXJncyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9yZWZsZWN0QXBwbHknKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIFJlZmxlY3QgJiYgUmVmbGVjdC5hcHBseTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyIGNhbGxCaW5kID0gcmVxdWlyZSgnLi8nKTtcblxudmFyICRpbmRleE9mID0gY2FsbEJpbmQoR2V0SW50cmluc2ljKCdTdHJpbmcucHJvdG90eXBlLmluZGV4T2YnKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FsbEJvdW5kSW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHR2YXIgaW50cmluc2ljID0gR2V0SW50cmluc2ljKG5hbWUsICEhYWxsb3dNaXNzaW5nKTtcblx0aWYgKHR5cGVvZiBpbnRyaW5zaWMgPT09ICdmdW5jdGlvbicgJiYgJGluZGV4T2YobmFtZSwgJy5wcm90b3R5cGUuJykgPiAtMSkge1xuXHRcdHJldHVybiBjYWxsQmluZChpbnRyaW5zaWMpO1xuXHR9XG5cdHJldHVybiBpbnRyaW5zaWM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2V0RnVuY3Rpb25MZW5ndGggPSByZXF1aXJlKCdzZXQtZnVuY3Rpb24tbGVuZ3RoJyk7XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCdlcy1kZWZpbmUtcHJvcGVydHknKTtcblxudmFyIGNhbGxCaW5kQmFzaWMgPSByZXF1aXJlKCdjYWxsLWJpbmQtYXBwbHktaGVscGVycycpO1xudmFyIGFwcGx5QmluZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC1hcHBseS1oZWxwZXJzL2FwcGx5QmluZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCaW5kKG9yaWdpbmFsRnVuY3Rpb24pIHtcblx0dmFyIGZ1bmMgPSBjYWxsQmluZEJhc2ljKGFyZ3VtZW50cyk7XG5cdHZhciBhZGp1c3RlZExlbmd0aCA9IG9yaWdpbmFsRnVuY3Rpb24ubGVuZ3RoIC0gKGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcblx0cmV0dXJuIHNldEZ1bmN0aW9uTGVuZ3RoKFxuXHRcdGZ1bmMsXG5cdFx0MSArIChhZGp1c3RlZExlbmd0aCA+IDAgPyBhZGp1c3RlZExlbmd0aCA6IDApLFxuXHRcdHRydWVcblx0KTtcbn07XG5cbmlmICgkZGVmaW5lUHJvcGVydHkpIHtcblx0JGRlZmluZVByb3BlcnR5KG1vZHVsZS5leHBvcnRzLCAnYXBwbHknLCB7IHZhbHVlOiBhcHBseUJpbmQgfSk7XG59IGVsc2Uge1xuXHRtb2R1bGUuZXhwb3J0cy5hcHBseSA9IGFwcGx5QmluZDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyIGNhbGxCaW5kQmFzaWMgPSByZXF1aXJlKCdjYWxsLWJpbmQtYXBwbHktaGVscGVycycpO1xuXG4vKiogQHR5cGUgeyh0aGlzQXJnOiBzdHJpbmcsIHNlYXJjaFN0cmluZzogc3RyaW5nLCBwb3NpdGlvbj86IG51bWJlcikgPT4gbnVtYmVyfSAqL1xudmFyICRpbmRleE9mID0gY2FsbEJpbmRCYXNpYyhbR2V0SW50cmluc2ljKCclU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mJScpXSk7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCb3VuZEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0LyogZXNsaW50IG5vLWV4dHJhLXBhcmVuczogMCAqL1xuXG5cdHZhciBpbnRyaW5zaWMgPSAvKiogQHR5cGUgeyh0aGlzOiB1bmtub3duLCAuLi5hcmdzOiB1bmtub3duW10pID0+IHVua25vd259ICovIChHZXRJbnRyaW5zaWMobmFtZSwgISFhbGxvd01pc3NpbmcpKTtcblx0aWYgKHR5cGVvZiBpbnRyaW5zaWMgPT09ICdmdW5jdGlvbicgJiYgJGluZGV4T2YobmFtZSwgJy5wcm90b3R5cGUuJykgPiAtMSkge1xuXHRcdHJldHVybiBjYWxsQmluZEJhc2ljKC8qKiBAdHlwZSB7Y29uc3R9ICovIChbaW50cmluc2ljXSkpO1xuXHR9XG5cdHJldHVybiBpbnRyaW5zaWM7XG59O1xuIiwiLypnbG9iYWwgd2luZG93LCBnbG9iYWwqL1xudmFyIHV0aWwgPSByZXF1aXJlKFwidXRpbFwiKVxudmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIilcbmZ1bmN0aW9uIG5vdygpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpIH1cblxudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlXG52YXIgY29uc29sZVxudmFyIHRpbWVzID0ge31cblxuaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNvbnNvbGUpIHtcbiAgICBjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGVcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuY29uc29sZSkge1xuICAgIGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZVxufSBlbHNlIHtcbiAgICBjb25zb2xlID0ge31cbn1cblxudmFyIGZ1bmN0aW9ucyA9IFtcbiAgICBbbG9nLCBcImxvZ1wiXSxcbiAgICBbaW5mbywgXCJpbmZvXCJdLFxuICAgIFt3YXJuLCBcIndhcm5cIl0sXG4gICAgW2Vycm9yLCBcImVycm9yXCJdLFxuICAgIFt0aW1lLCBcInRpbWVcIl0sXG4gICAgW3RpbWVFbmQsIFwidGltZUVuZFwiXSxcbiAgICBbdHJhY2UsIFwidHJhY2VcIl0sXG4gICAgW2RpciwgXCJkaXJcIl0sXG4gICAgW2NvbnNvbGVBc3NlcnQsIFwiYXNzZXJ0XCJdXG5dXG5cbmZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHR1cGxlID0gZnVuY3Rpb25zW2ldXG4gICAgdmFyIGYgPSB0dXBsZVswXVxuICAgIHZhciBuYW1lID0gdHVwbGVbMV1cblxuICAgIGlmICghY29uc29sZVtuYW1lXSkge1xuICAgICAgICBjb25zb2xlW25hbWVdID0gZlxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25zb2xlXG5cbmZ1bmN0aW9uIGxvZygpIHt9XG5cbmZ1bmN0aW9uIGluZm8oKSB7XG4gICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxufVxuXG5mdW5jdGlvbiB3YXJuKCkge1xuICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbn1cblxuZnVuY3Rpb24gZXJyb3IoKSB7XG4gICAgY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbn1cblxuZnVuY3Rpb24gdGltZShsYWJlbCkge1xuICAgIHRpbWVzW2xhYmVsXSA9IG5vdygpXG59XG5cbmZ1bmN0aW9uIHRpbWVFbmQobGFiZWwpIHtcbiAgICB2YXIgdGltZSA9IHRpbWVzW2xhYmVsXVxuICAgIGlmICghdGltZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdWNoIGxhYmVsOiBcIiArIGxhYmVsKVxuICAgIH1cblxuICAgIGRlbGV0ZSB0aW1lc1tsYWJlbF1cbiAgICB2YXIgZHVyYXRpb24gPSBub3coKSAtIHRpbWVcbiAgICBjb25zb2xlLmxvZyhsYWJlbCArIFwiOiBcIiArIGR1cmF0aW9uICsgXCJtc1wiKVxufVxuXG5mdW5jdGlvbiB0cmFjZSgpIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKClcbiAgICBlcnIubmFtZSA9IFwiVHJhY2VcIlxuICAgIGVyci5tZXNzYWdlID0gdXRpbC5mb3JtYXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIGNvbnNvbGUuZXJyb3IoZXJyLnN0YWNrKVxufVxuXG5mdW5jdGlvbiBkaXIob2JqZWN0KSB7XG4gICAgY29uc29sZS5sb2codXRpbC5pbnNwZWN0KG9iamVjdCkgKyBcIlxcblwiKVxufVxuXG5mdW5jdGlvbiBjb25zb2xlQXNzZXJ0KGV4cHJlc3Npb24pIHtcbiAgICBpZiAoIWV4cHJlc3Npb24pIHtcbiAgICAgICAgdmFyIGFyciA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICAgICBhc3NlcnQub2soZmFsc2UsIHV0aWwuZm9ybWF0LmFwcGx5KG51bGwsIGFycikpXG4gICAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnZXMtZGVmaW5lLXByb3BlcnR5Jyk7XG5cbnZhciAkU3ludGF4RXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMvc3ludGF4Jyk7XG52YXIgJFR5cGVFcnJvciA9IHJlcXVpcmUoJ2VzLWVycm9ycy90eXBlJyk7XG5cbnZhciBnb3BkID0gcmVxdWlyZSgnZ29wZCcpO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVEYXRhUHJvcGVydHkoXG5cdG9iaixcblx0cHJvcGVydHksXG5cdHZhbHVlXG4pIHtcblx0aWYgKCFvYmogfHwgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmogIT09ICdmdW5jdGlvbicpKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2BvYmpgIG11c3QgYmUgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb25gJyk7XG5cdH1cblx0aWYgKHR5cGVvZiBwcm9wZXJ0eSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHByb3BlcnR5ICE9PSAnc3ltYm9sJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgcHJvcGVydHlgIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBzeW1ib2xgJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIHR5cGVvZiBhcmd1bWVudHNbM10gIT09ICdib29sZWFuJyAmJiBhcmd1bWVudHNbM10gIT09IG51bGwpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYG5vbkVudW1lcmFibGVgLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIGJvb2xlYW4gb3IgbnVsbCcpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gNCAmJiB0eXBlb2YgYXJndW1lbnRzWzRdICE9PSAnYm9vbGVhbicgJiYgYXJndW1lbnRzWzRdICE9PSBudWxsKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Bub25Xcml0YWJsZWAsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGEgYm9vbGVhbiBvciBudWxsJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIHR5cGVvZiBhcmd1bWVudHNbNV0gIT09ICdib29sZWFuJyAmJiBhcmd1bWVudHNbNV0gIT09IG51bGwpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYG5vbkNvbmZpZ3VyYWJsZWAsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGEgYm9vbGVhbiBvciBudWxsJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIHR5cGVvZiBhcmd1bWVudHNbNl0gIT09ICdib29sZWFuJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgbG9vc2VgLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblx0fVxuXG5cdHZhciBub25FbnVtZXJhYmxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXHR2YXIgbm9uV3JpdGFibGUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCA/IGFyZ3VtZW50c1s0XSA6IG51bGw7XG5cdHZhciBub25Db25maWd1cmFibGUgPSBhcmd1bWVudHMubGVuZ3RoID4gNSA/IGFyZ3VtZW50c1s1XSA6IG51bGw7XG5cdHZhciBsb29zZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ID8gYXJndW1lbnRzWzZdIDogZmFsc2U7XG5cblx0LyogQHR5cGUge2ZhbHNlIHwgVHlwZWRQcm9wZXJ0eURlc2NyaXB0b3I8dW5rbm93bj59ICovXG5cdHZhciBkZXNjID0gISFnb3BkICYmIGdvcGQob2JqLCBwcm9wZXJ0eSk7XG5cblx0aWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdCRkZWZpbmVQcm9wZXJ0eShvYmosIHByb3BlcnR5LCB7XG5cdFx0XHRjb25maWd1cmFibGU6IG5vbkNvbmZpZ3VyYWJsZSA9PT0gbnVsbCAmJiBkZXNjID8gZGVzYy5jb25maWd1cmFibGUgOiAhbm9uQ29uZmlndXJhYmxlLFxuXHRcdFx0ZW51bWVyYWJsZTogbm9uRW51bWVyYWJsZSA9PT0gbnVsbCAmJiBkZXNjID8gZGVzYy5lbnVtZXJhYmxlIDogIW5vbkVudW1lcmFibGUsXG5cdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHR3cml0YWJsZTogbm9uV3JpdGFibGUgPT09IG51bGwgJiYgZGVzYyA/IGRlc2Mud3JpdGFibGUgOiAhbm9uV3JpdGFibGVcblx0XHR9KTtcblx0fSBlbHNlIGlmIChsb29zZSB8fCAoIW5vbkVudW1lcmFibGUgJiYgIW5vbldyaXRhYmxlICYmICFub25Db25maWd1cmFibGUpKSB7XG5cdFx0Ly8gbXVzdCBmYWxsIGJhY2sgdG8gW1tTZXRdXSwgYW5kIHdhcyBub3QgZXhwbGljaXRseSBhc2tlZCB0byBtYWtlIG5vbi1lbnVtZXJhYmxlLCBub24td3JpdGFibGUsIG9yIG5vbi1jb25maWd1cmFibGVcblx0XHRvYmpbcHJvcGVydHldID0gdmFsdWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdUaGlzIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgZGVmaW5pbmcgYSBwcm9wZXJ0eSBhcyBub24tY29uZmlndXJhYmxlLCBub24td3JpdGFibGUsIG9yIG5vbi1lbnVtZXJhYmxlLicpO1xuXHR9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5cyA9IHJlcXVpcmUoJ29iamVjdC1rZXlzJyk7XG52YXIgaGFzU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbCgnZm9vJykgPT09ICdzeW1ib2wnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGNvbmNhdCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQ7XG52YXIgZGVmaW5lRGF0YVByb3BlcnR5ID0gcmVxdWlyZSgnZGVmaW5lLWRhdGEtcHJvcGVydHknKTtcblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAoZm4pIHtcblx0cmV0dXJuIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyAmJiB0b1N0ci5jYWxsKGZuKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG5cbnZhciBzdXBwb3J0c0Rlc2NyaXB0b3JzID0gcmVxdWlyZSgnaGFzLXByb3BlcnR5LWRlc2NyaXB0b3JzJykoKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgdmFsdWUsIHByZWRpY2F0ZSkge1xuXHRpZiAobmFtZSBpbiBvYmplY3QpIHtcblx0XHRpZiAocHJlZGljYXRlID09PSB0cnVlKSB7XG5cdFx0XHRpZiAob2JqZWN0W25hbWVdID09PSB2YWx1ZSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICghaXNGdW5jdGlvbihwcmVkaWNhdGUpIHx8ICFwcmVkaWNhdGUoKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0fVxuXG5cdGlmIChzdXBwb3J0c0Rlc2NyaXB0b3JzKSB7XG5cdFx0ZGVmaW5lRGF0YVByb3BlcnR5KG9iamVjdCwgbmFtZSwgdmFsdWUsIHRydWUpO1xuXHR9IGVsc2Uge1xuXHRcdGRlZmluZURhdGFQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHZhbHVlKTtcblx0fVxufTtcblxudmFyIGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqZWN0LCBtYXApIHtcblx0dmFyIHByZWRpY2F0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXHR2YXIgcHJvcHMgPSBrZXlzKG1hcCk7XG5cdGlmIChoYXNTeW1ib2xzKSB7XG5cdFx0cHJvcHMgPSBjb25jYXQuY2FsbChwcm9wcywgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhtYXApKTtcblx0fVxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0ZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wc1tpXSwgbWFwW3Byb3BzW2ldXSwgcHJlZGljYXRlc1twcm9wc1tpXV0pO1xuXHR9XG59O1xuXG5kZWZpbmVQcm9wZXJ0aWVzLnN1cHBvcnRzRGVzY3JpcHRvcnMgPSAhIXN1cHBvcnRzRGVzY3JpcHRvcnM7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydGllcztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNhbGxCaW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kLWFwcGx5LWhlbHBlcnMnKTtcbnZhciBnT1BEID0gcmVxdWlyZSgnZ29wZCcpO1xuXG52YXIgaGFzUHJvdG9BY2Nlc3NvcjtcbnRyeSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1wYXJlbnMsIG5vLXByb3RvXG5cdGhhc1Byb3RvQWNjZXNzb3IgPSAvKiogQHR5cGUge3sgX19wcm90b19fPzogdHlwZW9mIEFycmF5LnByb3RvdHlwZSB9fSAqLyAoW10pLl9fcHJvdG9fXyA9PT0gQXJyYXkucHJvdG90eXBlO1xufSBjYXRjaCAoZSkge1xuXHRpZiAoIWUgfHwgdHlwZW9mIGUgIT09ICdvYmplY3QnIHx8ICEoJ2NvZGUnIGluIGUpIHx8IGUuY29kZSAhPT0gJ0VSUl9QUk9UT19BQ0NFU1MnKSB7XG5cdFx0dGhyb3cgZTtcblx0fVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0cmEtcGFyZW5zXG52YXIgZGVzYyA9ICEhaGFzUHJvdG9BY2Nlc3NvciAmJiBnT1BEICYmIGdPUEQoT2JqZWN0LnByb3RvdHlwZSwgLyoqIEB0eXBlIHtrZXlvZiB0eXBlb2YgT2JqZWN0LnByb3RvdHlwZX0gKi8gKCdfX3Byb3RvX18nKSk7XG5cbnZhciAkT2JqZWN0ID0gT2JqZWN0O1xudmFyICRnZXRQcm90b3R5cGVPZiA9ICRPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL2dldCcpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBkZXNjICYmIHR5cGVvZiBkZXNjLmdldCA9PT0gJ2Z1bmN0aW9uJ1xuXHQ/IGNhbGxCaW5kKFtkZXNjLmdldF0pXG5cdDogdHlwZW9mICRnZXRQcm90b3R5cGVPZiA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdD8gLyoqIEB0eXBlIHtpbXBvcnQoJy4vZ2V0Jyl9ICovIGZ1bmN0aW9uIGdldER1bmRlcih2YWx1ZSkge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0cmV0dXJuICRnZXRQcm90b3R5cGVPZih2YWx1ZSA9PSBudWxsID8gdmFsdWUgOiAkT2JqZWN0KHZhbHVlKSk7XG5cdFx0fVxuXHRcdDogZmFsc2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG52YXIgJGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5IHx8IGZhbHNlO1xuaWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHR0cnkge1xuXHRcdCRkZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IHZhbHVlOiAxIH0pO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gSUUgOCBoYXMgYSBicm9rZW4gZGVmaW5lUHJvcGVydHlcblx0XHQkZGVmaW5lUHJvcGVydHkgPSBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICRkZWZpbmVQcm9wZXJ0eTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vZXZhbCcpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBFdmFsRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IEVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9yYW5nZScpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBSYW5nZUVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9yZWYnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gUmVmZXJlbmNlRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3N5bnRheCcpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBTeW50YXhFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZScpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBUeXBlRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3VyaScpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBVUklFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJ2lzLWNhbGxhYmxlJyk7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKiogQHR5cGUgezxUaGlzLCBBIGV4dGVuZHMgcmVhZG9ubHkgdW5rbm93bltdPihhcnI6IEEsIGl0ZXJhdG9yOiAodGhpczogVGhpcyB8IHZvaWQsIHZhbHVlOiBBW251bWJlcl0sIGluZGV4OiBudW1iZXIsIGFycjogQSkgPT4gdm9pZCwgcmVjZWl2ZXI6IFRoaXMgfCB1bmRlZmluZWQpID0+IHZvaWR9ICovXG52YXIgZm9yRWFjaEFycmF5ID0gZnVuY3Rpb24gZm9yRWFjaEFycmF5KGFycmF5LCBpdGVyYXRvciwgcmVjZWl2ZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksIGkpKSB7XG4gICAgICAgICAgICBpZiAocmVjZWl2ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yKGFycmF5W2ldLCBpLCBhcnJheSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwocmVjZWl2ZXIsIGFycmF5W2ldLCBpLCBhcnJheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKiogQHR5cGUgezxUaGlzLCBTIGV4dGVuZHMgc3RyaW5nPihzdHJpbmc6IFMsIGl0ZXJhdG9yOiAodGhpczogVGhpcyB8IHZvaWQsIHZhbHVlOiBTW251bWJlcl0sIGluZGV4OiBudW1iZXIsIHN0cmluZzogUykgPT4gdm9pZCwgcmVjZWl2ZXI6IFRoaXMgfCB1bmRlZmluZWQpID0+IHZvaWR9ICovXG52YXIgZm9yRWFjaFN0cmluZyA9IGZ1bmN0aW9uIGZvckVhY2hTdHJpbmcoc3RyaW5nLCBpdGVyYXRvciwgcmVjZWl2ZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIG5vIHN1Y2ggdGhpbmcgYXMgYSBzcGFyc2Ugc3RyaW5nLlxuICAgICAgICBpZiAocmVjZWl2ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgaXRlcmF0b3Ioc3RyaW5nLmNoYXJBdChpKSwgaSwgc3RyaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwocmVjZWl2ZXIsIHN0cmluZy5jaGFyQXQoaSksIGksIHN0cmluZyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKiogQHR5cGUgezxUaGlzLCBPPihvYmo6IE8sIGl0ZXJhdG9yOiAodGhpczogVGhpcyB8IHZvaWQsIHZhbHVlOiBPW2tleW9mIE9dLCBpbmRleDoga2V5b2YgTywgb2JqOiBPKSA9PiB2b2lkLCByZWNlaXZlcjogVGhpcyB8IHVuZGVmaW5lZCkgPT4gdm9pZH0gKi9cbnZhciBmb3JFYWNoT2JqZWN0ID0gZnVuY3Rpb24gZm9yRWFjaE9iamVjdChvYmplY3QsIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGsgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgaykpIHtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3Iob2JqZWN0W2tdLCBrLCBvYmplY3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5jYWxsKHJlY2VpdmVyLCBvYmplY3Rba10sIGssIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKiogQHR5cGUgeyh4OiB1bmtub3duKSA9PiB4IGlzIHJlYWRvbmx5IHVua25vd25bXX0gKi9cbmZ1bmN0aW9uIGlzQXJyYXkoeCkge1xuICAgIHJldHVybiB0b1N0ci5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpLl9pbnRlcm5hbH0gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZm9yRWFjaChsaXN0LCBpdGVyYXRvciwgdGhpc0FyZykge1xuICAgIGlmICghaXNDYWxsYWJsZShpdGVyYXRvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgdmFyIHJlY2VpdmVyO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIHtcbiAgICAgICAgcmVjZWl2ZXIgPSB0aGlzQXJnO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KGxpc3QpKSB7XG4gICAgICAgIGZvckVhY2hBcnJheShsaXN0LCBpdGVyYXRvciwgcmVjZWl2ZXIpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZvckVhY2hTdHJpbmcobGlzdCwgaXRlcmF0b3IsIHJlY2VpdmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3JFYWNoT2JqZWN0KGxpc3QsIGl0ZXJhdG9yLCByZWNlaXZlcik7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50IG5vLWludmFsaWQtdGhpczogMSAqL1xuXG52YXIgRVJST1JfTUVTU0FHRSA9ICdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlICc7XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIGZ1bmNUeXBlID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblxudmFyIGNvbmNhdHR5ID0gZnVuY3Rpb24gY29uY2F0dHkoYSwgYikge1xuICAgIHZhciBhcnIgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBhcnJbaV0gPSBhW2ldO1xuICAgIH1cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGIubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgYXJyW2ogKyBhLmxlbmd0aF0gPSBiW2pdO1xuICAgIH1cblxuICAgIHJldHVybiBhcnI7XG59O1xuXG52YXIgc2xpY3kgPSBmdW5jdGlvbiBzbGljeShhcnJMaWtlLCBvZmZzZXQpIHtcbiAgICB2YXIgYXJyID0gW107XG4gICAgZm9yICh2YXIgaSA9IG9mZnNldCB8fCAwLCBqID0gMDsgaSA8IGFyckxpa2UubGVuZ3RoOyBpICs9IDEsIGogKz0gMSkge1xuICAgICAgICBhcnJbal0gPSBhcnJMaWtlW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufTtcblxudmFyIGpvaW55ID0gZnVuY3Rpb24gKGFyciwgam9pbmVyKSB7XG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHN0ciArPSBhcnJbaV07XG4gICAgICAgIGlmIChpICsgMSA8IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN0ciArPSBqb2luZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZCh0aGF0KSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicgfHwgdG9TdHIuYXBwbHkodGFyZ2V0KSAhPT0gZnVuY1R5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJPUl9NRVNTQUdFICsgdGFyZ2V0KTtcbiAgICB9XG4gICAgdmFyIGFyZ3MgPSBzbGljeShhcmd1bWVudHMsIDEpO1xuXG4gICAgdmFyIGJvdW5kO1xuICAgIHZhciBiaW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYm91bmQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBjb25jYXR0eShhcmdzLCBhcmd1bWVudHMpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShcbiAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICBjb25jYXR0eShhcmdzLCBhcmd1bWVudHMpXG4gICAgICAgICk7XG5cbiAgICB9O1xuXG4gICAgdmFyIGJvdW5kTGVuZ3RoID0gbWF4KDAsIHRhcmdldC5sZW5ndGggLSBhcmdzLmxlbmd0aCk7XG4gICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRMZW5ndGg7IGkrKykge1xuICAgICAgICBib3VuZEFyZ3NbaV0gPSAnJCcgKyBpO1xuICAgIH1cblxuICAgIGJvdW5kID0gRnVuY3Rpb24oJ2JpbmRlcicsICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBqb2lueShib3VuZEFyZ3MsICcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7IH0nKShiaW5kZXIpO1xuXG4gICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgdmFyIEVtcHR5ID0gZnVuY3Rpb24gRW1wdHkoKSB7fTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgYm91bmQucHJvdG90eXBlID0gbmV3IEVtcHR5KCk7XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvdW5kO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHx8IGltcGxlbWVudGF0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdW5kZWZpbmVkO1xuXG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJ2VzLW9iamVjdC1hdG9tcycpO1xuXG52YXIgJEVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzJyk7XG52YXIgJEV2YWxFcnJvciA9IHJlcXVpcmUoJ2VzLWVycm9ycy9ldmFsJyk7XG52YXIgJFJhbmdlRXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMvcmFuZ2UnKTtcbnZhciAkUmVmZXJlbmNlRXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMvcmVmJyk7XG52YXIgJFN5bnRheEVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzL3N5bnRheCcpO1xudmFyICRUeXBlRXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMvdHlwZScpO1xudmFyICRVUklFcnJvciA9IHJlcXVpcmUoJ2VzLWVycm9ycy91cmknKTtcblxudmFyIGFicyA9IHJlcXVpcmUoJ21hdGgtaW50cmluc2ljcy9hYnMnKTtcbnZhciBmbG9vciA9IHJlcXVpcmUoJ21hdGgtaW50cmluc2ljcy9mbG9vcicpO1xudmFyIG1heCA9IHJlcXVpcmUoJ21hdGgtaW50cmluc2ljcy9tYXgnKTtcbnZhciBtaW4gPSByZXF1aXJlKCdtYXRoLWludHJpbnNpY3MvbWluJyk7XG52YXIgcG93ID0gcmVxdWlyZSgnbWF0aC1pbnRyaW5zaWNzL3BvdycpO1xudmFyIHJvdW5kID0gcmVxdWlyZSgnbWF0aC1pbnRyaW5zaWNzL3JvdW5kJyk7XG52YXIgc2lnbiA9IHJlcXVpcmUoJ21hdGgtaW50cmluc2ljcy9zaWduJyk7XG5cbnZhciAkRnVuY3Rpb24gPSBGdW5jdGlvbjtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG52YXIgZ2V0RXZhbGxlZENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKGV4cHJlc3Npb25TeW50YXgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gJEZ1bmN0aW9uKCdcInVzZSBzdHJpY3RcIjsgcmV0dXJuICgnICsgZXhwcmVzc2lvblN5bnRheCArICcpLmNvbnN0cnVjdG9yOycpKCk7XG5cdH0gY2F0Y2ggKGUpIHt9XG59O1xuXG52YXIgJGdPUEQgPSByZXF1aXJlKCdnb3BkJyk7XG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnZXMtZGVmaW5lLXByb3BlcnR5Jyk7XG5cbnZhciB0aHJvd1R5cGVFcnJvciA9IGZ1bmN0aW9uICgpIHtcblx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoKTtcbn07XG52YXIgVGhyb3dUeXBlRXJyb3IgPSAkZ09QRFxuXHQ/IChmdW5jdGlvbiAoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnMsIG5vLWNhbGxlciwgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG5cdFx0XHRhcmd1bWVudHMuY2FsbGVlOyAvLyBJRSA4IGRvZXMgbm90IHRocm93IGhlcmVcblx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHR9IGNhdGNoIChjYWxsZWVUaHJvd3MpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIElFIDggdGhyb3dzIG9uIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYXJndW1lbnRzLCAnJylcblx0XHRcdFx0cmV0dXJuICRnT1BEKGFyZ3VtZW50cywgJ2NhbGxlZScpLmdldDtcblx0XHRcdH0gY2F0Y2ggKGdPUER0aHJvd3MpIHtcblx0XHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fSgpKVxuXHQ6IHRocm93VHlwZUVycm9yO1xuXG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzJykoKTtcblxudmFyIGdldFByb3RvID0gcmVxdWlyZSgnZ2V0LXByb3RvJyk7XG52YXIgJE9iamVjdEdQTyA9IHJlcXVpcmUoJ2dldC1wcm90by9PYmplY3QuZ2V0UHJvdG90eXBlT2YnKTtcbnZhciAkUmVmbGVjdEdQTyA9IHJlcXVpcmUoJ2dldC1wcm90by9SZWZsZWN0LmdldFByb3RvdHlwZU9mJyk7XG5cbnZhciAkYXBwbHkgPSByZXF1aXJlKCdjYWxsLWJpbmQtYXBwbHktaGVscGVycy9mdW5jdGlvbkFwcGx5Jyk7XG52YXIgJGNhbGwgPSByZXF1aXJlKCdjYWxsLWJpbmQtYXBwbHktaGVscGVycy9mdW5jdGlvbkNhbGwnKTtcblxudmFyIG5lZWRzRXZhbCA9IHt9O1xuXG52YXIgVHlwZWRBcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyB8fCAhZ2V0UHJvdG8gPyB1bmRlZmluZWQgOiBnZXRQcm90byhVaW50OEFycmF5KTtcblxudmFyIElOVFJJTlNJQ1MgPSB7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0JyVBZ2dyZWdhdGVFcnJvciUnOiB0eXBlb2YgQWdncmVnYXRlRXJyb3IgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQWdncmVnYXRlRXJyb3IsXG5cdCclQXJyYXklJzogQXJyYXksXG5cdCclQXJyYXlCdWZmZXIlJzogdHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFycmF5QnVmZmVyLFxuXHQnJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyAmJiBnZXRQcm90byA/IGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGcm9tU3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IHVuZGVmaW5lZCxcblx0JyVBc3luY0Z1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiBuZWVkc0V2YWwsXG5cdCclQXRvbWljcyUnOiB0eXBlb2YgQXRvbWljcyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBdG9taWNzLFxuXHQnJUJpZ0ludCUnOiB0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ0ludCxcblx0JyVCaWdJbnQ2NEFycmF5JSc6IHR5cGVvZiBCaWdJbnQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ0ludDY0QXJyYXksXG5cdCclQmlnVWludDY0QXJyYXklJzogdHlwZW9mIEJpZ1VpbnQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ1VpbnQ2NEFycmF5LFxuXHQnJUJvb2xlYW4lJzogQm9vbGVhbixcblx0JyVEYXRhVmlldyUnOiB0eXBlb2YgRGF0YVZpZXcgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRGF0YVZpZXcsXG5cdCclRGF0ZSUnOiBEYXRlLFxuXHQnJWRlY29kZVVSSSUnOiBkZWNvZGVVUkksXG5cdCclZGVjb2RlVVJJQ29tcG9uZW50JSc6IGRlY29kZVVSSUNvbXBvbmVudCxcblx0JyVlbmNvZGVVUkklJzogZW5jb2RlVVJJLFxuXHQnJWVuY29kZVVSSUNvbXBvbmVudCUnOiBlbmNvZGVVUklDb21wb25lbnQsXG5cdCclRXJyb3IlJzogJEVycm9yLFxuXHQnJWV2YWwlJzogZXZhbCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXG5cdCclRXZhbEVycm9yJSc6ICRFdmFsRXJyb3IsXG5cdCclRmxvYXQxNkFycmF5JSc6IHR5cGVvZiBGbG9hdDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQxNkFycmF5LFxuXHQnJUZsb2F0MzJBcnJheSUnOiB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0MzJBcnJheSxcblx0JyVGbG9hdDY0QXJyYXklJzogdHlwZW9mIEZsb2F0NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDY0QXJyYXksXG5cdCclRmluYWxpemF0aW9uUmVnaXN0cnklJzogdHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZpbmFsaXphdGlvblJlZ2lzdHJ5LFxuXHQnJUZ1bmN0aW9uJSc6ICRGdW5jdGlvbixcblx0JyVHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclSW50OEFycmF5JSc6IHR5cGVvZiBJbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50OEFycmF5LFxuXHQnJUludDE2QXJyYXklJzogdHlwZW9mIEludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MTZBcnJheSxcblx0JyVJbnQzMkFycmF5JSc6IHR5cGVvZiBJbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDMyQXJyYXksXG5cdCclaXNGaW5pdGUlJzogaXNGaW5pdGUsXG5cdCclaXNOYU4lJzogaXNOYU4sXG5cdCclSXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyAmJiBnZXRQcm90byA/IGdldFByb3RvKGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkpIDogdW5kZWZpbmVkLFxuXHQnJUpTT04lJzogdHlwZW9mIEpTT04gPT09ICdvYmplY3QnID8gSlNPTiA6IHVuZGVmaW5lZCxcblx0JyVNYXAlJzogdHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBNYXAsXG5cdCclTWFwSXRlcmF0b3JQcm90b3R5cGUlJzogdHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc1N5bWJvbHMgfHwgIWdldFByb3RvID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8obmV3IE1hcCgpW1N5bWJvbC5pdGVyYXRvcl0oKSksXG5cdCclTWF0aCUnOiBNYXRoLFxuXHQnJU51bWJlciUnOiBOdW1iZXIsXG5cdCclT2JqZWN0JSc6ICRPYmplY3QsXG5cdCclT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciUnOiAkZ09QRCxcblx0JyVwYXJzZUZsb2F0JSc6IHBhcnNlRmxvYXQsXG5cdCclcGFyc2VJbnQlJzogcGFyc2VJbnQsXG5cdCclUHJvbWlzZSUnOiB0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm9taXNlLFxuXHQnJVByb3h5JSc6IHR5cGVvZiBQcm94eSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm94eSxcblx0JyVSYW5nZUVycm9yJSc6ICRSYW5nZUVycm9yLFxuXHQnJVJlZmVyZW5jZUVycm9yJSc6ICRSZWZlcmVuY2VFcnJvcixcblx0JyVSZWZsZWN0JSc6IHR5cGVvZiBSZWZsZWN0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFJlZmxlY3QsXG5cdCclUmVnRXhwJSc6IFJlZ0V4cCxcblx0JyVTZXQlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTZXQsXG5cdCclU2V0SXRlcmF0b3JQcm90b3R5cGUlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc1N5bWJvbHMgfHwgIWdldFByb3RvID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8obmV3IFNldCgpW1N5bWJvbC5pdGVyYXRvcl0oKSksXG5cdCclU2hhcmVkQXJyYXlCdWZmZXIlJzogdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNoYXJlZEFycmF5QnVmZmVyLFxuXHQnJVN0cmluZyUnOiBTdHJpbmcsXG5cdCclU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyAmJiBnZXRQcm90byA/IGdldFByb3RvKCcnW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCclU3ltYm9sJSc6IGhhc1N5bWJvbHMgPyBTeW1ib2wgOiB1bmRlZmluZWQsXG5cdCclU3ludGF4RXJyb3IlJzogJFN5bnRheEVycm9yLFxuXHQnJVRocm93VHlwZUVycm9yJSc6IFRocm93VHlwZUVycm9yLFxuXHQnJVR5cGVkQXJyYXklJzogVHlwZWRBcnJheSxcblx0JyVUeXBlRXJyb3IlJzogJFR5cGVFcnJvcixcblx0JyVVaW50OEFycmF5JSc6IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4QXJyYXksXG5cdCclVWludDhDbGFtcGVkQXJyYXklJzogdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4Q2xhbXBlZEFycmF5LFxuXHQnJVVpbnQxNkFycmF5JSc6IHR5cGVvZiBVaW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MTZBcnJheSxcblx0JyVVaW50MzJBcnJheSUnOiB0eXBlb2YgVWludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDMyQXJyYXksXG5cdCclVVJJRXJyb3IlJzogJFVSSUVycm9yLFxuXHQnJVdlYWtNYXAlJzogdHlwZW9mIFdlYWtNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha01hcCxcblx0JyVXZWFrUmVmJSc6IHR5cGVvZiBXZWFrUmVmID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtSZWYsXG5cdCclV2Vha1NldCUnOiB0eXBlb2YgV2Vha1NldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrU2V0LFxuXG5cdCclRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwlJzogJGNhbGwsXG5cdCclRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5JSc6ICRhcHBseSxcblx0JyVPYmplY3QuZGVmaW5lUHJvcGVydHklJzogJGRlZmluZVByb3BlcnR5LFxuXHQnJU9iamVjdC5nZXRQcm90b3R5cGVPZiUnOiAkT2JqZWN0R1BPLFxuXHQnJU1hdGguYWJzJSc6IGFicyxcblx0JyVNYXRoLmZsb29yJSc6IGZsb29yLFxuXHQnJU1hdGgubWF4JSc6IG1heCxcblx0JyVNYXRoLm1pbiUnOiBtaW4sXG5cdCclTWF0aC5wb3clJzogcG93LFxuXHQnJU1hdGgucm91bmQlJzogcm91bmQsXG5cdCclTWF0aC5zaWduJSc6IHNpZ24sXG5cdCclUmVmbGVjdC5nZXRQcm90b3R5cGVPZiUnOiAkUmVmbGVjdEdQT1xufTtcblxuaWYgKGdldFByb3RvKSB7XG5cdHRyeSB7XG5cdFx0bnVsbC5lcnJvcjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXNoYWRvd3JlYWxtL3B1bGwvMzg0I2lzc3VlY29tbWVudC0xMzY0MjY0MjI5XG5cdFx0dmFyIGVycm9yUHJvdG8gPSBnZXRQcm90byhnZXRQcm90byhlKSk7XG5cdFx0SU5UUklOU0lDU1snJUVycm9yLnByb3RvdHlwZSUnXSA9IGVycm9yUHJvdG87XG5cdH1cbn1cblxudmFyIGRvRXZhbCA9IGZ1bmN0aW9uIGRvRXZhbChuYW1lKSB7XG5cdHZhciB2YWx1ZTtcblx0aWYgKG5hbWUgPT09ICclQXN5bmNGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2Z1bmN0aW9uKiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uKiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3IlJykge1xuXHRcdHZhciBmbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJyk7XG5cdFx0aWYgKGZuKSB7XG5cdFx0XHR2YWx1ZSA9IGZuLnByb3RvdHlwZTtcblx0XHR9XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJScpIHtcblx0XHR2YXIgZ2VuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3IlJyk7XG5cdFx0aWYgKGdlbiAmJiBnZXRQcm90bykge1xuXHRcdFx0dmFsdWUgPSBnZXRQcm90byhnZW4ucHJvdG90eXBlKTtcblx0XHR9XG5cdH1cblxuXHRJTlRSSU5TSUNTW25hbWVdID0gdmFsdWU7XG5cblx0cmV0dXJuIHZhbHVlO1xufTtcblxudmFyIExFR0FDWV9BTElBU0VTID0ge1xuXHRfX3Byb3RvX186IG51bGwsXG5cdCclQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvdHlwZSUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUFycmF5UHJvdG9fZW50cmllcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdlbnRyaWVzJ10sXG5cdCclQXJyYXlQcm90b19mb3JFYWNoJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2ZvckVhY2gnXSxcblx0JyVBcnJheVByb3RvX2tleXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAna2V5cyddLFxuXHQnJUFycmF5UHJvdG9fdmFsdWVzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ3ZhbHVlcyddLFxuXHQnJUFzeW5jRnVuY3Rpb25Qcm90b3R5cGUlJzogWydBc3luY0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFzeW5jR2VuZXJhdG9yJSc6IFsnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUJvb2xlYW5Qcm90b3R5cGUlJzogWydCb29sZWFuJywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGFWaWV3UHJvdG90eXBlJSc6IFsnRGF0YVZpZXcnLCAncHJvdG90eXBlJ10sXG5cdCclRGF0ZVByb3RvdHlwZSUnOiBbJ0RhdGUnLCAncHJvdG90eXBlJ10sXG5cdCclRXJyb3JQcm90b3R5cGUlJzogWydFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVFdmFsRXJyb3JQcm90b3R5cGUlJzogWydFdmFsRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRmxvYXQzMkFycmF5UHJvdG90eXBlJSc6IFsnRmxvYXQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0NjRBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0NjRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGdW5jdGlvblByb3RvdHlwZSUnOiBbJ0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUdlbmVyYXRvciUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUdlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQ4QXJyYXlQcm90b3R5cGUlJzogWydJbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ0ludDE2QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ0ludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSlNPTlBhcnNlJSc6IFsnSlNPTicsICdwYXJzZSddLFxuXHQnJUpTT05TdHJpbmdpZnklJzogWydKU09OJywgJ3N0cmluZ2lmeSddLFxuXHQnJU1hcFByb3RvdHlwZSUnOiBbJ01hcCcsICdwcm90b3R5cGUnXSxcblx0JyVOdW1iZXJQcm90b3R5cGUlJzogWydOdW1iZXInLCAncHJvdG90eXBlJ10sXG5cdCclT2JqZWN0UHJvdG90eXBlJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZSddLFxuXHQnJU9ialByb3RvX3RvU3RyaW5nJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd0b1N0cmluZyddLFxuXHQnJU9ialByb3RvX3ZhbHVlT2YlJzogWydPYmplY3QnLCAncHJvdG90eXBlJywgJ3ZhbHVlT2YnXSxcblx0JyVQcm9taXNlUHJvdG90eXBlJSc6IFsnUHJvbWlzZScsICdwcm90b3R5cGUnXSxcblx0JyVQcm9taXNlUHJvdG9fdGhlbiUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJywgJ3RoZW4nXSxcblx0JyVQcm9taXNlX2FsbCUnOiBbJ1Byb21pc2UnLCAnYWxsJ10sXG5cdCclUHJvbWlzZV9yZWplY3QlJzogWydQcm9taXNlJywgJ3JlamVjdCddLFxuXHQnJVByb21pc2VfcmVzb2x2ZSUnOiBbJ1Byb21pc2UnLCAncmVzb2x2ZSddLFxuXHQnJVJhbmdlRXJyb3JQcm90b3R5cGUlJzogWydSYW5nZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZmVyZW5jZUVycm9yUHJvdG90eXBlJSc6IFsnUmVmZXJlbmNlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclUmVnRXhwUHJvdG90eXBlJSc6IFsnUmVnRXhwJywgJ3Byb3RvdHlwZSddLFxuXHQnJVNldFByb3RvdHlwZSUnOiBbJ1NldCcsICdwcm90b3R5cGUnXSxcblx0JyVTaGFyZWRBcnJheUJ1ZmZlclByb3RvdHlwZSUnOiBbJ1NoYXJlZEFycmF5QnVmZmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN0cmluZ1Byb3RvdHlwZSUnOiBbJ1N0cmluZycsICdwcm90b3R5cGUnXSxcblx0JyVTeW1ib2xQcm90b3R5cGUlJzogWydTeW1ib2wnLCAncHJvdG90eXBlJ10sXG5cdCclU3ludGF4RXJyb3JQcm90b3R5cGUlJzogWydTeW50YXhFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVUeXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVHlwZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVUeXBlRXJyb3JQcm90b3R5cGUlJzogWydUeXBlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVWludDhBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUlJzogWydVaW50OENsYW1wZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQzMkFycmF5UHJvdG90eXBlJSc6IFsnVWludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVVJJRXJyb3JQcm90b3R5cGUlJzogWydVUklFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVXZWFrTWFwUHJvdG90eXBlJSc6IFsnV2Vha01hcCcsICdwcm90b3R5cGUnXSxcblx0JyVXZWFrU2V0UHJvdG90eXBlJSc6IFsnV2Vha1NldCcsICdwcm90b3R5cGUnXVxufTtcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnaGFzb3duJyk7XG52YXIgJGNvbmNhdCA9IGJpbmQuY2FsbCgkY2FsbCwgQXJyYXkucHJvdG90eXBlLmNvbmNhdCk7XG52YXIgJHNwbGljZUFwcGx5ID0gYmluZC5jYWxsKCRhcHBseSwgQXJyYXkucHJvdG90eXBlLnNwbGljZSk7XG52YXIgJHJlcGxhY2UgPSBiaW5kLmNhbGwoJGNhbGwsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG52YXIgJHN0clNsaWNlID0gYmluZC5jYWxsKCRjYWxsLCBTdHJpbmcucHJvdG90eXBlLnNsaWNlKTtcbnZhciAkZXhlYyA9IGJpbmQuY2FsbCgkY2FsbCwgUmVnRXhwLnByb3RvdHlwZS5leGVjKTtcblxuLyogYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvNC4xNy4xNS9kaXN0L2xvZGFzaC5qcyNMNjczNS1MNjc0NCAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14lLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCUkKSkvZztcbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZzsgLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgc3RyaW5nVG9QYXRoID0gZnVuY3Rpb24gc3RyaW5nVG9QYXRoKHN0cmluZykge1xuXHR2YXIgZmlyc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAwLCAxKTtcblx0dmFyIGxhc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAtMSk7XG5cdGlmIChmaXJzdCA9PT0gJyUnICYmIGxhc3QgIT09ICclJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgY2xvc2luZyBgJWAnKTtcblx0fSBlbHNlIGlmIChsYXN0ID09PSAnJScgJiYgZmlyc3QgIT09ICclJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgb3BlbmluZyBgJWAnKTtcblx0fVxuXHR2YXIgcmVzdWx0ID0gW107XG5cdCRyZXBsYWNlKHN0cmluZywgcmVQcm9wTmFtZSwgZnVuY3Rpb24gKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcblx0XHRyZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBxdW90ZSA/ICRyZXBsYWNlKHN1YlN0cmluZywgcmVFc2NhcGVDaGFyLCAnJDEnKSA6IG51bWJlciB8fCBtYXRjaDtcblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuLyogZW5kIGFkYXB0YXRpb24gKi9cblxudmFyIGdldEJhc2VJbnRyaW5zaWMgPSBmdW5jdGlvbiBnZXRCYXNlSW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHR2YXIgaW50cmluc2ljTmFtZSA9IG5hbWU7XG5cdHZhciBhbGlhcztcblx0aWYgKGhhc093bihMRUdBQ1lfQUxJQVNFUywgaW50cmluc2ljTmFtZSkpIHtcblx0XHRhbGlhcyA9IExFR0FDWV9BTElBU0VTW2ludHJpbnNpY05hbWVdO1xuXHRcdGludHJpbnNpY05hbWUgPSAnJScgKyBhbGlhc1swXSArICclJztcblx0fVxuXG5cdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljTmFtZSkpIHtcblx0XHR2YXIgdmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY05hbWVdO1xuXHRcdGlmICh2YWx1ZSA9PT0gbmVlZHNFdmFsKSB7XG5cdFx0XHR2YWx1ZSA9IGRvRXZhbChpbnRyaW5zaWNOYW1lKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgJiYgIWFsbG93TWlzc2luZykge1xuXHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIGZpbGUgYW4gaXNzdWUhJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFsaWFzOiBhbGlhcyxcblx0XHRcdG5hbWU6IGludHJpbnNpY05hbWUsXG5cdFx0XHR2YWx1ZTogdmFsdWVcblx0XHR9O1xuXHR9XG5cblx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBkb2VzIG5vdCBleGlzdCEnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gR2V0SW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHRpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8IG5hbWUubGVuZ3RoID09PSAwKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBhbGxvd01pc3NpbmcgIT09ICdib29sZWFuJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdcImFsbG93TWlzc2luZ1wiIGFyZ3VtZW50IG11c3QgYmUgYSBib29sZWFuJyk7XG5cdH1cblxuXHRpZiAoJGV4ZWMoL14lP1teJV0qJT8kLywgbmFtZSkgPT09IG51bGwpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdgJWAgbWF5IG5vdCBiZSBwcmVzZW50IGFueXdoZXJlIGJ1dCBhdCB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgdGhlIGludHJpbnNpYyBuYW1lJyk7XG5cdH1cblx0dmFyIHBhcnRzID0gc3RyaW5nVG9QYXRoKG5hbWUpO1xuXHR2YXIgaW50cmluc2ljQmFzZU5hbWUgPSBwYXJ0cy5sZW5ndGggPiAwID8gcGFydHNbMF0gOiAnJztcblxuXHR2YXIgaW50cmluc2ljID0gZ2V0QmFzZUludHJpbnNpYygnJScgKyBpbnRyaW5zaWNCYXNlTmFtZSArICclJywgYWxsb3dNaXNzaW5nKTtcblx0dmFyIGludHJpbnNpY1JlYWxOYW1lID0gaW50cmluc2ljLm5hbWU7XG5cdHZhciB2YWx1ZSA9IGludHJpbnNpYy52YWx1ZTtcblx0dmFyIHNraXBGdXJ0aGVyQ2FjaGluZyA9IGZhbHNlO1xuXG5cdHZhciBhbGlhcyA9IGludHJpbnNpYy5hbGlhcztcblx0aWYgKGFsaWFzKSB7XG5cdFx0aW50cmluc2ljQmFzZU5hbWUgPSBhbGlhc1swXTtcblx0XHQkc3BsaWNlQXBwbHkocGFydHMsICRjb25jYXQoWzAsIDFdLCBhbGlhcykpO1xuXHR9XG5cblx0Zm9yICh2YXIgaSA9IDEsIGlzT3duID0gdHJ1ZTsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0dmFyIHBhcnQgPSBwYXJ0c1tpXTtcblx0XHR2YXIgZmlyc3QgPSAkc3RyU2xpY2UocGFydCwgMCwgMSk7XG5cdFx0dmFyIGxhc3QgPSAkc3RyU2xpY2UocGFydCwgLTEpO1xuXHRcdGlmIChcblx0XHRcdChcblx0XHRcdFx0KGZpcnN0ID09PSAnXCInIHx8IGZpcnN0ID09PSBcIidcIiB8fCBmaXJzdCA9PT0gJ2AnKVxuXHRcdFx0XHR8fCAobGFzdCA9PT0gJ1wiJyB8fCBsYXN0ID09PSBcIidcIiB8fCBsYXN0ID09PSAnYCcpXG5cdFx0XHQpXG5cdFx0XHQmJiBmaXJzdCAhPT0gbGFzdFxuXHRcdCkge1xuXHRcdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcigncHJvcGVydHkgbmFtZXMgd2l0aCBxdW90ZXMgbXVzdCBoYXZlIG1hdGNoaW5nIHF1b3RlcycpO1xuXHRcdH1cblx0XHRpZiAocGFydCA9PT0gJ2NvbnN0cnVjdG9yJyB8fCAhaXNPd24pIHtcblx0XHRcdHNraXBGdXJ0aGVyQ2FjaGluZyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aW50cmluc2ljQmFzZU5hbWUgKz0gJy4nICsgcGFydDtcblx0XHRpbnRyaW5zaWNSZWFsTmFtZSA9ICclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnO1xuXG5cdFx0aWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNSZWFsTmFtZSkpIHtcblx0XHRcdHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV07XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRpZiAoIShwYXJ0IGluIHZhbHVlKSkge1xuXHRcdFx0XHRpZiAoIWFsbG93TWlzc2luZykge1xuXHRcdFx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdiYXNlIGludHJpbnNpYyBmb3IgJyArIG5hbWUgKyAnIGV4aXN0cywgYnV0IHRoZSBwcm9wZXJ0eSBpcyBub3QgYXZhaWxhYmxlLicpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2b2lkIHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdGlmICgkZ09QRCAmJiAoaSArIDEpID49IHBhcnRzLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgZGVzYyA9ICRnT1BEKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0aXNPd24gPSAhIWRlc2M7XG5cblx0XHRcdFx0Ly8gQnkgY29udmVudGlvbiwgd2hlbiBhIGRhdGEgcHJvcGVydHkgaXMgY29udmVydGVkIHRvIGFuIGFjY2Vzc29yXG5cdFx0XHRcdC8vIHByb3BlcnR5IHRvIGVtdWxhdGUgYSBkYXRhIHByb3BlcnR5IHRoYXQgZG9lcyBub3Qgc3VmZmVyIGZyb21cblx0XHRcdFx0Ly8gdGhlIG92ZXJyaWRlIG1pc3Rha2UsIHRoYXQgYWNjZXNzb3IncyBnZXR0ZXIgaXMgbWFya2VkIHdpdGhcblx0XHRcdFx0Ly8gYW4gYG9yaWdpbmFsVmFsdWVgIHByb3BlcnR5LiBIZXJlLCB3aGVuIHdlIGRldGVjdCB0aGlzLCB3ZVxuXHRcdFx0XHQvLyB1cGhvbGQgdGhlIGlsbHVzaW9uIGJ5IHByZXRlbmRpbmcgdG8gc2VlIHRoYXQgb3JpZ2luYWwgZGF0YVxuXHRcdFx0XHQvLyBwcm9wZXJ0eSwgaS5lLiwgcmV0dXJuaW5nIHRoZSB2YWx1ZSByYXRoZXIgdGhhbiB0aGUgZ2V0dGVyXG5cdFx0XHRcdC8vIGl0c2VsZi5cblx0XHRcdFx0aWYgKGlzT3duICYmICdnZXQnIGluIGRlc2MgJiYgISgnb3JpZ2luYWxWYWx1ZScgaW4gZGVzYy5nZXQpKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBkZXNjLmdldDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpc093biA9IGhhc093bih2YWx1ZSwgcGFydCk7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpc093biAmJiAhc2tpcEZ1cnRoZXJDYWNoaW5nKSB7XG5cdFx0XHRcdElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiB2YWx1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnZXMtb2JqZWN0LWF0b21zJyk7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL09iamVjdC5nZXRQcm90b3R5cGVPZicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSAkT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IG51bGw7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL1JlZmxlY3QuZ2V0UHJvdG90eXBlT2YnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gKHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKSB8fCBudWxsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVmbGVjdEdldFByb3RvID0gcmVxdWlyZSgnLi9SZWZsZWN0LmdldFByb3RvdHlwZU9mJyk7XG52YXIgb3JpZ2luYWxHZXRQcm90byA9IHJlcXVpcmUoJy4vT2JqZWN0LmdldFByb3RvdHlwZU9mJyk7XG5cbnZhciBnZXREdW5kZXJQcm90byA9IHJlcXVpcmUoJ2R1bmRlci1wcm90by9nZXQnKTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gcmVmbGVjdEdldFByb3RvXG5cdD8gZnVuY3Rpb24gZ2V0UHJvdG8oTykge1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgVFMgY2FuJ3QgbmFycm93IGluc2lkZSBhIGNsb3N1cmUsIGZvciBzb21lIHJlYXNvblxuXHRcdHJldHVybiByZWZsZWN0R2V0UHJvdG8oTyk7XG5cdH1cblx0OiBvcmlnaW5hbEdldFByb3RvXG5cdFx0PyBmdW5jdGlvbiBnZXRQcm90byhPKSB7XG5cdFx0XHRpZiAoIU8gfHwgKHR5cGVvZiBPICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgTyAhPT0gJ2Z1bmN0aW9uJykpIHtcblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignZ2V0UHJvdG86IG5vdCBhbiBvYmplY3QnKTtcblx0XHRcdH1cblx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgVFMgY2FuJ3QgbmFycm93IGluc2lkZSBhIGNsb3N1cmUsIGZvciBzb21lIHJlYXNvblxuXHRcdFx0cmV0dXJuIG9yaWdpbmFsR2V0UHJvdG8oTyk7XG5cdFx0fVxuXHRcdDogZ2V0RHVuZGVyUHJvdG9cblx0XHRcdD8gZnVuY3Rpb24gZ2V0UHJvdG8oTykge1xuXHRcdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIFRTIGNhbid0IG5hcnJvdyBpbnNpZGUgYSBjbG9zdXJlLCBmb3Igc29tZSByZWFzb25cblx0XHRcdFx0cmV0dXJuIGdldER1bmRlclByb3RvKE8pO1xuXHRcdFx0fVxuXHRcdFx0OiBudWxsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9nT1BEJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG52YXIgJGdPUEQgPSByZXF1aXJlKCcuL2dPUEQnKTtcblxuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoW10sICdsZW5ndGgnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGdPUERcblx0XHQkZ09QRCA9IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAkZ09QRDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJ2VzLWRlZmluZS1wcm9wZXJ0eScpO1xuXG52YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9ycyA9IGZ1bmN0aW9uIGhhc1Byb3BlcnR5RGVzY3JpcHRvcnMoKSB7XG5cdHJldHVybiAhISRkZWZpbmVQcm9wZXJ0eTtcbn07XG5cbmhhc1Byb3BlcnR5RGVzY3JpcHRvcnMuaGFzQXJyYXlMZW5ndGhEZWZpbmVCdWcgPSBmdW5jdGlvbiBoYXNBcnJheUxlbmd0aERlZmluZUJ1ZygpIHtcblx0Ly8gbm9kZSB2MC42IGhhcyBhIGJ1ZyB3aGVyZSBhcnJheSBsZW5ndGhzIGNhbiBiZSBTZXQgYnV0IG5vdCBEZWZpbmVkXG5cdGlmICghJGRlZmluZVByb3BlcnR5KSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0dHJ5IHtcblx0XHRyZXR1cm4gJGRlZmluZVByb3BlcnR5KFtdLCAnbGVuZ3RoJywgeyB2YWx1ZTogMSB9KS5sZW5ndGggIT09IDE7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJbiBGaXJlZm94IDQtMjIsIGRlZmluaW5nIGxlbmd0aCBvbiBhbiBhcnJheSB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvcnM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBvcmlnU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sO1xudmFyIGhhc1N5bWJvbFNoYW0gPSByZXF1aXJlKCcuL3NoYW1zJyk7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc05hdGl2ZVN5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCgnZm9vJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbCgnYmFyJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHJldHVybiBoYXNTeW1ib2xTaGFtKCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9zaGFtcycpfSAqL1xuLyogZXNsaW50IGNvbXBsZXhpdHk6IFsyLCAxOF0sIG1heC1zdGF0ZW1lbnRzOiBbMiwgMzNdICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1N5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHsgcmV0dXJuIHRydWU7IH1cblxuXHQvKiogQHR5cGUge3sgW2sgaW4gc3ltYm9sXT86IHVua25vd24gfX0gKi9cblx0dmFyIG9iaiA9IHt9O1xuXHR2YXIgc3ltID0gU3ltYm9sKCd0ZXN0Jyk7XG5cdHZhciBzeW1PYmogPSBPYmplY3Qoc3ltKTtcblx0aWYgKHR5cGVvZiBzeW0gPT09ICdzdHJpbmcnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltT2JqKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9vYmplY3QuYXNzaWduL2lzc3Vlcy8xN1xuXHQvLyBpZiAoc3ltIGluc3RhbmNlb2YgU3ltYm9sKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMvaXNzdWVzLzRcblx0Ly8gaWYgKCEoc3ltT2JqIGluc3RhbmNlb2YgU3ltYm9sKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyBpZiAodHlwZW9mIFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIGlmIChTdHJpbmcoc3ltKSAhPT0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0dmFyIHN5bVZhbCA9IDQyO1xuXHRvYmpbc3ltXSA9IHN5bVZhbDtcblx0Zm9yICh2YXIgXyBpbiBvYmopIHsgcmV0dXJuIGZhbHNlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLXVucmVhY2hhYmxlLWxvb3Bcblx0aWYgKHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1zID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopO1xuXHRpZiAoc3ltcy5sZW5ndGggIT09IDEgfHwgc3ltc1swXSAhPT0gc3ltKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwgc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPT09ICdmdW5jdGlvbicpIHtcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0cmEtcGFyZW5zXG5cdFx0dmFyIGRlc2NyaXB0b3IgPSAvKiogQHR5cGUge1Byb3BlcnR5RGVzY3JpcHRvcn0gKi8gKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBzeW0pKTtcblx0XHRpZiAoZGVzY3JpcHRvci52YWx1ZSAhPT0gc3ltVmFsIHx8IGRlc2NyaXB0b3IuZW51bWVyYWJsZSAhPT0gdHJ1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc1N5bWJvbHMgPSByZXF1aXJlKCdoYXMtc3ltYm9scy9zaGFtcycpO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNUb1N0cmluZ1RhZ1NoYW1zKCkge1xuXHRyZXR1cm4gaGFzU3ltYm9scygpICYmICEhU3ltYm9sLnRvU3RyaW5nVGFnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNhbGwgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcbnZhciAkaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBiaW5kLmNhbGwoY2FsbCwgJGhhc093bik7XG4iLCIvKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG9zdHJpbmd0YWcvc2hhbXMnKSgpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYm91bmQnKTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xudmFyIGlzU3RhbmRhcmRBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHRpZiAoXG5cdFx0aGFzVG9TdHJpbmdUYWdcblx0XHQmJiB2YWx1ZVxuXHRcdCYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCdcblx0XHQmJiBTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWVcblx0KSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHJldHVybiAkdG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn07XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG52YXIgaXNMZWdhY3lBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHRpZiAoaXNTdGFuZGFyZEFyZ3VtZW50cyh2YWx1ZSkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gdmFsdWUgIT09IG51bGxcblx0XHQmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnXG5cdFx0JiYgJ2xlbmd0aCcgaW4gdmFsdWVcblx0XHQmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJ1xuXHRcdCYmIHZhbHVlLmxlbmd0aCA+PSAwXG5cdFx0JiYgJHRvU3RyaW5nKHZhbHVlKSAhPT0gJ1tvYmplY3QgQXJyYXldJ1xuXHRcdCYmICdjYWxsZWUnIGluIHZhbHVlXG5cdFx0JiYgJHRvU3RyaW5nKHZhbHVlLmNhbGxlZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xuXG52YXIgc3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyA9IChmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBpc1N0YW5kYXJkQXJndW1lbnRzKGFyZ3VtZW50cyk7XG59KCkpO1xuXG4vLyBAdHMtZXhwZWN0LWVycm9yIFRPRE8gbWFrZSB0aGlzIG5vdCBlcnJvclxuaXNTdGFuZGFyZEFyZ3VtZW50cy5pc0xlZ2FjeUFyZ3VtZW50cyA9IGlzTGVnYWN5QXJndW1lbnRzOyAvLyBmb3IgdGVzdHNcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyA/IGlzU3RhbmRhcmRBcmd1bWVudHMgOiBpc0xlZ2FjeUFyZ3VtZW50cztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZuVG9TdHIgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgcmVmbGVjdEFwcGx5ID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QgIT09IG51bGwgJiYgUmVmbGVjdC5hcHBseTtcbnZhciBiYWRBcnJheUxpa2U7XG52YXIgaXNDYWxsYWJsZU1hcmtlcjtcbmlmICh0eXBlb2YgcmVmbGVjdEFwcGx5ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBPYmplY3QuZGVmaW5lUHJvcGVydHkgPT09ICdmdW5jdGlvbicpIHtcblx0dHJ5IHtcblx0XHRiYWRBcnJheUxpa2UgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdsZW5ndGgnLCB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhyb3cgaXNDYWxsYWJsZU1hcmtlcjtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRpc0NhbGxhYmxlTWFya2VyID0ge307XG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcblx0XHRyZWZsZWN0QXBwbHkoZnVuY3Rpb24gKCkgeyB0aHJvdyA0MjsgfSwgbnVsbCwgYmFkQXJyYXlMaWtlKTtcblx0fSBjYXRjaCAoXykge1xuXHRcdGlmIChfICE9PSBpc0NhbGxhYmxlTWFya2VyKSB7XG5cdFx0XHRyZWZsZWN0QXBwbHkgPSBudWxsO1xuXHRcdH1cblx0fVxufSBlbHNlIHtcblx0cmVmbGVjdEFwcGx5ID0gbnVsbDtcbn1cblxudmFyIGNvbnN0cnVjdG9yUmVnZXggPSAvXlxccypjbGFzc1xcYi87XG52YXIgaXNFUzZDbGFzc0ZuID0gZnVuY3Rpb24gaXNFUzZDbGFzc0Z1bmN0aW9uKHZhbHVlKSB7XG5cdHRyeSB7XG5cdFx0dmFyIGZuU3RyID0gZm5Ub1N0ci5jYWxsKHZhbHVlKTtcblx0XHRyZXR1cm4gY29uc3RydWN0b3JSZWdleC50ZXN0KGZuU3RyKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTsgLy8gbm90IGEgZnVuY3Rpb25cblx0fVxufTtcblxudmFyIHRyeUZ1bmN0aW9uT2JqZWN0ID0gZnVuY3Rpb24gdHJ5RnVuY3Rpb25Ub1N0cih2YWx1ZSkge1xuXHR0cnkge1xuXHRcdGlmIChpc0VTNkNsYXNzRm4odmFsdWUpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGZuVG9TdHIuY2FsbCh2YWx1ZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIG9iamVjdENsYXNzID0gJ1tvYmplY3QgT2JqZWN0XSc7XG52YXIgZm5DbGFzcyA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG52YXIgZ2VuQ2xhc3MgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xudmFyIGRkYUNsYXNzID0gJ1tvYmplY3QgSFRNTEFsbENvbGxlY3Rpb25dJzsgLy8gSUUgMTFcbnZhciBkZGFDbGFzczIgPSAnW29iamVjdCBIVE1MIGRvY3VtZW50LmFsbCBjbGFzc10nO1xudmFyIGRkYUNsYXNzMyA9ICdbb2JqZWN0IEhUTUxDb2xsZWN0aW9uXSc7IC8vIElFIDktMTBcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgISFTeW1ib2wudG9TdHJpbmdUYWc7IC8vIGJldHRlcjogdXNlIGBoYXMtdG9zdHJpbmd0YWdgXG5cbnZhciBpc0lFNjggPSAhKDAgaW4gWyxdKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zcGFyc2UtYXJyYXlzLCBjb21tYS1zcGFjaW5nXG5cbnZhciBpc0REQSA9IGZ1bmN0aW9uIGlzRG9jdW1lbnREb3RBbGwoKSB7IHJldHVybiBmYWxzZTsgfTtcbmlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICdvYmplY3QnKSB7XG5cdC8vIEZpcmVmb3ggMyBjYW5vbmljYWxpemVzIEREQSB0byB1bmRlZmluZWQgd2hlbiBpdCdzIG5vdCBhY2Nlc3NlZCBkaXJlY3RseVxuXHR2YXIgYWxsID0gZG9jdW1lbnQuYWxsO1xuXHRpZiAodG9TdHIuY2FsbChhbGwpID09PSB0b1N0ci5jYWxsKGRvY3VtZW50LmFsbCkpIHtcblx0XHRpc0REQSA9IGZ1bmN0aW9uIGlzRG9jdW1lbnREb3RBbGwodmFsdWUpIHtcblx0XHRcdC8qIGdsb2JhbHMgZG9jdW1lbnQ6IGZhbHNlICovXG5cdFx0XHQvLyBpbiBJRSA2LTgsIHR5cGVvZiBkb2N1bWVudC5hbGwgaXMgXCJvYmplY3RcIiBhbmQgaXQncyB0cnV0aHlcblx0XHRcdGlmICgoaXNJRTY4IHx8ICF2YWx1ZSkgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JykpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR2YXIgc3RyID0gdG9TdHIuY2FsbCh2YWx1ZSk7XG5cdFx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHRcdHN0ciA9PT0gZGRhQ2xhc3Ncblx0XHRcdFx0XHRcdHx8IHN0ciA9PT0gZGRhQ2xhc3MyXG5cdFx0XHRcdFx0XHR8fCBzdHIgPT09IGRkYUNsYXNzMyAvLyBvcGVyYSAxMi4xNlxuXHRcdFx0XHRcdFx0fHwgc3RyID09PSBvYmplY3RDbGFzcyAvLyBJRSA2LThcblx0XHRcdFx0XHQpICYmIHZhbHVlKCcnKSA9PSBudWxsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuXHRcdFx0XHR9IGNhdGNoIChlKSB7IC8qKi8gfVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWZsZWN0QXBwbHlcblx0PyBmdW5jdGlvbiBpc0NhbGxhYmxlKHZhbHVlKSB7XG5cdFx0aWYgKGlzRERBKHZhbHVlKSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdGlmICghdmFsdWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdHRyeSB7XG5cdFx0XHRyZWZsZWN0QXBwbHkodmFsdWUsIG51bGwsIGJhZEFycmF5TGlrZSk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0aWYgKGUgIT09IGlzQ2FsbGFibGVNYXJrZXIpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0fVxuXHRcdHJldHVybiAhaXNFUzZDbGFzc0ZuKHZhbHVlKSAmJiB0cnlGdW5jdGlvbk9iamVjdCh2YWx1ZSk7XG5cdH1cblx0OiBmdW5jdGlvbiBpc0NhbGxhYmxlKHZhbHVlKSB7XG5cdFx0aWYgKGlzRERBKHZhbHVlKSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdGlmICghdmFsdWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmIChoYXNUb1N0cmluZ1RhZykgeyByZXR1cm4gdHJ5RnVuY3Rpb25PYmplY3QodmFsdWUpOyB9XG5cdFx0aWYgKGlzRVM2Q2xhc3NGbih2YWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0dmFyIHN0ckNsYXNzID0gdG9TdHIuY2FsbCh2YWx1ZSk7XG5cdFx0aWYgKHN0ckNsYXNzICE9PSBmbkNsYXNzICYmIHN0ckNsYXNzICE9PSBnZW5DbGFzcyAmJiAhKC9eXFxbb2JqZWN0IEhUTUwvKS50ZXN0KHN0ckNsYXNzKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRyZXR1cm4gdHJ5RnVuY3Rpb25PYmplY3QodmFsdWUpO1xuXHR9O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1ib3VuZCcpO1xudmFyIHNhZmVSZWdleFRlc3QgPSByZXF1aXJlKCdzYWZlLXJlZ2V4LXRlc3QnKTtcbnZhciBpc0ZuUmVnZXggPSBzYWZlUmVnZXhUZXN0KC9eXFxzKig/OmZ1bmN0aW9uKT9cXCovKTtcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJ2hhcy10b3N0cmluZ3RhZy9zaGFtcycpKCk7XG52YXIgZ2V0UHJvdG8gPSByZXF1aXJlKCdnZXQtcHJvdG8nKTtcblxudmFyIHRvU3RyID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJyk7XG52YXIgZm5Ub1N0ciA9IGNhbGxCb3VuZCgnRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nJyk7XG5cbnZhciBnZXRHZW5lcmF0b3JGdW5jID0gZnVuY3Rpb24gKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0dHJ5IHtcblx0XHRyZXR1cm4gRnVuY3Rpb24oJ3JldHVybiBmdW5jdGlvbiooKSB7fScpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0fVxufTtcbi8qKiBAdHlwZSB7dW5kZWZpbmVkIHwgZmFsc2UgfCBudWxsIHwgR2VuZXJhdG9yRnVuY3Rpb25Db25zdHJ1Y3Rvcn0gKi9cbnZhciBHZW5lcmF0b3JGdW5jdGlvbjtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNHZW5lcmF0b3JGdW5jdGlvbihmbikge1xuXHRpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGlmIChpc0ZuUmVnZXgoZm5Ub1N0cihmbikpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHZhciBzdHIgPSB0b1N0cihmbik7XG5cdFx0cmV0dXJuIHN0ciA9PT0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcblx0fVxuXHRpZiAoIWdldFByb3RvKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGlmICh0eXBlb2YgR2VuZXJhdG9yRnVuY3Rpb24gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0dmFyIGdlbmVyYXRvckZ1bmMgPSBnZXRHZW5lcmF0b3JGdW5jKCk7XG5cdFx0R2VuZXJhdG9yRnVuY3Rpb24gPSBnZW5lcmF0b3JGdW5jXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0cmEtcGFyZW5zXG5cdFx0XHQ/IC8qKiBAdHlwZSB7R2VuZXJhdG9yRnVuY3Rpb25Db25zdHJ1Y3Rvcn0gKi8gKGdldFByb3RvKGdlbmVyYXRvckZ1bmMpKVxuXHRcdFx0OiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gZ2V0UHJvdG8oZm4pID09PSBHZW5lcmF0b3JGdW5jdGlvbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIuaXNuYW4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNhbGxCaW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kJyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnRpZXMnKTtcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xudmFyIHNoaW0gPSByZXF1aXJlKCcuL3NoaW0nKTtcblxudmFyIHBvbHlmaWxsID0gY2FsbEJpbmQoZ2V0UG9seWZpbGwoKSwgTnVtYmVyKTtcblxuLyogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5pc25hbiAqL1xuXG5kZWZpbmUocG9seWZpbGwsIHtcblx0Z2V0UG9seWZpbGw6IGdldFBvbHlmaWxsLFxuXHRpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb24sXG5cdHNoaW06IHNoaW1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvbHlmaWxsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UG9seWZpbGwoKSB7XG5cdGlmIChOdW1iZXIuaXNOYU4gJiYgTnVtYmVyLmlzTmFOKE5hTikgJiYgIU51bWJlci5pc05hTignYScpKSB7XG5cdFx0cmV0dXJuIE51bWJlci5pc05hTjtcblx0fVxuXHRyZXR1cm4gaW1wbGVtZW50YXRpb247XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnRpZXMnKTtcbnZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcblxuLyogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5pc25hbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1OdW1iZXJJc05hTigpIHtcblx0dmFyIHBvbHlmaWxsID0gZ2V0UG9seWZpbGwoKTtcblx0ZGVmaW5lKE51bWJlciwgeyBpc05hTjogcG9seWZpbGwgfSwge1xuXHRcdGlzTmFOOiBmdW5jdGlvbiB0ZXN0SXNOYU4oKSB7XG5cdFx0XHRyZXR1cm4gTnVtYmVyLmlzTmFOICE9PSBwb2x5ZmlsbDtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gcG9seWZpbGw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1ib3VuZCcpO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCdoYXNvd24nKTtcbnZhciBnT1BEID0gcmVxdWlyZSgnZ29wZCcpO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xudmFyIGZuO1xuXG5pZiAoaGFzVG9TdHJpbmdUYWcpIHtcblx0LyoqIEB0eXBlIHsocmVjZWl2ZXI6IFRoaXNQYXJhbWV0ZXJUeXBlPHR5cGVvZiBSZWdFeHAucHJvdG90eXBlLmV4ZWM+LCAuLi5hcmdzOiBQYXJhbWV0ZXJzPHR5cGVvZiBSZWdFeHAucHJvdG90eXBlLmV4ZWM+KSA9PiBSZXR1cm5UeXBlPHR5cGVvZiBSZWdFeHAucHJvdG90eXBlLmV4ZWM+fSAqL1xuXHR2YXIgJGV4ZWMgPSBjYWxsQm91bmQoJ1JlZ0V4cC5wcm90b3R5cGUuZXhlYycpO1xuXHQvKiogQHR5cGUge29iamVjdH0gKi9cblx0dmFyIGlzUmVnZXhNYXJrZXIgPSB7fTtcblxuXHR2YXIgdGhyb3dSZWdleE1hcmtlciA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aHJvdyBpc1JlZ2V4TWFya2VyO1xuXHR9O1xuXHQvKiogQHR5cGUge3sgdG9TdHJpbmcoKTogbmV2ZXIsIHZhbHVlT2YoKTogbmV2ZXIsIFtTeW1ib2wudG9QcmltaXRpdmVdPygpOiBuZXZlciB9fSAqL1xuXHR2YXIgYmFkU3RyaW5naWZpZXIgPSB7XG5cdFx0dG9TdHJpbmc6IHRocm93UmVnZXhNYXJrZXIsXG5cdFx0dmFsdWVPZjogdGhyb3dSZWdleE1hcmtlclxuXHR9O1xuXG5cdGlmICh0eXBlb2YgU3ltYm9sLnRvUHJpbWl0aXZlID09PSAnc3ltYm9sJykge1xuXHRcdGJhZFN0cmluZ2lmaWVyW1N5bWJvbC50b1ByaW1pdGl2ZV0gPSB0aHJvd1JlZ2V4TWFya2VyO1xuXHR9XG5cblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cblx0Ly8gQHRzLWV4cGVjdC1lcnJvciBUUyBjYW4ndCBmaWd1cmUgb3V0IHRoYXQgdGhlICRleGVjIGNhbGwgYWx3YXlzIHRocm93c1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cblx0Zm4gPSBmdW5jdGlvbiBpc1JlZ2V4KHZhbHVlKSB7XG5cdFx0aWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXBhcmVuc1xuXHRcdHZhciBkZXNjcmlwdG9yID0gLyoqIEB0eXBlIHtOb25OdWxsYWJsZTx0eXBlb2YgZ09QRD59ICovIChnT1BEKSgvKiogQHR5cGUge3sgbGFzdEluZGV4PzogdW5rbm93biB9fSAqLyAodmFsdWUpLCAnbGFzdEluZGV4Jyk7XG5cdFx0dmFyIGhhc0xhc3RJbmRleERhdGFQcm9wZXJ0eSA9IGRlc2NyaXB0b3IgJiYgaGFzT3duKGRlc2NyaXB0b3IsICd2YWx1ZScpO1xuXHRcdGlmICghaGFzTGFzdEluZGV4RGF0YVByb3BlcnR5KSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1wYXJlbnNcblx0XHRcdCRleGVjKHZhbHVlLCAvKiogQHR5cGUge3N0cmluZ30gKi8gKC8qKiBAdHlwZSB7dW5rbm93bn0gKi8gKGJhZFN0cmluZ2lmaWVyKSkpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiBlID09PSBpc1JlZ2V4TWFya2VyO1xuXHRcdH1cblx0fTtcbn0gZWxzZSB7XG5cdC8qKiBAdHlwZSB7KHJlY2VpdmVyOiBUaGlzUGFyYW1ldGVyVHlwZTx0eXBlb2YgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZz4sIC4uLmFyZ3M6IFBhcmFtZXRlcnM8dHlwZW9mIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc+KSA9PiBSZXR1cm5UeXBlPHR5cGVvZiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nPn0gKi9cblx0dmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xuXHQvKiogQGNvbnN0IEB0eXBlIHsnW29iamVjdCBSZWdFeHBdJ30gKi9cblx0dmFyIHJlZ2V4Q2xhc3MgPSAnW29iamVjdCBSZWdFeHBdJztcblxuXHQvKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xuXHRmbiA9IGZ1bmN0aW9uIGlzUmVnZXgodmFsdWUpIHtcblx0XHQvLyBJbiBvbGRlciBicm93c2VycywgdHlwZW9mIHJlZ2V4IGluY29ycmVjdGx5IHJldHVybnMgJ2Z1bmN0aW9uJ1xuXHRcdGlmICghdmFsdWUgfHwgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiAkdG9TdHJpbmcodmFsdWUpID09PSByZWdleENsYXNzO1xuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgd2hpY2hUeXBlZEFycmF5ID0gcmVxdWlyZSgnd2hpY2gtdHlwZWQtYXJyYXknKTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNUeXBlZEFycmF5KHZhbHVlKSB7XG5cdHJldHVybiAhIXdoaWNoVHlwZWRBcnJheSh2YWx1ZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9hYnMnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gTWF0aC5hYnM7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL2Zsb29yJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGguZmxvb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL2lzTmFOJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBpc05hTihhKSB7XG5cdHJldHVybiBhICE9PSBhO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vbWF4Jyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGgubWF4O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9taW4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gTWF0aC5taW47XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3BvdycpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnBvdztcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vcm91bmQnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gTWF0aC5yb3VuZDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyICRpc05hTiA9IHJlcXVpcmUoJy4vaXNOYU4nKTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vc2lnbicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaWduKG51bWJlcikge1xuXHRpZiAoJGlzTmFOKG51bWJlcikgfHwgbnVtYmVyID09PSAwKSB7XG5cdFx0cmV0dXJuIG51bWJlcjtcblx0fVxuXHRyZXR1cm4gbnVtYmVyIDwgMCA/IC0xIDogKzE7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbnVtYmVySXNOYU4gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXMoYSwgYikge1xuXHRpZiAoYSA9PT0gMCAmJiBiID09PSAwKSB7XG5cdFx0cmV0dXJuIDEgLyBhID09PSAxIC8gYjtcblx0fVxuXHRpZiAoYSA9PT0gYikge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdGlmIChudW1iZXJJc05hTihhKSAmJiBudW1iZXJJc05hTihiKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0aWVzJyk7XG52YXIgY2FsbEJpbmQgPSByZXF1aXJlKCdjYWxsLWJpbmQnKTtcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xudmFyIHNoaW0gPSByZXF1aXJlKCcuL3NoaW0nKTtcblxudmFyIHBvbHlmaWxsID0gY2FsbEJpbmQoZ2V0UG9seWZpbGwoKSwgT2JqZWN0KTtcblxuZGVmaW5lKHBvbHlmaWxsLCB7XG5cdGdldFBvbHlmaWxsOiBnZXRQb2x5ZmlsbCxcblx0aW1wbGVtZW50YXRpb246IGltcGxlbWVudGF0aW9uLFxuXHRzaGltOiBzaGltXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwb2x5ZmlsbDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBvbHlmaWxsKCkge1xuXHRyZXR1cm4gdHlwZW9mIE9iamVjdC5pcyA9PT0gJ2Z1bmN0aW9uJyA/IE9iamVjdC5pcyA6IGltcGxlbWVudGF0aW9uO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0aWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hpbU9iamVjdElzKCkge1xuXHR2YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpO1xuXHRkZWZpbmUoT2JqZWN0LCB7IGlzOiBwb2x5ZmlsbCB9LCB7XG5cdFx0aXM6IGZ1bmN0aW9uIHRlc3RPYmplY3RJcygpIHtcblx0XHRcdHJldHVybiBPYmplY3QuaXMgIT09IHBvbHlmaWxsO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBwb2x5ZmlsbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBrZXlzU2hpbTtcbmlmICghT2JqZWN0LmtleXMpIHtcblx0Ly8gbW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW1cblx0dmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cdHZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cdHZhciBpc0FyZ3MgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZ2xvYmFsLXJlcXVpcmVcblx0dmFyIGlzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cdHZhciBoYXNEb250RW51bUJ1ZyA9ICFpc0VudW1lcmFibGUuY2FsbCh7IHRvU3RyaW5nOiBudWxsIH0sICd0b1N0cmluZycpO1xuXHR2YXIgaGFzUHJvdG9FbnVtQnVnID0gaXNFbnVtZXJhYmxlLmNhbGwoZnVuY3Rpb24gKCkge30sICdwcm90b3R5cGUnKTtcblx0dmFyIGRvbnRFbnVtcyA9IFtcblx0XHQndG9TdHJpbmcnLFxuXHRcdCd0b0xvY2FsZVN0cmluZycsXG5cdFx0J3ZhbHVlT2YnLFxuXHRcdCdoYXNPd25Qcm9wZXJ0eScsXG5cdFx0J2lzUHJvdG90eXBlT2YnLFxuXHRcdCdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG5cdFx0J2NvbnN0cnVjdG9yJ1xuXHRdO1xuXHR2YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUgPSBmdW5jdGlvbiAobykge1xuXHRcdHZhciBjdG9yID0gby5jb25zdHJ1Y3Rvcjtcblx0XHRyZXR1cm4gY3RvciAmJiBjdG9yLnByb3RvdHlwZSA9PT0gbztcblx0fTtcblx0dmFyIGV4Y2x1ZGVkS2V5cyA9IHtcblx0XHQkYXBwbGljYXRpb25DYWNoZTogdHJ1ZSxcblx0XHQkY29uc29sZTogdHJ1ZSxcblx0XHQkZXh0ZXJuYWw6IHRydWUsXG5cdFx0JGZyYW1lOiB0cnVlLFxuXHRcdCRmcmFtZUVsZW1lbnQ6IHRydWUsXG5cdFx0JGZyYW1lczogdHJ1ZSxcblx0XHQkaW5uZXJIZWlnaHQ6IHRydWUsXG5cdFx0JGlubmVyV2lkdGg6IHRydWUsXG5cdFx0JG9ubW96ZnVsbHNjcmVlbmNoYW5nZTogdHJ1ZSxcblx0XHQkb25tb3pmdWxsc2NyZWVuZXJyb3I6IHRydWUsXG5cdFx0JG91dGVySGVpZ2h0OiB0cnVlLFxuXHRcdCRvdXRlcldpZHRoOiB0cnVlLFxuXHRcdCRwYWdlWE9mZnNldDogdHJ1ZSxcblx0XHQkcGFnZVlPZmZzZXQ6IHRydWUsXG5cdFx0JHBhcmVudDogdHJ1ZSxcblx0XHQkc2Nyb2xsTGVmdDogdHJ1ZSxcblx0XHQkc2Nyb2xsVG9wOiB0cnVlLFxuXHRcdCRzY3JvbGxYOiB0cnVlLFxuXHRcdCRzY3JvbGxZOiB0cnVlLFxuXHRcdCRzZWxmOiB0cnVlLFxuXHRcdCR3ZWJraXRJbmRleGVkREI6IHRydWUsXG5cdFx0JHdlYmtpdFN0b3JhZ2VJbmZvOiB0cnVlLFxuXHRcdCR3aW5kb3c6IHRydWVcblx0fTtcblx0dmFyIGhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1ZyA9IChmdW5jdGlvbiAoKSB7XG5cdFx0LyogZ2xvYmFsIHdpbmRvdyAqL1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRmb3IgKHZhciBrIGluIHdpbmRvdykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKCFleGNsdWRlZEtleXNbJyQnICsga10gJiYgaGFzLmNhbGwod2luZG93LCBrKSAmJiB3aW5kb3dba10gIT09IG51bGwgJiYgdHlwZW9mIHdpbmRvd1trXSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0ZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUod2luZG93W2tdKTtcblx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSgpKTtcblx0dmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneSA9IGZ1bmN0aW9uIChvKSB7XG5cdFx0LyogZ2xvYmFsIHdpbmRvdyAqL1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhaGFzQXV0b21hdGlvbkVxdWFsaXR5QnVnKSB7XG5cdFx0XHRyZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUobyk7XG5cdFx0fVxuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUobyk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fTtcblxuXHRrZXlzU2hpbSA9IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG5cdFx0dmFyIGlzT2JqZWN0ID0gb2JqZWN0ICE9PSBudWxsICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnO1xuXHRcdHZhciBpc0Z1bmN0aW9uID0gdG9TdHIuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXHRcdHZhciBpc0FyZ3VtZW50cyA9IGlzQXJncyhvYmplY3QpO1xuXHRcdHZhciBpc1N0cmluZyA9IGlzT2JqZWN0ICYmIHRvU3RyLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cdFx0dmFyIHRoZUtleXMgPSBbXTtcblxuXHRcdGlmICghaXNPYmplY3QgJiYgIWlzRnVuY3Rpb24gJiYgIWlzQXJndW1lbnRzKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Qua2V5cyBjYWxsZWQgb24gYSBub24tb2JqZWN0Jyk7XG5cdFx0fVxuXG5cdFx0dmFyIHNraXBQcm90byA9IGhhc1Byb3RvRW51bUJ1ZyAmJiBpc0Z1bmN0aW9uO1xuXHRcdGlmIChpc1N0cmluZyAmJiBvYmplY3QubGVuZ3RoID4gMCAmJiAhaGFzLmNhbGwob2JqZWN0LCAwKSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhpKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGlzQXJndW1lbnRzICYmIG9iamVjdC5sZW5ndGggPiAwKSB7XG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IG9iamVjdC5sZW5ndGg7ICsraikge1xuXHRcdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKGopKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcblx0XHRcdFx0aWYgKCEoc2tpcFByb3RvICYmIG5hbWUgPT09ICdwcm90b3R5cGUnKSAmJiBoYXMuY2FsbChvYmplY3QsIG5hbWUpKSB7XG5cdFx0XHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhuYW1lKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaGFzRG9udEVudW1CdWcpIHtcblx0XHRcdHZhciBza2lwQ29uc3RydWN0b3IgPSBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kob2JqZWN0KTtcblxuXHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBkb250RW51bXMubGVuZ3RoOyArK2spIHtcblx0XHRcdFx0aWYgKCEoc2tpcENvbnN0cnVjdG9yICYmIGRvbnRFbnVtc1trXSA9PT0gJ2NvbnN0cnVjdG9yJykgJiYgaGFzLmNhbGwob2JqZWN0LCBkb250RW51bXNba10pKSB7XG5cdFx0XHRcdFx0dGhlS2V5cy5wdXNoKGRvbnRFbnVtc1trXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoZUtleXM7XG5cdH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGtleXNTaGltO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaXNBcmdzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpO1xuXG52YXIgb3JpZ0tleXMgPSBPYmplY3Qua2V5cztcbnZhciBrZXlzU2hpbSA9IG9yaWdLZXlzID8gZnVuY3Rpb24ga2V5cyhvKSB7IHJldHVybiBvcmlnS2V5cyhvKTsgfSA6IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxudmFyIG9yaWdpbmFsS2V5cyA9IE9iamVjdC5rZXlzO1xuXG5rZXlzU2hpbS5zaGltID0gZnVuY3Rpb24gc2hpbU9iamVjdEtleXMoKSB7XG5cdGlmIChPYmplY3Qua2V5cykge1xuXHRcdHZhciBrZXlzV29ya3NXaXRoQXJndW1lbnRzID0gKGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIFNhZmFyaSA1LjAgYnVnXG5cdFx0XHR2YXIgYXJncyA9IE9iamVjdC5rZXlzKGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gYXJncyAmJiBhcmdzLmxlbmd0aCA9PT0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHR9KDEsIDIpKTtcblx0XHRpZiAoIWtleXNXb3Jrc1dpdGhBcmd1bWVudHMpIHtcblx0XHRcdE9iamVjdC5rZXlzID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jLW5hbWUtbWF0Y2hpbmdcblx0XHRcdFx0aWYgKGlzQXJncyhvYmplY3QpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsS2V5cyhzbGljZS5jYWxsKG9iamVjdCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBvcmlnaW5hbEtleXMob2JqZWN0KTtcblx0XHRcdH07XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdE9iamVjdC5rZXlzID0ga2V5c1NoaW07XG5cdH1cblx0cmV0dXJuIE9iamVjdC5rZXlzIHx8IGtleXNTaGltO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzU2hpbTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHR2YXIgc3RyID0gdG9TdHIuY2FsbCh2YWx1ZSk7XG5cdHZhciBpc0FyZ3MgPSBzdHIgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXHRpZiAoIWlzQXJncykge1xuXHRcdGlzQXJncyA9IHN0ciAhPT0gJ1tvYmplY3QgQXJyYXldJyAmJlxuXHRcdFx0dmFsdWUgIT09IG51bGwgJiZcblx0XHRcdHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcblx0XHRcdHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG5cdFx0XHR2YWx1ZS5sZW5ndGggPj0gMCAmJlxuXHRcdFx0dG9TdHIuY2FsbCh2YWx1ZS5jYWxsZWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXHR9XG5cdHJldHVybiBpc0FyZ3M7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczYtc2hpbVxudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCdvYmplY3Qta2V5cycpO1xudmFyIGhhc1N5bWJvbHMgPSByZXF1aXJlKCdoYXMtc3ltYm9scy9zaGFtcycpKCk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1ib3VuZCcpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCdlcy1vYmplY3QtYXRvbXMnKTtcbnZhciAkcHVzaCA9IGNhbGxCb3VuZCgnQXJyYXkucHJvdG90eXBlLnB1c2gnKTtcbnZhciAkcHJvcElzRW51bWVyYWJsZSA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZScpO1xudmFyIG9yaWdpbmFsR2V0U3ltYm9scyA9IGhhc1N5bWJvbHMgPyAkT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA6IG51bGw7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UxKSB7XG5cdGlmICh0YXJnZXQgPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCd0YXJnZXQgbXVzdCBiZSBhbiBvYmplY3QnKTsgfVxuXHR2YXIgdG8gPSAkT2JqZWN0KHRhcmdldCk7IC8vIHN0ZXAgMVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuXHRcdHJldHVybiB0bzsgLy8gc3RlcCAyXG5cdH1cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyArK3MpIHtcblx0XHR2YXIgZnJvbSA9ICRPYmplY3QoYXJndW1lbnRzW3NdKTsgLy8gc3RlcCAzLmEuaVxuXG5cdFx0Ly8gc3RlcCAzLmEuaWk6XG5cdFx0dmFyIGtleXMgPSBvYmplY3RLZXlzKGZyb20pO1xuXHRcdHZhciBnZXRTeW1ib2xzID0gaGFzU3ltYm9scyAmJiAoJE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgfHwgb3JpZ2luYWxHZXRTeW1ib2xzKTtcblx0XHRpZiAoZ2V0U3ltYm9scykge1xuXHRcdFx0dmFyIHN5bXMgPSBnZXRTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBzeW1zLmxlbmd0aDsgKytqKSB7XG5cdFx0XHRcdHZhciBrZXkgPSBzeW1zW2pdO1xuXHRcdFx0XHRpZiAoJHByb3BJc0VudW1lcmFibGUoZnJvbSwga2V5KSkge1xuXHRcdFx0XHRcdCRwdXNoKGtleXMsIGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBzdGVwIDMuYS5paWk6XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHR2YXIgbmV4dEtleSA9IGtleXNbaV07XG5cdFx0XHRpZiAoJHByb3BJc0VudW1lcmFibGUoZnJvbSwgbmV4dEtleSkpIHsgLy8gc3RlcCAzLmEuaWlpLjJcblx0XHRcdFx0dmFyIHByb3BWYWx1ZSA9IGZyb21bbmV4dEtleV07IC8vIHN0ZXAgMy5hLmlpaS4yLmFcblx0XHRcdFx0dG9bbmV4dEtleV0gPSBwcm9wVmFsdWU7IC8vIHN0ZXAgMy5hLmlpaS4yLmJcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87IC8vIHN0ZXAgNFxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG52YXIgbGFja3NQcm9wZXJFbnVtZXJhdGlvbk9yZGVyID0gZnVuY3Rpb24gKCkge1xuXHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0Lypcblx0ICogdjgsIHNwZWNpZmljYWxseSBpbiBub2RlIDQueCwgaGFzIGEgYnVnIHdpdGggaW5jb3JyZWN0IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyXG5cdCAqIG5vdGU6IHRoaXMgZG9lcyBub3QgZGV0ZWN0IHRoZSBidWcgdW5sZXNzIHRoZXJlJ3MgMjAgY2hhcmFjdGVyc1xuXHQgKi9cblx0dmFyIHN0ciA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG5cdHZhciBsZXR0ZXJzID0gc3RyLnNwbGl0KCcnKTtcblx0dmFyIG1hcCA9IHt9O1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxldHRlcnMubGVuZ3RoOyArK2kpIHtcblx0XHRtYXBbbGV0dGVyc1tpXV0gPSBsZXR0ZXJzW2ldO1xuXHR9XG5cdHZhciBvYmogPSBPYmplY3QuYXNzaWduKHt9LCBtYXApO1xuXHR2YXIgYWN0dWFsID0gJyc7XG5cdGZvciAodmFyIGsgaW4gb2JqKSB7XG5cdFx0YWN0dWFsICs9IGs7XG5cdH1cblx0cmV0dXJuIHN0ciAhPT0gYWN0dWFsO1xufTtcblxudmFyIGFzc2lnbkhhc1BlbmRpbmdFeGNlcHRpb25zID0gZnVuY3Rpb24gKCkge1xuXHRpZiAoIU9iamVjdC5hc3NpZ24gfHwgIU9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHQvKlxuXHQgKiBGaXJlZm94IDM3IHN0aWxsIGhhcyBcInBlbmRpbmcgZXhjZXB0aW9uXCIgbG9naWMgaW4gaXRzIE9iamVjdC5hc3NpZ24gaW1wbGVtZW50YXRpb24sXG5cdCAqIHdoaWNoIGlzIDcyJSBzbG93ZXIgdGhhbiBvdXIgc2hpbSwgYW5kIEZpcmVmb3ggNDAncyBuYXRpdmUgaW1wbGVtZW50YXRpb24uXG5cdCAqL1xuXHR2YXIgdGhyb3dlciA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7IDE6IDIgfSk7XG5cdHRyeSB7XG5cdFx0T2JqZWN0LmFzc2lnbih0aHJvd2VyLCAneHknKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiB0aHJvd2VyWzFdID09PSAneSc7XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQb2x5ZmlsbCgpIHtcblx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0cmV0dXJuIGltcGxlbWVudGF0aW9uO1xuXHR9XG5cdGlmIChsYWNrc1Byb3BlckVudW1lcmF0aW9uT3JkZXIoKSkge1xuXHRcdHJldHVybiBpbXBsZW1lbnRhdGlvbjtcblx0fVxuXHRpZiAoYXNzaWduSGFzUGVuZGluZ0V4Y2VwdGlvbnMoKSkge1xuXHRcdHJldHVybiBpbXBsZW1lbnRhdGlvbjtcblx0fVxuXHRyZXR1cm4gT2JqZWN0LmFzc2lnbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IFtcblx0J0Zsb2F0MTZBcnJheScsXG5cdCdGbG9hdDMyQXJyYXknLFxuXHQnRmxvYXQ2NEFycmF5Jyxcblx0J0ludDhBcnJheScsXG5cdCdJbnQxNkFycmF5Jyxcblx0J0ludDMyQXJyYXknLFxuXHQnVWludDhBcnJheScsXG5cdCdVaW50OENsYW1wZWRBcnJheScsXG5cdCdVaW50MTZBcnJheScsXG5cdCdVaW50MzJBcnJheScsXG5cdCdCaWdJbnQ2NEFycmF5Jyxcblx0J0JpZ1VpbnQ2NEFycmF5J1xuXTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJvdW5kJyk7XG52YXIgaXNSZWdleCA9IHJlcXVpcmUoJ2lzLXJlZ2V4Jyk7XG5cbnZhciAkZXhlYyA9IGNhbGxCb3VuZCgnUmVnRXhwLnByb3RvdHlwZS5leGVjJyk7XG52YXIgJFR5cGVFcnJvciA9IHJlcXVpcmUoJ2VzLWVycm9ycy90eXBlJyk7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlZ2V4VGVzdGVyKHJlZ2V4KSB7XG5cdGlmICghaXNSZWdleChyZWdleCkpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYHJlZ2V4YCBtdXN0IGJlIGEgUmVnRXhwJyk7XG5cdH1cblx0cmV0dXJuIGZ1bmN0aW9uIHRlc3Qocykge1xuXHRcdHJldHVybiAkZXhlYyhyZWdleCwgcykgIT09IG51bGw7XG5cdH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1kYXRhLXByb3BlcnR5Jyk7XG52YXIgaGFzRGVzY3JpcHRvcnMgPSByZXF1aXJlKCdoYXMtcHJvcGVydHktZGVzY3JpcHRvcnMnKSgpO1xudmFyIGdPUEQgPSByZXF1aXJlKCdnb3BkJyk7XG5cbnZhciAkVHlwZUVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzL3R5cGUnKTtcbnZhciAkZmxvb3IgPSBHZXRJbnRyaW5zaWMoJyVNYXRoLmZsb29yJScpO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXRGdW5jdGlvbkxlbmd0aChmbiwgbGVuZ3RoKSB7XG5cdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYGZuYCBpcyBub3QgYSBmdW5jdGlvbicpO1xuXHR9XG5cdGlmICh0eXBlb2YgbGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBsZW5ndGggPCAwIHx8IGxlbmd0aCA+IDB4RkZGRkZGRkYgfHwgJGZsb29yKGxlbmd0aCkgIT09IGxlbmd0aCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgbGVuZ3RoYCBtdXN0IGJlIGEgcG9zaXRpdmUgMzItYml0IGludGVnZXInKTtcblx0fVxuXG5cdHZhciBsb29zZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmICEhYXJndW1lbnRzWzJdO1xuXG5cdHZhciBmdW5jdGlvbkxlbmd0aElzQ29uZmlndXJhYmxlID0gdHJ1ZTtcblx0dmFyIGZ1bmN0aW9uTGVuZ3RoSXNXcml0YWJsZSA9IHRydWU7XG5cdGlmICgnbGVuZ3RoJyBpbiBmbiAmJiBnT1BEKSB7XG5cdFx0dmFyIGRlc2MgPSBnT1BEKGZuLCAnbGVuZ3RoJyk7XG5cdFx0aWYgKGRlc2MgJiYgIWRlc2MuY29uZmlndXJhYmxlKSB7XG5cdFx0XHRmdW5jdGlvbkxlbmd0aElzQ29uZmlndXJhYmxlID0gZmFsc2U7XG5cdFx0fVxuXHRcdGlmIChkZXNjICYmICFkZXNjLndyaXRhYmxlKSB7XG5cdFx0XHRmdW5jdGlvbkxlbmd0aElzV3JpdGFibGUgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRpZiAoZnVuY3Rpb25MZW5ndGhJc0NvbmZpZ3VyYWJsZSB8fCBmdW5jdGlvbkxlbmd0aElzV3JpdGFibGUgfHwgIWxvb3NlKSB7XG5cdFx0aWYgKGhhc0Rlc2NyaXB0b3JzKSB7XG5cdFx0XHRkZWZpbmUoLyoqIEB0eXBlIHtQYXJhbWV0ZXJzPGRlZmluZT5bMF19ICovIChmbiksICdsZW5ndGgnLCBsZW5ndGgsIHRydWUsIHRydWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWZpbmUoLyoqIEB0eXBlIHtQYXJhbWV0ZXJzPGRlZmluZT5bMF19ICovIChmbiksICdsZW5ndGgnLCBsZW5ndGgpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZm47XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvaW50ZXJuYWwvdXRpbC90eXBlcy5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8xMTJjYzdjMjc1NTEyNTRhYTJiMTcwOThmYjc3NDg2N2YwNWVkMGQ5XG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzQXJndW1lbnRzT2JqZWN0ID0gcmVxdWlyZSgnaXMtYXJndW1lbnRzJyk7XG52YXIgaXNHZW5lcmF0b3JGdW5jdGlvbiA9IHJlcXVpcmUoJ2lzLWdlbmVyYXRvci1mdW5jdGlvbicpO1xudmFyIHdoaWNoVHlwZWRBcnJheSA9IHJlcXVpcmUoJ3doaWNoLXR5cGVkLWFycmF5Jyk7XG52YXIgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnaXMtdHlwZWQtYXJyYXknKTtcblxuZnVuY3Rpb24gdW5jdXJyeVRoaXMoZikge1xuICByZXR1cm4gZi5jYWxsLmJpbmQoZik7XG59XG5cbnZhciBCaWdJbnRTdXBwb3J0ZWQgPSB0eXBlb2YgQmlnSW50ICE9PSAndW5kZWZpbmVkJztcbnZhciBTeW1ib2xTdXBwb3J0ZWQgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJztcblxudmFyIE9iamVjdFRvU3RyaW5nID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG5cbnZhciBudW1iZXJWYWx1ZSA9IHVuY3VycnlUaGlzKE51bWJlci5wcm90b3R5cGUudmFsdWVPZik7XG52YXIgc3RyaW5nVmFsdWUgPSB1bmN1cnJ5VGhpcyhTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YpO1xudmFyIGJvb2xlYW5WYWx1ZSA9IHVuY3VycnlUaGlzKEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YpO1xuXG5pZiAoQmlnSW50U3VwcG9ydGVkKSB7XG4gIHZhciBiaWdJbnRWYWx1ZSA9IHVuY3VycnlUaGlzKEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZik7XG59XG5cbmlmIChTeW1ib2xTdXBwb3J0ZWQpIHtcbiAgdmFyIHN5bWJvbFZhbHVlID0gdW5jdXJyeVRoaXMoU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgcHJvdG90eXBlVmFsdWVPZikge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIHByb3RvdHlwZVZhbHVlT2YodmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0cy5pc0FyZ3VtZW50c09iamVjdCA9IGlzQXJndW1lbnRzT2JqZWN0O1xuZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gaXNHZW5lcmF0b3JGdW5jdGlvbjtcbmV4cG9ydHMuaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xuXG4vLyBUYWtlbiBmcm9tIGhlcmUgYW5kIG1vZGlmaWVkIGZvciBiZXR0ZXIgYnJvd3NlciBzdXBwb3J0XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3AtaXMtcHJvbWlzZS9ibG9iL2NkYTM1YTUxM2JkYTAzZjk3N2FkNWNkZTNhMDc5ZDIzN2U4MmQ3ZWYvaW5kZXguanNcbmZ1bmN0aW9uIGlzUHJvbWlzZShpbnB1dCkge1xuXHRyZXR1cm4gKFxuXHRcdChcblx0XHRcdHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJlxuXHRcdFx0aW5wdXQgaW5zdGFuY2VvZiBQcm9taXNlXG5cdFx0KSB8fFxuXHRcdChcblx0XHRcdGlucHV0ICE9PSBudWxsICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdFx0dHlwZW9mIGlucHV0LmNhdGNoID09PSAnZnVuY3Rpb24nXG5cdFx0KVxuXHQpO1xufVxuZXhwb3J0cy5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIEFycmF5QnVmZmVyLmlzVmlldykge1xuICAgIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICBpc1R5cGVkQXJyYXkodmFsdWUpIHx8XG4gICAgaXNEYXRhVmlldyh2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNBcnJheUJ1ZmZlclZpZXcgPSBpc0FycmF5QnVmZmVyVmlldztcblxuXG5mdW5jdGlvbiBpc1VpbnQ4QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50OEFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50OEFycmF5ID0gaXNVaW50OEFycmF5O1xuXG5mdW5jdGlvbiBpc1VpbnQ4Q2xhbXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDhDbGFtcGVkQXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQ4Q2xhbXBlZEFycmF5ID0gaXNVaW50OENsYW1wZWRBcnJheTtcblxuZnVuY3Rpb24gaXNVaW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQxNkFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50MTZBcnJheSA9IGlzVWludDE2QXJyYXk7XG5cbmZ1bmN0aW9uIGlzVWludDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50MzJBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDMyQXJyYXkgPSBpc1VpbnQzMkFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDhBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDhBcnJheSc7XG59XG5leHBvcnRzLmlzSW50OEFycmF5ID0gaXNJbnQ4QXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDE2QXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDE2QXJyYXkgPSBpc0ludDE2QXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDMyQXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDMyQXJyYXkgPSBpc0ludDMyQXJyYXk7XG5cbmZ1bmN0aW9uIGlzRmxvYXQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnRmxvYXQzMkFycmF5Jztcbn1cbmV4cG9ydHMuaXNGbG9hdDMyQXJyYXkgPSBpc0Zsb2F0MzJBcnJheTtcblxuZnVuY3Rpb24gaXNGbG9hdDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdGbG9hdDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0Zsb2F0NjRBcnJheSA9IGlzRmxvYXQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc0JpZ0ludDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdCaWdJbnQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNCaWdJbnQ2NEFycmF5ID0gaXNCaWdJbnQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc0JpZ1VpbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnQmlnVWludDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0JpZ1VpbnQ2NEFycmF5ID0gaXNCaWdVaW50NjRBcnJheTtcblxuZnVuY3Rpb24gaXNNYXBUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBNYXBdJztcbn1cbmlzTWFwVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNNYXBUb1N0cmluZyhuZXcgTWFwKCkpXG4pO1xuXG5mdW5jdGlvbiBpc01hcCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNNYXBUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc01hcFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBNYXA7XG59XG5leHBvcnRzLmlzTWFwID0gaXNNYXA7XG5cbmZ1bmN0aW9uIGlzU2V0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2V0XSc7XG59XG5pc1NldFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzU2V0VG9TdHJpbmcobmV3IFNldCgpKVxuKTtcbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc1NldFRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzU2V0VG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFNldDtcbn1cbmV4cG9ydHMuaXNTZXQgPSBpc1NldDtcblxuZnVuY3Rpb24gaXNXZWFrTWFwVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2Vha01hcF0nO1xufVxuaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzV2Vha01hcFRvU3RyaW5nKG5ldyBXZWFrTWFwKCkpXG4pO1xuZnVuY3Rpb24gaXNXZWFrTWFwKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNXZWFrTWFwVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFdlYWtNYXA7XG59XG5leHBvcnRzLmlzV2Vha01hcCA9IGlzV2Vha01hcDtcblxuZnVuY3Rpb24gaXNXZWFrU2V0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2Vha1NldF0nO1xufVxuaXNXZWFrU2V0VG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFdlYWtTZXQgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzV2Vha1NldFRvU3RyaW5nKG5ldyBXZWFrU2V0KCkpXG4pO1xuZnVuY3Rpb24gaXNXZWFrU2V0KHZhbHVlKSB7XG4gIHJldHVybiBpc1dlYWtTZXRUb1N0cmluZyh2YWx1ZSk7XG59XG5leHBvcnRzLmlzV2Vha1NldCA9IGlzV2Vha1NldDtcblxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG59XG5pc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc0FycmF5QnVmZmVyVG9TdHJpbmcobmV3IEFycmF5QnVmZmVyKCkpXG4pO1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbn1cbmV4cG9ydHMuaXNBcnJheUJ1ZmZlciA9IGlzQXJyYXlCdWZmZXI7XG5cbmZ1bmN0aW9uIGlzRGF0YVZpZXdUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBEYXRhVmlld10nO1xufVxuaXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIERhdGFWaWV3ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc0RhdGFWaWV3VG9TdHJpbmcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSwgMCwgMSkpXG4pO1xuZnVuY3Rpb24gaXNEYXRhVmlldyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIERhdGFWaWV3ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0RhdGFWaWV3VG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNEYXRhVmlld1RvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBEYXRhVmlldztcbn1cbmV4cG9ydHMuaXNEYXRhVmlldyA9IGlzRGF0YVZpZXc7XG5cbi8vIFN0b3JlIGEgY29weSBvZiBTaGFyZWRBcnJheUJ1ZmZlciBpbiBjYXNlIGl0J3MgZGVsZXRlZCBlbHNld2hlcmVcbnZhciBTaGFyZWRBcnJheUJ1ZmZlckNvcHkgPSB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnID8gU2hhcmVkQXJyYXlCdWZmZXIgOiB1bmRlZmluZWQ7XG5mdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2hhcmVkQXJyYXlCdWZmZXJdJztcbn1cbmZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlckNvcHkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9IGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgU2hhcmVkQXJyYXlCdWZmZXJDb3B5KCkpO1xuICB9XG5cbiAgcmV0dXJuIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyQ29weTtcbn1cbmV4cG9ydHMuaXNTaGFyZWRBcnJheUJ1ZmZlciA9IGlzU2hhcmVkQXJyYXlCdWZmZXI7XG5cbmZ1bmN0aW9uIGlzQXN5bmNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXSc7XG59XG5leHBvcnRzLmlzQXN5bmNGdW5jdGlvbiA9IGlzQXN5bmNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNNYXBJdGVyYXRvcih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBNYXAgSXRlcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNNYXBJdGVyYXRvciA9IGlzTWFwSXRlcmF0b3I7XG5cbmZ1bmN0aW9uIGlzU2V0SXRlcmF0b3IodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2V0IEl0ZXJhdG9yXSc7XG59XG5leHBvcnRzLmlzU2V0SXRlcmF0b3IgPSBpc1NldEl0ZXJhdG9yO1xuXG5mdW5jdGlvbiBpc0dlbmVyYXRvck9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBHZW5lcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNHZW5lcmF0b3JPYmplY3QgPSBpc0dlbmVyYXRvck9iamVjdDtcblxuZnVuY3Rpb24gaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYkFzc2VtYmx5Lk1vZHVsZV0nO1xufVxuZXhwb3J0cy5pc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUgPSBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGU7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBudW1iZXJWYWx1ZSk7XG59XG5leHBvcnRzLmlzTnVtYmVyT2JqZWN0ID0gaXNOdW1iZXJPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBzdHJpbmdWYWx1ZSk7XG59XG5leHBvcnRzLmlzU3RyaW5nT2JqZWN0ID0gaXNTdHJpbmdPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgYm9vbGVhblZhbHVlKTtcbn1cbmV4cG9ydHMuaXNCb29sZWFuT2JqZWN0ID0gaXNCb29sZWFuT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0JpZ0ludE9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gQmlnSW50U3VwcG9ydGVkICYmIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIGJpZ0ludFZhbHVlKTtcbn1cbmV4cG9ydHMuaXNCaWdJbnRPYmplY3QgPSBpc0JpZ0ludE9iamVjdDtcblxuZnVuY3Rpb24gaXNTeW1ib2xPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIFN5bWJvbFN1cHBvcnRlZCAmJiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBzeW1ib2xWYWx1ZSk7XG59XG5leHBvcnRzLmlzU3ltYm9sT2JqZWN0ID0gaXNTeW1ib2xPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQm94ZWRQcmltaXRpdmUodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICBpc051bWJlck9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc1N0cmluZ09iamVjdCh2YWx1ZSkgfHxcbiAgICBpc0Jvb2xlYW5PYmplY3QodmFsdWUpIHx8XG4gICAgaXNCaWdJbnRPYmplY3QodmFsdWUpIHx8XG4gICAgaXNTeW1ib2xPYmplY3QodmFsdWUpXG4gICk7XG59XG5leHBvcnRzLmlzQm94ZWRQcmltaXRpdmUgPSBpc0JveGVkUHJpbWl0aXZlO1xuXG5mdW5jdGlvbiBpc0FueUFycmF5QnVmZmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICAgIGlzQXJyYXlCdWZmZXIodmFsdWUpIHx8XG4gICAgaXNTaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNBbnlBcnJheUJ1ZmZlciA9IGlzQW55QXJyYXlCdWZmZXI7XG5cblsnaXNQcm94eScsICdpc0V4dGVybmFsJywgJ2lzTW9kdWxlTmFtZXNwYWNlT2JqZWN0J10uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG1ldGhvZCwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXRob2QgKyAnIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdXNlcmxhbmQnKTtcbiAgICB9XG4gIH0pO1xufSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyB8fFxuICBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB2YXIgZGVzY3JpcHRvcnMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlc2NyaXB0b3JzW2tleXNbaV1dID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVzY3JpcHRvcnM7XG4gIH07XG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52UmVnZXggPSAvXiQvO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRykge1xuICB2YXIgZGVidWdFbnYgPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHO1xuICBkZWJ1Z0VudiA9IGRlYnVnRW52LnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrPy5dL2csICdcXFxcJCYnKVxuICAgIC5yZXBsYWNlKC9cXCovZywgJy4qJylcbiAgICAucmVwbGFjZSgvLC9nLCAnJHxeJylcbiAgICAudG9VcHBlckNhc2UoKTtcbiAgZGVidWdFbnZSZWdleCA9IG5ldyBSZWdFeHAoJ14nICsgZGVidWdFbnYgKyAnJCcsICdpJyk7XG59XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKGRlYnVnRW52UmVnZXgudGVzdChzZXQpKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnNsaWNlKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMSwgLTEpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmV4cG9ydHMudHlwZXMgPSByZXF1aXJlKCcuL3N1cHBvcnQvdHlwZXMnKTtcblxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcbmV4cG9ydHMudHlwZXMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5leHBvcnRzLnR5cGVzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuZXhwb3J0cy50eXBlcy5pc05hdGl2ZUVycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxudmFyIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnID8gU3ltYm9sKCd1dGlsLnByb21pc2lmeS5jdXN0b20nKSA6IHVuZGVmaW5lZDtcblxuZXhwb3J0cy5wcm9taXNpZnkgPSBmdW5jdGlvbiBwcm9taXNpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgJiYgb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXSkge1xuICAgIHZhciBmbiA9IG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF07XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidXRpbC5wcm9taXNpZnkuY3VzdG9tXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZuKCkge1xuICAgIHZhciBwcm9taXNlUmVzb2x2ZSwgcHJvbWlzZVJlamVjdDtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHByb21pc2VSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHByb21pc2VSZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG5cbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG4gICAgYXJncy5wdXNoKGZ1bmN0aW9uIChlcnIsIHZhbHVlKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2VSZXNvbHZlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRyeSB7XG4gICAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihmbiwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFxuICAgIGZuLFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpXG4gICk7XG59XG5cbmV4cG9ydHMucHJvbWlzaWZ5LmN1c3RvbSA9IGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbFxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeU9uUmVqZWN0ZWQocmVhc29uLCBjYikge1xuICAvLyBgIXJlYXNvbmAgZ3VhcmQgaW5zcGlyZWQgYnkgYmx1ZWJpcmQgKFJlZjogaHR0cHM6Ly9nb28uZ2wvdDVJUzZNKS5cbiAgLy8gQmVjYXVzZSBgbnVsbGAgaXMgYSBzcGVjaWFsIGVycm9yIHZhbHVlIGluIGNhbGxiYWNrcyB3aGljaCBtZWFucyBcIm5vIGVycm9yXG4gIC8vIG9jY3VycmVkXCIsIHdlIGVycm9yLXdyYXAgc28gdGhlIGNhbGxiYWNrIGNvbnN1bWVyIGNhbiBkaXN0aW5ndWlzaCBiZXR3ZWVuXG4gIC8vIFwidGhlIHByb21pc2UgcmVqZWN0ZWQgd2l0aCBudWxsXCIgb3IgXCJ0aGUgcHJvbWlzZSBmdWxmaWxsZWQgd2l0aCB1bmRlZmluZWRcIi5cbiAgaWYgKCFyZWFzb24pIHtcbiAgICB2YXIgbmV3UmVhc29uID0gbmV3IEVycm9yKCdQcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGEgZmFsc3kgdmFsdWUnKTtcbiAgICBuZXdSZWFzb24ucmVhc29uID0gcmVhc29uO1xuICAgIHJlYXNvbiA9IG5ld1JlYXNvbjtcbiAgfVxuICByZXR1cm4gY2IocmVhc29uKTtcbn1cblxuZnVuY3Rpb24gY2FsbGJhY2tpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gIH1cblxuICAvLyBXZSBETyBOT1QgcmV0dXJuIHRoZSBwcm9taXNlIGFzIGl0IGdpdmVzIHRoZSB1c2VyIGEgZmFsc2Ugc2Vuc2UgdGhhdFxuICAvLyB0aGUgcHJvbWlzZSBpcyBhY3R1YWxseSBzb21laG93IHJlbGF0ZWQgdG8gdGhlIGNhbGxiYWNrJ3MgZXhlY3V0aW9uXG4gIC8vIGFuZCB0aGF0IHRoZSBjYWxsYmFjayB0aHJvd2luZyB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZS5cbiAgZnVuY3Rpb24gY2FsbGJhY2tpZmllZCgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG5cbiAgICB2YXIgbWF5YmVDYiA9IGFyZ3MucG9wKCk7XG4gICAgaWYgKHR5cGVvZiBtYXliZUNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGFzdCBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG1heWJlQ2IuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIC8vIEluIHRydWUgbm9kZSBzdHlsZSB3ZSBwcm9jZXNzIHRoZSBjYWxsYmFjayBvbiBgbmV4dFRpY2tgIHdpdGggYWxsIHRoZVxuICAgIC8vIGltcGxpY2F0aW9ucyAoc3RhY2ssIGB1bmNhdWdodEV4Y2VwdGlvbmAsIGBhc3luY19ob29rc2ApXG4gICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncylcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHJldCkgeyBwcm9jZXNzLm5leHRUaWNrKGNiLmJpbmQobnVsbCwgbnVsbCwgcmV0KSkgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHJlaikgeyBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNraWZ5T25SZWplY3RlZC5iaW5kKG51bGwsIHJlaiwgY2IpKSB9KTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihjYWxsYmFja2lmaWVkLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY2FsbGJhY2tpZmllZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbCkpO1xuICByZXR1cm4gY2FsbGJhY2tpZmllZDtcbn1cbmV4cG9ydHMuY2FsbGJhY2tpZnkgPSBjYWxsYmFja2lmeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZvckVhY2ggPSByZXF1aXJlKCdmb3ItZWFjaCcpO1xudmFyIGF2YWlsYWJsZVR5cGVkQXJyYXlzID0gcmVxdWlyZSgnYXZhaWxhYmxlLXR5cGVkLWFycmF5cycpO1xudmFyIGNhbGxCaW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kJyk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1ib3VuZCcpO1xudmFyIGdPUEQgPSByZXF1aXJlKCdnb3BkJyk7XG52YXIgZ2V0UHJvdG8gPSByZXF1aXJlKCdnZXQtcHJvdG8nKTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcblxudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiBnbG9iYWxUaGlzO1xudmFyIHR5cGVkQXJyYXlzID0gYXZhaWxhYmxlVHlwZWRBcnJheXMoKTtcblxudmFyICRzbGljZSA9IGNhbGxCb3VuZCgnU3RyaW5nLnByb3RvdHlwZS5zbGljZScpO1xuXG4vKiogQHR5cGUgezxUID0gdW5rbm93bj4oYXJyYXk6IHJlYWRvbmx5IFRbXSwgdmFsdWU6IHVua25vd24pID0+IG51bWJlcn0gKi9cbnZhciAkaW5kZXhPZiA9IGNhbGxCb3VuZCgnQXJyYXkucHJvdG90eXBlLmluZGV4T2YnLCB0cnVlKSB8fCBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0aWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIGk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiAtMTtcbn07XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3R5cGVzJykuR2V0dGVyfSBHZXR0ZXIgKi9cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGVzJykuQ2FjaGV9ICovXG52YXIgY2FjaGUgPSB7IF9fcHJvdG9fXzogbnVsbCB9O1xuaWYgKGhhc1RvU3RyaW5nVGFnICYmIGdPUEQgJiYgZ2V0UHJvdG8pIHtcblx0Zm9yRWFjaCh0eXBlZEFycmF5cywgZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0XHR2YXIgYXJyID0gbmV3IGdbdHlwZWRBcnJheV0oKTtcblx0XHRpZiAoU3ltYm9sLnRvU3RyaW5nVGFnIGluIGFyciAmJiBnZXRQcm90bykge1xuXHRcdFx0dmFyIHByb3RvID0gZ2V0UHJvdG8oYXJyKTtcblx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgVFMgd29uJ3QgbmFycm93IGluc2lkZSBhIGNsb3N1cmVcblx0XHRcdHZhciBkZXNjcmlwdG9yID0gZ09QRChwcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRcdGlmICghZGVzY3JpcHRvciAmJiBwcm90bykge1xuXHRcdFx0XHR2YXIgc3VwZXJQcm90byA9IGdldFByb3RvKHByb3RvKTtcblx0XHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBUUyB3b24ndCBuYXJyb3cgaW5zaWRlIGEgY2xvc3VyZVxuXHRcdFx0XHRkZXNjcmlwdG9yID0gZ09QRChzdXBlclByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBUT0RPOiBmaXhcblx0XHRcdGNhY2hlWyckJyArIHR5cGVkQXJyYXldID0gY2FsbEJpbmQoZGVzY3JpcHRvci5nZXQpO1xuXHRcdH1cblx0fSk7XG59IGVsc2Uge1xuXHRmb3JFYWNoKHR5cGVkQXJyYXlzLCBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuXHRcdHZhciBhcnIgPSBuZXcgZ1t0eXBlZEFycmF5XSgpO1xuXHRcdHZhciBmbiA9IGFyci5zbGljZSB8fCBhcnIuc2V0O1xuXHRcdGlmIChmbikge1xuXHRcdFx0Y2FjaGVbXG5cdFx0XHRcdC8qKiBAdHlwZSB7YCQke2ltcG9ydCgnLicpLlR5cGVkQXJyYXlOYW1lfWB9ICovICgnJCcgKyB0eXBlZEFycmF5KVxuXHRcdFx0XSA9IC8qKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGVzJykuQm91bmRTbGljZSB8IGltcG9ydCgnLi90eXBlcycpLkJvdW5kU2V0fSAqLyAoXG5cdFx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETyBGSVhNRVxuXHRcdFx0XHRjYWxsQmluZChmbilcblx0XHRcdCk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqIEB0eXBlIHsodmFsdWU6IG9iamVjdCkgPT4gZmFsc2UgfCBpbXBvcnQoJy4nKS5UeXBlZEFycmF5TmFtZX0gKi9cbnZhciB0cnlUeXBlZEFycmF5cyA9IGZ1bmN0aW9uIHRyeUFsbFR5cGVkQXJyYXlzKHZhbHVlKSB7XG5cdC8qKiBAdHlwZSB7UmV0dXJuVHlwZTx0eXBlb2YgdHJ5QWxsVHlwZWRBcnJheXM+fSAqLyB2YXIgZm91bmQgPSBmYWxzZTtcblx0Zm9yRWFjaChcblx0XHQvKiogQHR5cGUge1JlY29yZDxgXFwkJHtpbXBvcnQoJy4nKS5UeXBlZEFycmF5TmFtZX1gLCBHZXR0ZXI+fSAqLyAoY2FjaGUpLFxuXHRcdC8qKiBAdHlwZSB7KGdldHRlcjogR2V0dGVyLCBuYW1lOiBgXFwkJHtpbXBvcnQoJy4nKS5UeXBlZEFycmF5TmFtZX1gKSA9PiB2b2lkfSAqL1xuXHRcdGZ1bmN0aW9uIChnZXR0ZXIsIHR5cGVkQXJyYXkpIHtcblx0XHRcdGlmICghZm91bmQpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIGEgdGhyb3cgaXMgZmluZSBoZXJlXG5cdFx0XHRcdFx0aWYgKCckJyArIGdldHRlcih2YWx1ZSkgPT09IHR5cGVkQXJyYXkpIHtcblx0XHRcdFx0XHRcdGZvdW5kID0gLyoqIEB0eXBlIHtpbXBvcnQoJy4nKS5UeXBlZEFycmF5TmFtZX0gKi8gKCRzbGljZSh0eXBlZEFycmF5LCAxKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGNhdGNoIChlKSB7IC8qKi8gfVxuXHRcdFx0fVxuXHRcdH1cblx0KTtcblx0cmV0dXJuIGZvdW5kO1xufTtcblxuLyoqIEB0eXBlIHsodmFsdWU6IG9iamVjdCkgPT4gZmFsc2UgfCBpbXBvcnQoJy4nKS5UeXBlZEFycmF5TmFtZX0gKi9cbnZhciB0cnlTbGljZXMgPSBmdW5jdGlvbiB0cnlBbGxTbGljZXModmFsdWUpIHtcblx0LyoqIEB0eXBlIHtSZXR1cm5UeXBlPHR5cGVvZiB0cnlBbGxTbGljZXM+fSAqLyB2YXIgZm91bmQgPSBmYWxzZTtcblx0Zm9yRWFjaChcblx0XHQvKiogQHR5cGUge1JlY29yZDxgXFwkJHtpbXBvcnQoJy4nKS5UeXBlZEFycmF5TmFtZX1gLCBHZXR0ZXI+fSAqLyhjYWNoZSksXG5cdFx0LyoqIEB0eXBlIHsoZ2V0dGVyOiBHZXR0ZXIsIG5hbWU6IGBcXCQke2ltcG9ydCgnLicpLlR5cGVkQXJyYXlOYW1lfWApID0+IHZvaWR9ICovIGZ1bmN0aW9uIChnZXR0ZXIsIG5hbWUpIHtcblx0XHRcdGlmICghZm91bmQpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIGEgdGhyb3cgaXMgZmluZSBoZXJlXG5cdFx0XHRcdFx0Z2V0dGVyKHZhbHVlKTtcblx0XHRcdFx0XHRmb3VuZCA9IC8qKiBAdHlwZSB7aW1wb3J0KCcuJykuVHlwZWRBcnJheU5hbWV9ICovICgkc2xpY2UobmFtZSwgMSkpO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7IC8qKi8gfVxuXHRcdFx0fVxuXHRcdH1cblx0KTtcblx0cmV0dXJuIGZvdW5kO1xufTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSB7XG5cdGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuXHRcdHZhciB0YWcgPSAkc2xpY2UoJHRvU3RyaW5nKHZhbHVlKSwgOCwgLTEpO1xuXHRcdGlmICgkaW5kZXhPZih0eXBlZEFycmF5cywgdGFnKSA+IC0xKSB7XG5cdFx0XHRyZXR1cm4gdGFnO1xuXHRcdH1cblx0XHRpZiAodGFnICE9PSAnT2JqZWN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHQvLyBub2RlIDwgMC42IGhpdHMgaGVyZSBvbiByZWFsIFR5cGVkIEFycmF5c1xuXHRcdHJldHVybiB0cnlTbGljZXModmFsdWUpO1xuXHR9XG5cdGlmICghZ09QRCkgeyByZXR1cm4gbnVsbDsgfSAvLyB1bmtub3duIGVuZ2luZVxuXHRyZXR1cm4gdHJ5VHlwZWRBcnJheXModmFsdWUpO1xufTtcbiIsImV4cG9ydCBlbnVtIFByb3RvY29sIHtcblx0Ly8gUm9vbS1yZWxhdGVkICgxMH4xOSlcblx0SEFORFNIQUtFID0gOSxcblx0Sk9JTl9ST09NID0gMTAsXG5cdEVSUk9SID0gMTEsXG5cdExFQVZFX1JPT00gPSAxMixcblx0Uk9PTV9EQVRBID0gMTMsXG5cdFJPT01fU1RBVEUgPSAxNCxcblx0Uk9PTV9TVEFURV9QQVRDSCA9IDE1LFxuXHRST09NX0RBVEFfU0NIRU1BID0gMTYsXG5cdFJPT01fREFUQV9CWVRFUyA9IDE3LFxufVxuXG5leHBvcnQgZW51bSBDdXN0b21NZXNzYWdlVHlwZSB7XG4gICAgUG9zaXRpb25VcGRhdGUgPSA0MSxcbiAgICBDaGF0ID0gNzEsXG4gICAgU2V0R3VuID0gODgsXG4gICAgU2hvb3QgPSA2MSxcbiAgICBTaG90UmVqZWN0ZWQgPSAzOSxcbiAgICBFeHBsb3Npb24gPSA3MCxcbiAgICBSb2NrZXRLaWxsZWQgPSA4NyxcbiAgICBVc2VyRGF0YUNoYW5nZWQgPSA4MSxcbiAgICBQaW5nID0gNzUsXG4gICAgUG9uZyA9IDc4LFxuICAgIFJlcXVlc3RTcGF3biA9IDg0LFxuICAgIFNjZW5lTG9hZGVkID0gODMsXG4gICAgR290U2hvdCA9IDY5LFxuICAgIEdhbWVFbmRlZCA9IDM1LFxuICAgIFRha2VJdGVtID0gMzAsXG4gICAgVGhyb3dHcmVuYWRlID0gODksXG4gICAgR3JlbmFkZVBvc2l0aW9uVXBkYXRlID0gMzEsXG4gICAgUGlja3VwRmxhZyA9IDM4LFxuICAgIENvbGxlY3RUYWcgPSA3MyxcbiAgICBTdWJtaXRGbGFnID0gMzIsXG4gICAgRGFzaCA9IDQ2LFxuICAgIFNob3dDbGllbnROb3RpZmljYXRpb24gPSAzMyxcbiAgICBDcm91Y2ggPSA1OVxufVxuXG4iLCJpbXBvcnQgeyBTY2hlbWEsIHR5cGUsIHR5cGUgQXJyYXlTY2hlbWEsIHR5cGUgTWFwU2NoZW1hIH0gZnJvbSBcIkBjb2x5c2V1cy9zY2hlbWFcIjtcblxuLy8gcmVtZW1iZXIgdG8gdXBkYXRlIGFsb25nc2lkZSB0aGUgZ2FtZVxuXG5jbGFzcyBDb2x5VmVjdG9yMyBleHRlbmRzIFNjaGVtYSB7XG5cdEB0eXBlKFwibnVtYmVyXCIpIHg6IG51bWJlcjtcblx0QHR5cGUoXCJudW1iZXJcIikgeTogbnVtYmVyO1xuXHRAdHlwZShcIm51bWJlclwiKSB6OiBudW1iZXI7XG59XG5cbmNsYXNzIENvbHlSaWdpZCBleHRlbmRzIFNjaGVtYSB7XG5cdEB0eXBlKENvbHlWZWN0b3IzKSBwb3NpdGlvbjogQ29seVZlY3RvcjM7XG5cdEB0eXBlKFwibnVtYmVyXCIpIHJvdGF0aW9uWTogbnVtYmVyO1xuXHRAdHlwZShcImJvb2xlYW5cIikgYWlyOiBib29sZWFuO1xuXHRAdHlwZShcImludDhcIikgbmVjazogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgV2VhcG9uIGV4dGVuZHMgU2NoZW1hIHtcblx0QHR5cGUoXCJpbnQxNlwiKSB3ZWFwb25JZDogbnVtYmVyO1xuXHRAdHlwZShcImludDE2XCIpIHNraW5JZDogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgUHVibGljVXNlckRhdGEgZXh0ZW5kcyBTY2hlbWEge1xuXHRAdHlwZShcInN0cmluZ1wiKSB1c2VybmFtZTogc3RyaW5nO1xuXHRAdHlwZShcInN0cmluZ1wiKSBwZnA6IHN0cmluZztcblx0QHR5cGUoXCJzdHJpbmdcIikgY3JlYXRlZEF0OiBzdHJpbmc7XG59XG5cbmNsYXNzIFNob3QgZXh0ZW5kcyBTY2hlbWEge1xuXHRAdHlwZShcInN0cmluZ1wiKSBieUlkOiBzdHJpbmc7XG5cdEB0eXBlKFwiaW50OFwiKSBndW5JZDogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgUGxheWVyIGV4dGVuZHMgU2NoZW1hIHtcblx0QHR5cGUoeyBtYXA6IFwiaW50MTZcIiB9KSBzZWxlY3RlZEd1blNraW5zOiBNYXBTY2hlbWE8bnVtYmVyPjtcblx0QHR5cGUoXCJzdHJpbmdcIikgcGxheWVySWQ6IHN0cmluZztcblx0QHR5cGUoXCJzdHJpbmdcIikgbmlja25hbWU6IHN0cmluZztcblx0QHR5cGUoXCJ1aW50MzJcIikgc2NvcmU6IG51bWJlcjtcblx0QHR5cGUoXCJudW1iZXJcIikgZWxvOiBudW1iZXI7XG5cdEB0eXBlKFwidWludDE2XCIpIGtpbGxzOiBudW1iZXI7XG5cdEB0eXBlKFwidWludDE2XCIpIGRlYXRoczogbnVtYmVyO1xuXHRAdHlwZShcImludDE2XCIpIHNraW46IG51bWJlcjtcblx0QHR5cGUoXCJpbnQxNlwiKSBoYXQ6IG51bWJlcjtcblx0QHR5cGUoXCJpbnQxNlwiKSBiYWNrOiBudW1iZXI7XG5cdEB0eXBlKFwidWludDE2XCIpIHdlYXBvbnNDb2xsZWN0ZWQ6IG51bWJlcjtcblx0QHR5cGUoXCJ1aW50MTZcIikgbWF4S2lsbFN0cmVhazogbnVtYmVyO1xuXHRAdHlwZShDb2x5UmlnaWQpIHJpZ2lkOiBDb2x5UmlnaWQ7XG5cdEB0eXBlKFwidWludDhcIikgaGVhbHRoOiBudW1iZXI7XG5cdEB0eXBlKFwidWludDhcIikgd2VhcG9uQ2xhc3M6IG51bWJlcjtcblx0QHR5cGUoXCJib29sZWFuXCIpIHNwYXduZWQ6IGJvb2xlYW47XG5cdEB0eXBlKFwiYm9vbGVhblwiKSBkYXNoaW5nOiBib29sZWFuO1xuXHRAdHlwZShcImJvb2xlYW5cIikgY3JvdWNoaW5nOiBib29sZWFuO1xuXHRAdHlwZShcImJvb2xlYW5cIikgc2NlbmVMb2FkZWQ6IGJvb2xlYW47XG5cdEB0eXBlKFwiaW50OFwiKSBsb2NhbFdlYXBvbkluZGV4OiBudW1iZXI7XG5cdEB0eXBlKFwiaW50OFwiKSB0ZWFtOiBudW1iZXI7XG5cdEB0eXBlKFwiYm9vbGVhblwiKSBoZWFsdGhQcm90ZWN0ZWQ6IGJvb2xlYW47XG5cdEB0eXBlKFtXZWFwb25dKSBpbnZlbnRvcnk6IEFycmF5U2NoZW1hPFdlYXBvbj47XG5cdEB0eXBlKFwic3RyaW5nXCIpIHVzZXJJZDogc3RyaW5nO1xuXHRAdHlwZShQdWJsaWNVc2VyRGF0YSkgdXNlcjogUHVibGljVXNlckRhdGE7XG5cdEB0eXBlKFNob3QpIGxhc3RHb3RTaG90OiBTaG90O1xuXHRAdHlwZShcIm51bWJlclwiKSBjdXJyZW50S2lsbFN0cmVhazogbnVtYmVyO1xuXHRAdHlwZSh7IG1hcDogXCJudW1iZXJcIiB9KSBraWxsc1dpdGhXZWFwb246IE1hcFNjaGVtYTxudW1iZXI+O1xuXHRAdHlwZShcIm51bWJlclwiKSBoZWFkc2hvdHM6IG51bWJlcjtcblx0QHR5cGUoXCJudW1iZXJcIikgc3RhcnRQbGF5VGltZTogbnVtYmVyO1xuXHRAdHlwZShcIm51bWJlclwiKSBsYXN0U2hvdFRpbWU6IG51bWJlcjtcblx0QHR5cGUoXCJudW1iZXJcIikgbGFzdFNob290VGltZTogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgU3Bhd25lZEl0ZW0gZXh0ZW5kcyBTY2hlbWEge1xuXHRAdHlwZShcIm51bWJlclwiKSB4OiBudW1iZXI7XG5cdEB0eXBlKFwibnVtYmVyXCIpIHk6IG51bWJlcjtcblx0QHR5cGUoXCJudW1iZXJcIikgejogbnVtYmVyO1xuXHRAdHlwZShcInN0cmluZ1wiKSB0eXBlOiBzdHJpbmc7XG5cdEB0eXBlKFwiaW50OFwiKSByZXdhcmRQYXJhbTogbnVtYmVyO1xuXHRAdHlwZShcInN0cmluZ1wiKSBpZDogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgR3JlbmFkZSBleHRlbmRzIFNjaGVtYSB7XG5cdEB0eXBlKENvbHlWZWN0b3IzKSBwb3NpdGlvbjogQ29seVZlY3RvcjM7XG5cdEB0eXBlKENvbHlWZWN0b3IzKSByb3RhdGlvbjogQ29seVZlY3RvcjM7XG5cdEB0eXBlKFwic3RyaW5nXCIpIGdyZW5hZGVJZDogc3RyaW5nO1xuXHRAdHlwZShcImludDE2XCIpIHdlYXBvbklkOiBudW1iZXI7XG5cdEB0eXBlKFwic3RyaW5nXCIpIG93bmVyU2Vzc2lvbklkOiBzdHJpbmc7XG5cdEB0eXBlKENvbHlWZWN0b3IzKSBpbml0aWFsVmVsb2NpdHk6IENvbHlWZWN0b3IzO1xufVxuXG5leHBvcnQgY2xhc3MgQ2FwdHVyZVBvaW50IGV4dGVuZHMgU2NoZW1hIHtcblx0QHR5cGUoXCJzdHJpbmdcIikgaWQ6IHN0cmluZztcblx0QHR5cGUoQ29seVZlY3RvcjMpIHBvc2l0aW9uOiBDb2x5VmVjdG9yMztcblx0QHR5cGUoXCJpbnQ4XCIpIGNvbnRyb2xsaW5nVGVhbTogbnVtYmVyO1xuXHRAdHlwZShcImZsb2F0MzJcIikgY2FwdHVyZVByb2dyZXNzOiBudW1iZXI7XG5cdEB0eXBlKFwiZmxvYXQzMlwiKSBwcm9ncmVzc1BlclNlY29uZDogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgRmxhZyBleHRlbmRzIFNjaGVtYSB7XG5cdEB0eXBlKFwiaW50OFwiKSB0ZWFtSWQ6IG51bWJlcjtcblx0QHR5cGUoXCJib29sZWFuXCIpIGlzQXRCYXNlOiBib29sZWFuO1xuXHRAdHlwZShcInN0cmluZ1wiKSBjYXJyaWVkQnk6IHN0cmluZztcblx0QHR5cGUoQ29seVZlY3RvcjMpIHBvc2l0aW9uOiBDb2x5VmVjdG9yMztcblx0QHR5cGUoQ29seVZlY3RvcjMpIGJhc2VQb3NpdGlvbjogQ29seVZlY3RvcjM7XG59XG5cbmV4cG9ydCBjbGFzcyBEcm9wcGVkVGFnIGV4dGVuZHMgU2NoZW1hIHtcblx0QHR5cGUoXCJzdHJpbmdcIikgaWQ6IHN0cmluZztcblx0QHR5cGUoQ29seVZlY3RvcjMpIHBvc2l0aW9uOiBDb2x5VmVjdG9yMztcblx0QHR5cGUoXCJpbnQ4XCIpIHRlYW1JZDogbnVtYmVyO1xuXHRAdHlwZShcIm51bWJlclwiKSBleHBpcmVUaW1lOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBNeVJvb21TdGF0ZSBleHRlbmRzIFNjaGVtYSB7XG5cdEB0eXBlKFwiZmxvYXQzMlwiKSBhdmdFbG86IG51bWJlcjtcblx0QHR5cGUoeyBtYXA6IFBsYXllciB9KSBwbGF5ZXJzOiBNYXBTY2hlbWE8UGxheWVyPjtcblx0QHR5cGUoXCJpbnQ4XCIpIG1hcDogbnVtYmVyO1xuXHRAdHlwZShcImludDhcIikgbGlnaHQ6IG51bWJlcjtcblx0QHR5cGUoXCJpbnQ4XCIpIG1vZGU6IG51bWJlcjtcblx0QHR5cGUoXCJpbnQzMlwiKSBtYXRjaExlbmd0aDogbnVtYmVyO1xuXHRAdHlwZShcImludDMyXCIpIG1heFBsYXllcnM6IG51bWJlcjtcblx0QHR5cGUoXCJpbnQ4XCIpIHJlZ2lvbjogbnVtYmVyO1xuXHRAdHlwZShcImZsb2F0NjRcIikgc3RhcnRUaW1lOiBudW1iZXI7XG5cdEB0eXBlKHsgbWFwOiBcImludDMyXCIgfSkgdGVhbVNjb3JlczogTWFwU2NoZW1hPG51bWJlcj47XG5cdEB0eXBlKHsgbWFwOiBTcGF3bmVkSXRlbSB9KSBzcGF3bmVkSXRlbXM6IE1hcFNjaGVtYTxTcGF3bmVkSXRlbT47XG5cdEB0eXBlKHsgbWFwOiBHcmVuYWRlIH0pIGdyZW5hZGVzOiBNYXBTY2hlbWE8R3JlbmFkZT47XG5cdEB0eXBlKHsgbWFwOiBDYXB0dXJlUG9pbnQgfSkgY2FwdHVyZVBvaW50czogTWFwU2NoZW1hPENhcHR1cmVQb2ludD47XG5cdEB0eXBlKHsgbWFwOiBGbGFnIH0pIGZsYWdzOiBNYXBTY2hlbWE8RmxhZz47XG5cdEB0eXBlKHsgbWFwOiBEcm9wcGVkVGFnIH0pIGRyb3BwZWRUYWdzOiBNYXBTY2hlbWE8RHJvcHBlZFRhZz47XG5cdEB0eXBlKFwiYm9vbGVhblwiKSBhYm91dFRvU2h1dGRvd246IGJvb2xlYW47XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBwb3NzaWJsZU5hbWVzID0gcmVxdWlyZSgncG9zc2libGUtdHlwZWQtYXJyYXktbmFtZXMnKTtcblxudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiBnbG9iYWxUaGlzO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhdmFpbGFibGVUeXBlZEFycmF5cygpIHtcblx0dmFyIC8qKiBAdHlwZSB7UmV0dXJuVHlwZTx0eXBlb2YgYXZhaWxhYmxlVHlwZWRBcnJheXM+fSAqLyBvdXQgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwb3NzaWJsZU5hbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKHR5cGVvZiBnW3Bvc3NpYmxlTmFtZXNbaV1dID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0XHRvdXRbb3V0Lmxlbmd0aF0gPSBwb3NzaWJsZU5hbWVzW2ldO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gb3V0O1xufTtcbiIsImV4cG9ydCB7IFBhY2tyLCBFbmNvZGVyLCBhZGRFeHRlbnNpb24sIHBhY2ssIGVuY29kZSwgTkVWRVIsIEFMV0FZUywgREVDSU1BTF9ST1VORCwgREVDSU1BTF9GSVQsIFJFVVNFX0JVRkZFUl9NT0RFLCBSRVNFVF9CVUZGRVJfTU9ERSwgUkVTRVJWRV9TVEFSVF9TUEFDRSB9IGZyb20gJy4vcGFjay5qcydcbmV4cG9ydCB7IFVucGFja3IsIERlY29kZXIsIEMxLCB1bnBhY2ssIHVucGFja011bHRpcGxlLCBkZWNvZGUsIEZMT0FUMzJfT1BUSU9OUywgY2xlYXJTb3VyY2UsIHJvdW5kRmxvYXQzMiwgaXNOYXRpdmVBY2NlbGVyYXRpb25FbmFibGVkIH0gZnJvbSAnLi91bnBhY2suanMnXG5leHBvcnQgeyBkZWNvZGVJdGVyLCBlbmNvZGVJdGVyIH0gZnJvbSAnLi9pdGVyYXRvcnMuanMnXG5leHBvcnQgY29uc3QgdXNlUmVjb3JkcyA9IGZhbHNlXG5leHBvcnQgY29uc3QgbWFwc0FzT2JqZWN0cyA9IHRydWVcbiIsImltcG9ydCB7IFBhY2tyIH0gZnJvbSAnLi9wYWNrLmpzJ1xuaW1wb3J0IHsgVW5wYWNrciB9IGZyb20gJy4vdW5wYWNrLmpzJ1xuXG4vKipcbiAqIEdpdmVuIGFuIEl0ZXJhYmxlIGZpcnN0IGFyZ3VtZW50LCByZXR1cm5zIGFuIEl0ZXJhYmxlIHdoZXJlIGVhY2ggdmFsdWUgaXMgcGFja2VkIGFzIGEgQnVmZmVyXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgb25seSBBc3luYyBJdGVyYWJsZSwgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIGFuIEFzeW5jIEl0ZXJhYmxlLlxuICogQHBhcmFtIHtJdGVyYWJsZXxJdGVyYXRvcnxBc3luY0l0ZXJhYmxlfEFzeW5jSXRlcmF0b3J9IG9iamVjdEl0ZXJhdG9yIC0gaXRlcmFibGUgc291cmNlLCBsaWtlIGEgUmVhZGFibGUgb2JqZWN0IHN0cmVhbSwgYW4gYXJyYXksIFNldCwgb3IgY3VzdG9tIG9iamVjdFxuICogQHBhcmFtIHtvcHRpb25zfSBbb3B0aW9uc10gLSBtc2dwYWNrciBwYWNrIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtJdGVyYWJsZUl0ZXJhdG9yfFByb21pc2UuPEFzeW5jSXRlcmFibGVJdGVyYXRvcj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWNrSXRlciAob2JqZWN0SXRlcmF0b3IsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAoIW9iamVjdEl0ZXJhdG9yIHx8IHR5cGVvZiBvYmplY3RJdGVyYXRvciAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYW4gSXRlcmFibGUsIEFzeW5jIEl0ZXJhYmxlLCBvciBhIFByb21pc2UgZm9yIGFuIEFzeW5jIEl0ZXJhYmxlJylcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0SXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBwYWNrSXRlclN5bmMob2JqZWN0SXRlcmF0b3IsIG9wdGlvbnMpXG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdEl0ZXJhdG9yLnRoZW4gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG9iamVjdEl0ZXJhdG9yW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBwYWNrSXRlckFzeW5jKG9iamVjdEl0ZXJhdG9yLCBvcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBJdGVyYWJsZSwgQXN5bmMgSXRlcmFibGUsIEl0ZXJhdG9yLCBBc3luYyBJdGVyYXRvciwgb3IgYSBQcm9taXNlJylcbiAgfVxufVxuXG5mdW5jdGlvbiAqIHBhY2tJdGVyU3luYyAob2JqZWN0SXRlcmF0b3IsIG9wdGlvbnMpIHtcbiAgY29uc3QgcGFja3IgPSBuZXcgUGFja3Iob3B0aW9ucylcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiBvYmplY3RJdGVyYXRvcikge1xuICAgIHlpZWxkIHBhY2tyLnBhY2sodmFsdWUpXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gKiBwYWNrSXRlckFzeW5jIChvYmplY3RJdGVyYXRvciwgb3B0aW9ucykge1xuICBjb25zdCBwYWNrciA9IG5ldyBQYWNrcihvcHRpb25zKVxuICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIG9iamVjdEl0ZXJhdG9yKSB7XG4gICAgeWllbGQgcGFja3IucGFjayh2YWx1ZSlcbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGFuIEl0ZXJhYmxlL0l0ZXJhdG9yIGlucHV0IHdoaWNoIHlpZWxkcyBidWZmZXJzLCByZXR1cm5zIGFuIEl0ZXJhYmxlSXRlcmF0b3Igd2hpY2ggeWllbGRzIHN5bmMgZGVjb2RlZCBvYmplY3RzXG4gKiBPciwgZ2l2ZW4gYW4gQXN5bmMgSXRlcmFibGUvSXRlcmF0b3Igd2hpY2ggeWllbGRzIHByb21pc2VzIHJlc29sdmluZyBpbiBidWZmZXJzLCByZXR1cm5zIGFuIEFzeW5jSXRlcmFibGVJdGVyYXRvci5cbiAqIEBwYXJhbSB7SXRlcmFibGV8SXRlcmF0b3J8QXN5bmNJdGVyYWJsZXxBc3luY0l0ZXJhYmxlSXRlcmF0b3J9IGJ1ZmZlckl0ZXJhdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gdW5wYWNrciBvcHRpb25zXG4gKiBAcmV0dXJucyB7SXRlcmFibGVJdGVyYXRvcnxQcm9taXNlLjxBc3luY0l0ZXJhYmxlSXRlcmF0b3J9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bnBhY2tJdGVyIChidWZmZXJJdGVyYXRvciwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmICghYnVmZmVySXRlcmF0b3IgfHwgdHlwZW9mIGJ1ZmZlckl0ZXJhdG9yICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBJdGVyYWJsZSwgQXN5bmMgSXRlcmFibGUsIEl0ZXJhdG9yLCBBc3luYyBJdGVyYXRvciwgb3IgYSBwcm9taXNlJylcbiAgfVxuXG4gIGNvbnN0IHVucGFja3IgPSBuZXcgVW5wYWNrcihvcHRpb25zKVxuICBsZXQgaW5jb21wbGV0ZVxuICBjb25zdCBwYXJzZXIgPSAoY2h1bmspID0+IHtcbiAgICBsZXQgeWllbGRzXG4gICAgLy8gaWYgdGhlcmUncyBpbmNvbXBsZXRlIGRhdGEgZnJvbSBwcmV2aW91cyBjaHVuaywgY29uY2F0aW5hdGUgYW5kIHRyeSBhZ2FpblxuICAgIGlmIChpbmNvbXBsZXRlKSB7XG4gICAgICBjaHVuayA9IEJ1ZmZlci5jb25jYXQoW2luY29tcGxldGUsIGNodW5rXSlcbiAgICAgIGluY29tcGxldGUgPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgeWllbGRzID0gdW5wYWNrci51bnBhY2tNdWx0aXBsZShjaHVuaylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIuaW5jb21wbGV0ZSkge1xuICAgICAgICBpbmNvbXBsZXRlID0gY2h1bmsuc2xpY2UoZXJyLmxhc3RQb3NpdGlvbilcbiAgICAgICAgeWllbGRzID0gZXJyLnZhbHVlc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB5aWVsZHNcbiAgfVxuXG4gIGlmICh0eXBlb2YgYnVmZmVySXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiAoZnVuY3Rpb24gKiBpdGVyICgpIHtcbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgYnVmZmVySXRlcmF0b3IpIHtcbiAgICAgICAgeWllbGQgKiBwYXJzZXIodmFsdWUpXG4gICAgICB9XG4gICAgfSkoKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBidWZmZXJJdGVyYXRvcltTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gKGFzeW5jIGZ1bmN0aW9uICogaXRlciAoKSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIGJ1ZmZlckl0ZXJhdG9yKSB7XG4gICAgICAgIHlpZWxkICogcGFyc2VyKHZhbHVlKVxuICAgICAgfVxuICAgIH0pKClcbiAgfVxufVxuZXhwb3J0IGNvbnN0IGRlY29kZUl0ZXIgPSB1bnBhY2tJdGVyXG5leHBvcnQgY29uc3QgZW5jb2RlSXRlciA9IHBhY2tJdGVyIiwiaW1wb3J0IHsgVW5wYWNrciwgbXVsdDEwLCBDMVR5cGUsIHR5cGVkQXJyYXlzLCBhZGRFeHRlbnNpb24gYXMgdW5wYWNrQWRkRXh0ZW5zaW9uIH0gZnJvbSAnLi91bnBhY2suanMnXG5sZXQgdGV4dEVuY29kZXJcbnRyeSB7XG5cdHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKClcbn0gY2F0Y2ggKGVycm9yKSB7fVxubGV0IGV4dGVuc2lvbnMsIGV4dGVuc2lvbkNsYXNzZXNcbmNvbnN0IGhhc05vZGVCdWZmZXIgPSB0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJ1xuY29uc3QgQnl0ZUFycmF5QWxsb2NhdGUgPSBoYXNOb2RlQnVmZmVyID9cblx0ZnVuY3Rpb24obGVuZ3RoKSB7IHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KGxlbmd0aCkgfSA6IFVpbnQ4QXJyYXlcbmNvbnN0IEJ5dGVBcnJheSA9IGhhc05vZGVCdWZmZXIgPyBCdWZmZXIgOiBVaW50OEFycmF5XG5jb25zdCBNQVhfQlVGRkVSX1NJWkUgPSBoYXNOb2RlQnVmZmVyID8gMHgxMDAwMDAwMDAgOiAweDdmZDAwMDAwXG5sZXQgdGFyZ2V0LCBrZXlzVGFyZ2V0XG5sZXQgdGFyZ2V0Vmlld1xubGV0IHBvc2l0aW9uID0gMFxubGV0IHNhZmVFbmRcbmxldCBidW5kbGVkU3RyaW5ncyA9IG51bGxcbmxldCB3cml0ZVN0cnVjdFNsb3RzXG5jb25zdCBNQVhfQlVORExFX1NJWkUgPSAweDU1MDAgLy8gbWF4aW11bSBjaGFyYWN0ZXJzIHN1Y2ggdGhhdCB0aGUgZW5jb2RlZCBieXRlcyBmaXRzIGluIDE2IGJpdHMuXG5jb25zdCBoYXNOb25MYXRpbiA9IC9bXFx1MDA4MC1cXHVGRkZGXS9cbmV4cG9ydCBjb25zdCBSRUNPUkRfU1lNQk9MID0gU3ltYm9sKCdyZWNvcmQtaWQnKVxuZXhwb3J0IGNsYXNzIFBhY2tyIGV4dGVuZHMgVW5wYWNrciB7XG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHRzdXBlcihvcHRpb25zKVxuXHRcdHRoaXMub2Zmc2V0ID0gMFxuXHRcdGxldCB0eXBlQnVmZmVyXG5cdFx0bGV0IHN0YXJ0XG5cdFx0bGV0IGhhc1NoYXJlZFVwZGF0ZVxuXHRcdGxldCBzdHJ1Y3R1cmVzXG5cdFx0bGV0IHJlZmVyZW5jZU1hcFxuXHRcdGxldCBlbmNvZGVVdGY4ID0gQnl0ZUFycmF5LnByb3RvdHlwZS51dGY4V3JpdGUgPyBmdW5jdGlvbihzdHJpbmcsIHBvc2l0aW9uKSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0LnV0ZjhXcml0ZShzdHJpbmcsIHBvc2l0aW9uLCB0YXJnZXQuYnl0ZUxlbmd0aCAtIHBvc2l0aW9uKVxuXHRcdH0gOiAodGV4dEVuY29kZXIgJiYgdGV4dEVuY29kZXIuZW5jb2RlSW50bykgP1xuXHRcdFx0ZnVuY3Rpb24oc3RyaW5nLCBwb3NpdGlvbikge1xuXHRcdFx0XHRyZXR1cm4gdGV4dEVuY29kZXIuZW5jb2RlSW50byhzdHJpbmcsIHRhcmdldC5zdWJhcnJheShwb3NpdGlvbikpLndyaXR0ZW5cblx0XHRcdH0gOiBmYWxzZVxuXG5cdFx0bGV0IHBhY2tyID0gdGhpc1xuXHRcdGlmICghb3B0aW9ucylcblx0XHRcdG9wdGlvbnMgPSB7fVxuXHRcdGxldCBpc1NlcXVlbnRpYWwgPSBvcHRpb25zICYmIG9wdGlvbnMuc2VxdWVudGlhbFxuXHRcdGxldCBoYXNTaGFyZWRTdHJ1Y3R1cmVzID0gb3B0aW9ucy5zdHJ1Y3R1cmVzIHx8IG9wdGlvbnMuc2F2ZVN0cnVjdHVyZXNcblx0XHRsZXQgbWF4U2hhcmVkU3RydWN0dXJlcyA9IG9wdGlvbnMubWF4U2hhcmVkU3RydWN0dXJlc1xuXHRcdGlmIChtYXhTaGFyZWRTdHJ1Y3R1cmVzID09IG51bGwpXG5cdFx0XHRtYXhTaGFyZWRTdHJ1Y3R1cmVzID0gaGFzU2hhcmVkU3RydWN0dXJlcyA/IDMyIDogMFxuXHRcdGlmIChtYXhTaGFyZWRTdHJ1Y3R1cmVzID4gODE2MClcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWF4aW11bSBtYXhTaGFyZWRTdHJ1Y3R1cmUgaXMgODE2MCcpXG5cdFx0aWYgKG9wdGlvbnMuc3RydWN0dXJlZENsb25lICYmIG9wdGlvbnMubW9yZVR5cGVzID09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5tb3JlVHlwZXMgPSB0cnVlXG5cdFx0fVxuXHRcdGxldCBtYXhPd25TdHJ1Y3R1cmVzID0gb3B0aW9ucy5tYXhPd25TdHJ1Y3R1cmVzXG5cdFx0aWYgKG1heE93blN0cnVjdHVyZXMgPT0gbnVsbClcblx0XHRcdG1heE93blN0cnVjdHVyZXMgPSBoYXNTaGFyZWRTdHJ1Y3R1cmVzID8gMzIgOiA2NFxuXHRcdGlmICghdGhpcy5zdHJ1Y3R1cmVzICYmIG9wdGlvbnMudXNlUmVjb3JkcyAhPSBmYWxzZSlcblx0XHRcdHRoaXMuc3RydWN0dXJlcyA9IFtdXG5cdFx0Ly8gdHdvIGJ5dGUgcmVjb3JkIGlkcyBmb3Igc2hhcmVkIHN0cnVjdHVyZXNcblx0XHRsZXQgdXNlVHdvQnl0ZVJlY29yZHMgPSBtYXhTaGFyZWRTdHJ1Y3R1cmVzID4gMzIgfHwgKG1heE93blN0cnVjdHVyZXMgKyBtYXhTaGFyZWRTdHJ1Y3R1cmVzID4gNjQpXG5cdFx0bGV0IHNoYXJlZExpbWl0SWQgPSBtYXhTaGFyZWRTdHJ1Y3R1cmVzICsgMHg0MFxuXHRcdGxldCBtYXhTdHJ1Y3R1cmVJZCA9IG1heFNoYXJlZFN0cnVjdHVyZXMgKyBtYXhPd25TdHJ1Y3R1cmVzICsgMHg0MFxuXHRcdGlmIChtYXhTdHJ1Y3R1cmVJZCA+IDgyNTYpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWF4aW11bSBtYXhTaGFyZWRTdHJ1Y3R1cmUgKyBtYXhPd25TdHJ1Y3R1cmUgaXMgODE5MicpXG5cdFx0fVxuXHRcdGxldCByZWNvcmRJZHNUb1JlbW92ZSA9IFtdXG5cdFx0bGV0IHRyYW5zaXRpb25zQ291bnQgPSAwXG5cdFx0bGV0IHNlcmlhbGl6YXRpb25zU2luY2VUcmFuc2l0aW9uUmVidWlsZCA9IDBcblxuXHRcdHRoaXMucGFjayA9IHRoaXMuZW5jb2RlID0gZnVuY3Rpb24odmFsdWUsIGVuY29kZU9wdGlvbnMpIHtcblx0XHRcdGlmICghdGFyZ2V0KSB7XG5cdFx0XHRcdHRhcmdldCA9IG5ldyBCeXRlQXJyYXlBbGxvY2F0ZSg4MTkyKVxuXHRcdFx0XHR0YXJnZXRWaWV3ID0gdGFyZ2V0LmRhdGFWaWV3IHx8ICh0YXJnZXQuZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcodGFyZ2V0LmJ1ZmZlciwgMCwgODE5MikpXG5cdFx0XHRcdHBvc2l0aW9uID0gMFxuXHRcdFx0fVxuXHRcdFx0c2FmZUVuZCA9IHRhcmdldC5sZW5ndGggLSAxMFxuXHRcdFx0aWYgKHNhZmVFbmQgLSBwb3NpdGlvbiA8IDB4ODAwKSB7XG5cdFx0XHRcdC8vIGRvbid0IHN0YXJ0IHRvbyBjbG9zZSB0byB0aGUgZW5kLFxuXHRcdFx0XHR0YXJnZXQgPSBuZXcgQnl0ZUFycmF5QWxsb2NhdGUodGFyZ2V0Lmxlbmd0aClcblx0XHRcdFx0dGFyZ2V0VmlldyA9IHRhcmdldC5kYXRhVmlldyB8fCAodGFyZ2V0LmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHRhcmdldC5idWZmZXIsIDAsIHRhcmdldC5sZW5ndGgpKVxuXHRcdFx0XHRzYWZlRW5kID0gdGFyZ2V0Lmxlbmd0aCAtIDEwXG5cdFx0XHRcdHBvc2l0aW9uID0gMFxuXHRcdFx0fSBlbHNlXG5cdFx0XHRcdHBvc2l0aW9uID0gKHBvc2l0aW9uICsgNykgJiAweDdmZmZmZmY4IC8vIFdvcmQgYWxpZ24gdG8gbWFrZSBhbnkgZnV0dXJlIGNvcHlpbmcgb2YgdGhpcyBidWZmZXIgZmFzdGVyXG5cdFx0XHRzdGFydCA9IHBvc2l0aW9uXG5cdFx0XHRpZiAoZW5jb2RlT3B0aW9ucyAmIFJFU0VSVkVfU1RBUlRfU1BBQ0UpIHBvc2l0aW9uICs9IChlbmNvZGVPcHRpb25zICYgMHhmZilcblx0XHRcdHJlZmVyZW5jZU1hcCA9IHBhY2tyLnN0cnVjdHVyZWRDbG9uZSA/IG5ldyBNYXAoKSA6IG51bGxcblx0XHRcdGlmIChwYWNrci5idW5kbGVTdHJpbmdzICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0YnVuZGxlZFN0cmluZ3MgPSBbXVxuXHRcdFx0XHRidW5kbGVkU3RyaW5ncy5zaXplID0gSW5maW5pdHkgLy8gZm9yY2UgYSBuZXcgYnVuZGxlIHN0YXJ0IG9uIGZpcnN0IHN0cmluZ1xuXHRcdFx0fSBlbHNlXG5cdFx0XHRcdGJ1bmRsZWRTdHJpbmdzID0gbnVsbFxuXHRcdFx0c3RydWN0dXJlcyA9IHBhY2tyLnN0cnVjdHVyZXNcblx0XHRcdGlmIChzdHJ1Y3R1cmVzKSB7XG5cdFx0XHRcdGlmIChzdHJ1Y3R1cmVzLnVuaW5pdGlhbGl6ZWQpXG5cdFx0XHRcdFx0c3RydWN0dXJlcyA9IHBhY2tyLl9tZXJnZVN0cnVjdHVyZXMocGFja3IuZ2V0U3RydWN0dXJlcygpKVxuXHRcdFx0XHRsZXQgc2hhcmVkTGVuZ3RoID0gc3RydWN0dXJlcy5zaGFyZWRMZW5ndGggfHwgMFxuXHRcdFx0XHRpZiAoc2hhcmVkTGVuZ3RoID4gbWF4U2hhcmVkU3RydWN0dXJlcykge1xuXHRcdFx0XHRcdC8vaWYgKG1heFNoYXJlZFN0cnVjdHVyZXMgPD0gMzIgJiYgc3RydWN0dXJlcy5zaGFyZWRMZW5ndGggPiAzMikgLy8gVE9ETzogY291bGQgc3VwcG9ydCB0aGlzLCBidXQgd291bGQgbmVlZCB0byB1cGRhdGUgdGhlIGxpbWl0IGlkc1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignU2hhcmVkIHN0cnVjdHVyZXMgaXMgbGFyZ2VyIHRoYW4gbWF4aW11bSBzaGFyZWQgc3RydWN0dXJlcywgdHJ5IGluY3JlYXNpbmcgbWF4U2hhcmVkU3RydWN0dXJlcyB0byAnICsgc3RydWN0dXJlcy5zaGFyZWRMZW5ndGgpXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zKSB7XG5cdFx0XHRcdFx0Ly8gcmVidWlsZCBvdXIgc3RydWN0dXJlIHRyYW5zaXRpb25zXG5cdFx0XHRcdFx0c3RydWN0dXJlcy50cmFuc2l0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbClcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHNoYXJlZExlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRsZXQga2V5cyA9IHN0cnVjdHVyZXNbaV1cblx0XHRcdFx0XHRcdGlmICgha2V5cylcblx0XHRcdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0XHRcdGxldCBuZXh0VHJhbnNpdGlvbiwgdHJhbnNpdGlvbiA9IHN0cnVjdHVyZXMudHJhbnNpdGlvbnNcblx0XHRcdFx0XHRcdGZvciAobGV0IGogPSAwLCBsID0ga2V5cy5sZW5ndGg7IGogPCBsOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0bGV0IGtleSA9IGtleXNbal1cblx0XHRcdFx0XHRcdFx0bmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uW2tleV1cblx0XHRcdFx0XHRcdFx0aWYgKCFuZXh0VHJhbnNpdGlvbikge1xuXHRcdFx0XHRcdFx0XHRcdG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbltrZXldID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvblxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dHJhbnNpdGlvbltSRUNPUkRfU1lNQk9MXSA9IGkgKyAweDQwXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMubGFzdE5hbWVkU3RydWN0dXJlc0xlbmd0aCA9IHNoYXJlZExlbmd0aFxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghaXNTZXF1ZW50aWFsKSB7XG5cdFx0XHRcdFx0c3RydWN0dXJlcy5uZXh0SWQgPSBzaGFyZWRMZW5ndGggKyAweDQwXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChoYXNTaGFyZWRVcGRhdGUpXG5cdFx0XHRcdGhhc1NoYXJlZFVwZGF0ZSA9IGZhbHNlXG5cdFx0XHRsZXQgZW5jb2RpbmdFcnJvcjtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmIChwYWNrci5yYW5kb21BY2Nlc3NTdHJ1Y3R1cmUgJiYgdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdClcblx0XHRcdFx0XHR3cml0ZVN0cnVjdCh2YWx1ZSk7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRwYWNrKHZhbHVlKVxuXHRcdFx0XHRsZXQgbGFzdEJ1bmRsZSA9IGJ1bmRsZWRTdHJpbmdzO1xuXHRcdFx0XHRpZiAoYnVuZGxlZFN0cmluZ3MpXG5cdFx0XHRcdFx0d3JpdGVCdW5kbGVzKHN0YXJ0LCBwYWNrLCAwKVxuXHRcdFx0XHRpZiAocmVmZXJlbmNlTWFwICYmIHJlZmVyZW5jZU1hcC5pZHNUb0luc2VydCkge1xuXHRcdFx0XHRcdGxldCBpZHNUb0luc2VydCA9IHJlZmVyZW5jZU1hcC5pZHNUb0luc2VydC5zb3J0KChhLCBiKSA9PiBhLm9mZnNldCA+IGIub2Zmc2V0ID8gMSA6IC0xKTtcblx0XHRcdFx0XHRsZXQgaSA9IGlkc1RvSW5zZXJ0Lmxlbmd0aDtcblx0XHRcdFx0XHRsZXQgaW5jcmVtZW50UG9zaXRpb24gPSAtMTtcblx0XHRcdFx0XHR3aGlsZSAobGFzdEJ1bmRsZSAmJiBpID4gMCkge1xuXHRcdFx0XHRcdFx0bGV0IGluc2VydGlvblBvaW50ID0gaWRzVG9JbnNlcnRbLS1pXS5vZmZzZXQgKyBzdGFydDtcblx0XHRcdFx0XHRcdGlmIChpbnNlcnRpb25Qb2ludCA8IChsYXN0QnVuZGxlLnN0cmluZ3NQb3NpdGlvbiArIHN0YXJ0KSAmJiBpbmNyZW1lbnRQb3NpdGlvbiA9PT0gLTEpXG5cdFx0XHRcdFx0XHRcdGluY3JlbWVudFBvc2l0aW9uID0gMDtcblx0XHRcdFx0XHRcdGlmIChpbnNlcnRpb25Qb2ludCA+IChsYXN0QnVuZGxlLnBvc2l0aW9uICsgc3RhcnQpKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChpbmNyZW1lbnRQb3NpdGlvbiA+PSAwKVxuXHRcdFx0XHRcdFx0XHRcdGluY3JlbWVudFBvc2l0aW9uICs9IDY7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRpZiAoaW5jcmVtZW50UG9zaXRpb24gPj0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIHVwZGF0ZSB0aGUgYnVuZGxlIHJlZmVyZW5jZSBub3dcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihsYXN0QnVuZGxlLnBvc2l0aW9uICsgc3RhcnQsXG5cdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRWaWV3LmdldFVpbnQzMihsYXN0QnVuZGxlLnBvc2l0aW9uICsgc3RhcnQpICsgaW5jcmVtZW50UG9zaXRpb24pXG5cdFx0XHRcdFx0XHRcdFx0aW5jcmVtZW50UG9zaXRpb24gPSAtMTsgLy8gcmVzZXRcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRsYXN0QnVuZGxlID0gbGFzdEJ1bmRsZS5wcmV2aW91cztcblx0XHRcdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoaW5jcmVtZW50UG9zaXRpb24gPj0gMCAmJiBsYXN0QnVuZGxlKSB7XG5cdFx0XHRcdFx0XHQvLyB1cGRhdGUgdGhlIGJ1bmRsZSByZWZlcmVuY2Ugbm93XG5cdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihsYXN0QnVuZGxlLnBvc2l0aW9uICsgc3RhcnQsXG5cdFx0XHRcdFx0XHRcdHRhcmdldFZpZXcuZ2V0VWludDMyKGxhc3RCdW5kbGUucG9zaXRpb24gKyBzdGFydCkgKyBpbmNyZW1lbnRQb3NpdGlvbilcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zaXRpb24gKz0gaWRzVG9JbnNlcnQubGVuZ3RoICogNjtcblx0XHRcdFx0XHRpZiAocG9zaXRpb24gPiBzYWZlRW5kKVxuXHRcdFx0XHRcdFx0bWFrZVJvb20ocG9zaXRpb24pXG5cdFx0XHRcdFx0cGFja3Iub2Zmc2V0ID0gcG9zaXRpb25cblx0XHRcdFx0XHRsZXQgc2VyaWFsaXplZCA9IGluc2VydElkcyh0YXJnZXQuc3ViYXJyYXkoc3RhcnQsIHBvc2l0aW9uKSwgaWRzVG9JbnNlcnQpXG5cdFx0XHRcdFx0cmVmZXJlbmNlTWFwID0gbnVsbFxuXHRcdFx0XHRcdHJldHVybiBzZXJpYWxpemVkXG5cdFx0XHRcdH1cblx0XHRcdFx0cGFja3Iub2Zmc2V0ID0gcG9zaXRpb24gLy8gdXBkYXRlIHRoZSBvZmZzZXQgc28gbmV4dCBzZXJpYWxpemF0aW9uIGRvZXNuJ3Qgd3JpdGUgb3ZlciBvdXIgYnVmZmVyLCBidXQgY2FuIGNvbnRpbnVlIHdyaXRpbmcgdG8gc2FtZSBidWZmZXIgc2VxdWVudGlhbGx5XG5cdFx0XHRcdGlmIChlbmNvZGVPcHRpb25zICYgUkVVU0VfQlVGRkVSX01PREUpIHtcblx0XHRcdFx0XHR0YXJnZXQuc3RhcnQgPSBzdGFydFxuXHRcdFx0XHRcdHRhcmdldC5lbmQgPSBwb3NpdGlvblxuXHRcdFx0XHRcdHJldHVybiB0YXJnZXRcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0LnN1YmFycmF5KHN0YXJ0LCBwb3NpdGlvbikgLy8gcG9zaXRpb24gY2FuIGNoYW5nZSBpZiB3ZSBjYWxsIHBhY2sgYWdhaW4gaW4gc2F2ZVN0cnVjdHVyZXMsIHNvIHdlIGdldCB0aGUgYnVmZmVyIG5vd1xuXHRcdFx0fSBjYXRjaChlcnJvcikge1xuXHRcdFx0XHRlbmNvZGluZ0Vycm9yID0gZXJyb3I7XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0aWYgKHN0cnVjdHVyZXMpIHtcblx0XHRcdFx0XHRyZXNldFN0cnVjdHVyZXMoKTtcblx0XHRcdFx0XHRpZiAoaGFzU2hhcmVkVXBkYXRlICYmIHBhY2tyLnNhdmVTdHJ1Y3R1cmVzKSB7XG5cdFx0XHRcdFx0XHRsZXQgc2hhcmVkTGVuZ3RoID0gc3RydWN0dXJlcy5zaGFyZWRMZW5ndGggfHwgMFxuXHRcdFx0XHRcdFx0Ly8gd2UgY2FuJ3QgcmVseSBvbiBzdGFydC9lbmQgd2l0aCBSRVVTRV9CVUZGRVJfTU9ERSBzaW5jZSB0aGV5IHdpbGwgKHByb2JhYmx5KSBjaGFuZ2Ugd2hlbiB3ZSBzYXZlXG5cdFx0XHRcdFx0XHRsZXQgcmV0dXJuQnVmZmVyID0gdGFyZ2V0LnN1YmFycmF5KHN0YXJ0LCBwb3NpdGlvbilcblx0XHRcdFx0XHRcdGxldCBuZXdTaGFyZWREYXRhID0gcHJlcGFyZVN0cnVjdHVyZXMoc3RydWN0dXJlcywgcGFja3IpO1xuXHRcdFx0XHRcdFx0aWYgKCFlbmNvZGluZ0Vycm9yKSB7IC8vIFRPRE86IElmIHRoZXJlIGlzIGFuIGVuY29kaW5nIGVycm9yLCBzaG91bGQgbWFrZSB0aGUgc3RydWN0dXJlcyBhcyB1bmluaXRpYWxpemVkIHNvIHRoZXkgZ2V0IHJlYnVpbHQgbmV4dCB0aW1lXG5cdFx0XHRcdFx0XHRcdGlmIChwYWNrci5zYXZlU3RydWN0dXJlcyhuZXdTaGFyZWREYXRhLCBuZXdTaGFyZWREYXRhLmlzQ29tcGF0aWJsZSkgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gZ2V0IHVwZGF0ZWQgc3RydWN0dXJlcyBhbmQgdHJ5IGFnYWluIGlmIHRoZSB1cGRhdGUgZmFpbGVkXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHBhY2tyLnBhY2sodmFsdWUsIGVuY29kZU9wdGlvbnMpXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cGFja3IubGFzdE5hbWVkU3RydWN0dXJlc0xlbmd0aCA9IHNoYXJlZExlbmd0aFxuXHRcdFx0XHRcdFx0XHQvLyBkb24ndCBrZWVwIGxhcmdlIGJ1ZmZlcnMgYXJvdW5kXG5cdFx0XHRcdFx0XHRcdGlmICh0YXJnZXQubGVuZ3RoID4gMHg0MDAwMDAwMCkgdGFyZ2V0ID0gbnVsbFxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmV0dXJuQnVmZmVyXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGRvbid0IGtlZXAgbGFyZ2UgYnVmZmVycyBhcm91bmQsIHRoZXkgdGFrZSB0b28gbXVjaCBtZW1vcnkgYW5kIGNhdXNlIHByb2JsZW1zIChsaW1pdCBhdCAxR0IpXG5cdFx0XHRcdGlmICh0YXJnZXQubGVuZ3RoID4gMHg0MDAwMDAwMCkgdGFyZ2V0ID0gbnVsbFxuXHRcdFx0XHRpZiAoZW5jb2RlT3B0aW9ucyAmIFJFU0VUX0JVRkZFUl9NT0RFKVxuXHRcdFx0XHRcdHBvc2l0aW9uID0gc3RhcnRcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29uc3QgcmVzZXRTdHJ1Y3R1cmVzID0gKCkgPT4ge1xuXHRcdFx0aWYgKHNlcmlhbGl6YXRpb25zU2luY2VUcmFuc2l0aW9uUmVidWlsZCA8IDEwKVxuXHRcdFx0XHRzZXJpYWxpemF0aW9uc1NpbmNlVHJhbnNpdGlvblJlYnVpbGQrK1xuXHRcdFx0bGV0IHNoYXJlZExlbmd0aCA9IHN0cnVjdHVyZXMuc2hhcmVkTGVuZ3RoIHx8IDBcblx0XHRcdGlmIChzdHJ1Y3R1cmVzLmxlbmd0aCA+IHNoYXJlZExlbmd0aCAmJiAhaXNTZXF1ZW50aWFsKVxuXHRcdFx0XHRzdHJ1Y3R1cmVzLmxlbmd0aCA9IHNoYXJlZExlbmd0aFxuXHRcdFx0aWYgKHRyYW5zaXRpb25zQ291bnQgPiAxMDAwMCkge1xuXHRcdFx0XHQvLyBmb3JjZSBhIHJlYnVpbGQgb2NjYXNpb25hbGx5IGFmdGVyIGEgbG90IG9mIHRyYW5zaXRpb25zIHNvIGl0IGNhbiBnZXQgY2xlYW5lZCB1cFxuXHRcdFx0XHRzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zID0gbnVsbFxuXHRcdFx0XHRzZXJpYWxpemF0aW9uc1NpbmNlVHJhbnNpdGlvblJlYnVpbGQgPSAwXG5cdFx0XHRcdHRyYW5zaXRpb25zQ291bnQgPSAwXG5cdFx0XHRcdGlmIChyZWNvcmRJZHNUb1JlbW92ZS5sZW5ndGggPiAwKVxuXHRcdFx0XHRcdHJlY29yZElkc1RvUmVtb3ZlID0gW11cblx0XHRcdH0gZWxzZSBpZiAocmVjb3JkSWRzVG9SZW1vdmUubGVuZ3RoID4gMCAmJiAhaXNTZXF1ZW50aWFsKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gcmVjb3JkSWRzVG9SZW1vdmUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0cmVjb3JkSWRzVG9SZW1vdmVbaV1bUkVDT1JEX1NZTUJPTF0gPSAwXG5cdFx0XHRcdH1cblx0XHRcdFx0cmVjb3JkSWRzVG9SZW1vdmUgPSBbXVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjb25zdCBwYWNrQXJyYXkgPSAodmFsdWUpID0+IHtcblx0XHRcdHZhciBsZW5ndGggPSB2YWx1ZS5sZW5ndGhcblx0XHRcdGlmIChsZW5ndGggPCAweDEwKSB7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4OTAgfCBsZW5ndGhcblx0XHRcdH0gZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGRjXG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCA+PiA4XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCAmIDB4ZmZcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZGRcblx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIGxlbmd0aClcblx0XHRcdFx0cG9zaXRpb24gKz0gNFxuXHRcdFx0fVxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRwYWNrKHZhbHVlW2ldKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjb25zdCBwYWNrID0gKHZhbHVlKSA9PiB7XG5cdFx0XHRpZiAocG9zaXRpb24gPiBzYWZlRW5kKVxuXHRcdFx0XHR0YXJnZXQgPSBtYWtlUm9vbShwb3NpdGlvbilcblxuXHRcdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWVcblx0XHRcdHZhciBsZW5ndGhcblx0XHRcdGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRsZXQgc3RyTGVuZ3RoID0gdmFsdWUubGVuZ3RoXG5cdFx0XHRcdGlmIChidW5kbGVkU3RyaW5ncyAmJiBzdHJMZW5ndGggPj0gNCAmJiBzdHJMZW5ndGggPCAweDEwMDApIHtcblx0XHRcdFx0XHRpZiAoKGJ1bmRsZWRTdHJpbmdzLnNpemUgKz0gc3RyTGVuZ3RoKSA+IE1BWF9CVU5ETEVfU0laRSkge1xuXHRcdFx0XHRcdFx0bGV0IGV4dFN0YXJ0XG5cdFx0XHRcdFx0XHRsZXQgbWF4Qnl0ZXMgPSAoYnVuZGxlZFN0cmluZ3NbMF0gPyBidW5kbGVkU3RyaW5nc1swXS5sZW5ndGggKiAzICsgYnVuZGxlZFN0cmluZ3NbMV0ubGVuZ3RoIDogMCkgKyAxMFxuXHRcdFx0XHRcdFx0aWYgKHBvc2l0aW9uICsgbWF4Qnl0ZXMgPiBzYWZlRW5kKVxuXHRcdFx0XHRcdFx0XHR0YXJnZXQgPSBtYWtlUm9vbShwb3NpdGlvbiArIG1heEJ5dGVzKVxuXHRcdFx0XHRcdFx0bGV0IGxhc3RCdW5kbGVcblx0XHRcdFx0XHRcdGlmIChidW5kbGVkU3RyaW5ncy5wb3NpdGlvbikgeyAvLyBoZXJlIHdlIHVzZSB0aGUgMHg2MiBleHRlbnNpb24gdG8gd3JpdGUgdGhlIGxhc3QgYnVuZGxlIGFuZCByZXNlcnZlIHNwYWNlIGZvciB0aGUgcmVmZXJlbmNlIHBvaW50ZXIgdG8gdGhlIG5leHQvY3VycmVudCBidW5kbGVcblx0XHRcdFx0XHRcdFx0bGFzdEJ1bmRsZSA9IGJ1bmRsZWRTdHJpbmdzXG5cdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbl0gPSAweGM4IC8vIGV4dCAxNlxuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbiArPSAzIC8vIHJlc2VydmUgZm9yIHRoZSB3cml0aW5nIGJ1bmRsZSBzaXplXG5cdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4NjIgLy8gJ2InXG5cdFx0XHRcdFx0XHRcdGV4dFN0YXJ0ID0gcG9zaXRpb24gLSBzdGFydFxuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA0IC8vIHJlc2VydmUgZm9yIHdyaXRpbmcgYnVuZGxlIHJlZmVyZW5jZVxuXHRcdFx0XHRcdFx0XHR3cml0ZUJ1bmRsZXMoc3RhcnQsIHBhY2ssIDApIC8vIHdyaXRlIHRoZSBsYXN0IGJ1bmRsZXNcblx0XHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MTYoZXh0U3RhcnQgKyBzdGFydCAtIDMsIHBvc2l0aW9uIC0gc3RhcnQgLSBleHRTdGFydClcblx0XHRcdFx0XHRcdH0gZWxzZSB7IC8vIGhlcmUgd2UgdXNlIHRoZSAweDYyIGV4dGVuc2lvbiBqdXN0IHRvIHJlc2VydmUgdGhlIHNwYWNlIGZvciB0aGUgcmVmZXJlbmNlIHBvaW50ZXIgdG8gdGhlIGJ1bmRsZSAod2lsbCBiZSB1cGRhdGVkIG9uY2UgdGhlIGJ1bmRsZSBpcyB3cml0dGVuKVxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ2IC8vIGZpeGV4dCA0XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4NjIgLy8gJ2InXG5cdFx0XHRcdFx0XHRcdGV4dFN0YXJ0ID0gcG9zaXRpb24gLSBzdGFydFxuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA0IC8vIHJlc2VydmUgZm9yIHdyaXRpbmcgYnVuZGxlIHJlZmVyZW5jZVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnVuZGxlZFN0cmluZ3MgPSBbJycsICcnXSAvLyBjcmVhdGUgbmV3IG9uZXNcblx0XHRcdFx0XHRcdGJ1bmRsZWRTdHJpbmdzLnByZXZpb3VzID0gbGFzdEJ1bmRsZTtcblx0XHRcdFx0XHRcdGJ1bmRsZWRTdHJpbmdzLnNpemUgPSAwXG5cdFx0XHRcdFx0XHRidW5kbGVkU3RyaW5ncy5wb3NpdGlvbiA9IGV4dFN0YXJ0XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxldCB0d29CeXRlID0gaGFzTm9uTGF0aW4udGVzdCh2YWx1ZSlcblx0XHRcdFx0XHRidW5kbGVkU3RyaW5nc1t0d29CeXRlID8gMCA6IDFdICs9IHZhbHVlXG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjMVxuXHRcdFx0XHRcdHBhY2sodHdvQnl0ZSA/IC1zdHJMZW5ndGggOiBzdHJMZW5ndGgpO1xuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHRcdGxldCBoZWFkZXJTaXplXG5cdFx0XHRcdC8vIGZpcnN0IHdlIGVzdGltYXRlIHRoZSBoZWFkZXIgc2l6ZSwgc28gd2UgY2FuIHdyaXRlIHRvIHRoZSBjb3JyZWN0IGxvY2F0aW9uXG5cdFx0XHRcdGlmIChzdHJMZW5ndGggPCAweDIwKSB7XG5cdFx0XHRcdFx0aGVhZGVyU2l6ZSA9IDFcblx0XHRcdFx0fSBlbHNlIGlmIChzdHJMZW5ndGggPCAweDEwMCkge1xuXHRcdFx0XHRcdGhlYWRlclNpemUgPSAyXG5cdFx0XHRcdH0gZWxzZSBpZiAoc3RyTGVuZ3RoIDwgMHgxMDAwMCkge1xuXHRcdFx0XHRcdGhlYWRlclNpemUgPSAzXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aGVhZGVyU2l6ZSA9IDVcblx0XHRcdFx0fVxuXHRcdFx0XHRsZXQgbWF4Qnl0ZXMgPSBzdHJMZW5ndGggKiAzXG5cdFx0XHRcdGlmIChwb3NpdGlvbiArIG1heEJ5dGVzID4gc2FmZUVuZClcblx0XHRcdFx0XHR0YXJnZXQgPSBtYWtlUm9vbShwb3NpdGlvbiArIG1heEJ5dGVzKVxuXG5cdFx0XHRcdGlmIChzdHJMZW5ndGggPCAweDQwIHx8ICFlbmNvZGVVdGY4KSB7XG5cdFx0XHRcdFx0bGV0IGksIGMxLCBjMiwgc3RyUG9zaXRpb24gPSBwb3NpdGlvbiArIGhlYWRlclNpemVcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgc3RyTGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGMxID0gdmFsdWUuY2hhckNvZGVBdChpKVxuXHRcdFx0XHRcdFx0aWYgKGMxIDwgMHg4MCkge1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbc3RyUG9zaXRpb24rK10gPSBjMVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChjMSA8IDB4ODAwKSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxID4+IDYgfCAweGMwXG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxICYgMHgzZiB8IDB4ODBcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdFx0XHRcdChjMSAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJlxuXHRcdFx0XHRcdFx0XHQoKGMyID0gdmFsdWUuY2hhckNvZGVBdChpICsgMSkpICYgMHhmYzAwKSA9PT0gMHhkYzAwXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0YzEgPSAweDEwMDAwICsgKChjMSAmIDB4MDNmZikgPDwgMTApICsgKGMyICYgMHgwM2ZmKVxuXHRcdFx0XHRcdFx0XHRpKytcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3N0clBvc2l0aW9uKytdID0gYzEgPj4gMTggfCAweGYwXG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxID4+IDEyICYgMHgzZiB8IDB4ODBcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3N0clBvc2l0aW9uKytdID0gYzEgPj4gNiAmIDB4M2YgfCAweDgwXG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxICYgMHgzZiB8IDB4ODBcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxID4+IDEyIHwgMHhlMFxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbc3RyUG9zaXRpb24rK10gPSBjMSA+PiA2ICYgMHgzZiB8IDB4ODBcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3N0clBvc2l0aW9uKytdID0gYzEgJiAweDNmIHwgMHg4MFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsZW5ndGggPSBzdHJQb3NpdGlvbiAtIHBvc2l0aW9uIC0gaGVhZGVyU2l6ZVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxlbmd0aCA9IGVuY29kZVV0ZjgodmFsdWUsIHBvc2l0aW9uICsgaGVhZGVyU2l6ZSlcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChsZW5ndGggPCAweDIwKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhhMCB8IGxlbmd0aFxuXHRcdFx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwKSB7XG5cdFx0XHRcdFx0aWYgKGhlYWRlclNpemUgPCAyKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXQuY29weVdpdGhpbihwb3NpdGlvbiArIDIsIHBvc2l0aW9uICsgMSwgcG9zaXRpb24gKyAxICsgbGVuZ3RoKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ5XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoXG5cdFx0XHRcdH0gZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xuXHRcdFx0XHRcdGlmIChoZWFkZXJTaXplIDwgMykge1xuXHRcdFx0XHRcdFx0dGFyZ2V0LmNvcHlXaXRoaW4ocG9zaXRpb24gKyAzLCBwb3NpdGlvbiArIDIsIHBvc2l0aW9uICsgMiArIGxlbmd0aClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkYVxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCA+PiA4XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoICYgMHhmZlxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChoZWFkZXJTaXplIDwgNSkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0LmNvcHlXaXRoaW4ocG9zaXRpb24gKyA1LCBwb3NpdGlvbiArIDMsIHBvc2l0aW9uICsgMyArIGxlbmd0aClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkYlxuXHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBsZW5ndGgpXG5cdFx0XHRcdFx0cG9zaXRpb24gKz0gNFxuXHRcdFx0XHR9XG5cdFx0XHRcdHBvc2l0aW9uICs9IGxlbmd0aFxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRpZiAodmFsdWUgPj4+IDAgPT09IHZhbHVlKSB7Ly8gcG9zaXRpdmUgaW50ZWdlciwgMzItYml0IG9yIGxlc3Ncblx0XHRcdFx0XHQvLyBwb3NpdGl2ZSB1aW50XG5cdFx0XHRcdFx0aWYgKHZhbHVlIDwgMHgyMCB8fCAodmFsdWUgPCAweDgwICYmIHRoaXMudXNlUmVjb3JkcyA9PT0gZmFsc2UpIHx8ICh2YWx1ZSA8IDB4NDAgJiYgIXRoaXMucmFuZG9tQWNjZXNzU3RydWN0dXJlKSkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gdmFsdWVcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlIDwgMHgxMDApIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Y2Ncblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHZhbHVlXG5cdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA8IDB4MTAwMDApIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Y2Rcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHZhbHVlID4+IDhcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHZhbHVlICYgMHhmZlxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGNlXG5cdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiwgdmFsdWUpXG5cdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlID4+IDAgPT09IHZhbHVlKSB7IC8vIG5lZ2F0aXZlIGludGVnZXJcblx0XHRcdFx0XHRpZiAodmFsdWUgPj0gLTB4MjApIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4MTAwICsgdmFsdWVcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlID49IC0weDgwKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQwXG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSB2YWx1ZSArIDB4MTAwXG5cdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA+PSAtMHg4MDAwKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQxXG5cdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldEludDE2KHBvc2l0aW9uLCB2YWx1ZSlcblx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IDJcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkMlxuXHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRJbnQzMihwb3NpdGlvbiwgdmFsdWUpXG5cdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxldCB1c2VGbG9hdDMyXG5cdFx0XHRcdFx0aWYgKCh1c2VGbG9hdDMyID0gdGhpcy51c2VGbG9hdDMyKSA+IDAgJiYgdmFsdWUgPCAweDEwMDAwMDAwMCAmJiB2YWx1ZSA+PSAtMHg4MDAwMDAwMCkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjYVxuXHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRGbG9hdDMyKHBvc2l0aW9uLCB2YWx1ZSlcblx0XHRcdFx0XHRcdGxldCB4U2hpZnRlZFxuXHRcdFx0XHRcdFx0aWYgKHVzZUZsb2F0MzIgPCA0IHx8XG5cdFx0XHRcdFx0XHRcdFx0Ly8gdGhpcyBjaGVja3MgZm9yIHJvdW5kaW5nIG9mIG51bWJlcnMgdGhhdCB3ZXJlIGVuY29kZWQgaW4gMzItYml0IGZsb2F0IHRvIG5lYXJlc3Qgc2lnbmlmaWNhbnQgZGVjaW1hbCBkaWdpdCB0aGF0IGNvdWxkIGJlIHByZXNlcnZlZFxuXHRcdFx0XHRcdFx0XHRcdCgoeFNoaWZ0ZWQgPSB2YWx1ZSAqIG11bHQxMFsoKHRhcmdldFtwb3NpdGlvbl0gJiAweDdmKSA8PCAxKSB8ICh0YXJnZXRbcG9zaXRpb24gKyAxXSA+PiA3KV0pID4+IDApID09PSB4U2hpZnRlZCkge1xuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uLS0gLy8gbW92ZSBiYWNrIGludG8gcG9zaXRpb24gZm9yIHdyaXRpbmcgYSBkb3VibGVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjYlxuXHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0RmxvYXQ2NChwb3NpdGlvbiwgdmFsdWUpXG5cdFx0XHRcdFx0cG9zaXRpb24gKz0gOFxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0aWYgKCF2YWx1ZSlcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGMwXG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmIChyZWZlcmVuY2VNYXApIHtcblx0XHRcdFx0XHRcdGxldCByZWZlcmVlID0gcmVmZXJlbmNlTWFwLmdldCh2YWx1ZSlcblx0XHRcdFx0XHRcdGlmIChyZWZlcmVlKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghcmVmZXJlZS5pZCkge1xuXHRcdFx0XHRcdFx0XHRcdGxldCBpZHNUb0luc2VydCA9IHJlZmVyZW5jZU1hcC5pZHNUb0luc2VydCB8fCAocmVmZXJlbmNlTWFwLmlkc1RvSW5zZXJ0ID0gW10pXG5cdFx0XHRcdFx0XHRcdFx0cmVmZXJlZS5pZCA9IGlkc1RvSW5zZXJ0LnB1c2gocmVmZXJlZSlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ2IC8vIGZpeGV4dCA0XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4NzAgLy8gXCJwXCIgZm9yIHBvaW50ZXJcblx0XHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIHJlZmVyZWUuaWQpXG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IDRcblx0XHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRcdFx0cmVmZXJlbmNlTWFwLnNldCh2YWx1ZSwgeyBvZmZzZXQ6IHBvc2l0aW9uIC0gc3RhcnQgfSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGV0IGNvbnN0cnVjdG9yID0gdmFsdWUuY29uc3RydWN0b3Jcblx0XHRcdFx0XHRpZiAoY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuXHRcdFx0XHRcdFx0d3JpdGVPYmplY3QodmFsdWUpXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcblx0XHRcdFx0XHRcdHBhY2tBcnJheSh2YWx1ZSlcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGNvbnN0cnVjdG9yID09PSBNYXApIHtcblx0XHRcdFx0XHRcdGlmICh0aGlzLm1hcEFzRW1wdHlPYmplY3QpIHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ODBcblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRsZW5ndGggPSB2YWx1ZS5zaXplXG5cdFx0XHRcdFx0XHRcdGlmIChsZW5ndGggPCAweDEwKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg4MCB8IGxlbmd0aFxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGRlXG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoID4+IDhcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggJiAweGZmXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkZlxuXHRcdFx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBsZW5ndGgpXG5cdFx0XHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gNFxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGZvciAobGV0IFtrZXksIGVudHJ5VmFsdWVdIG9mIHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0cGFjayhrZXkpXG5cdFx0XHRcdFx0XHRcdFx0cGFjayhlbnRyeVZhbHVlKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gZXh0ZW5zaW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0bGV0IGV4dGVuc2lvbkNsYXNzID0gZXh0ZW5zaW9uQ2xhc3Nlc1tpXVxuXHRcdFx0XHRcdFx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBleHRlbnNpb25DbGFzcykge1xuXHRcdFx0XHRcdFx0XHRcdGxldCBleHRlbnNpb24gPSBleHRlbnNpb25zW2ldXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGV4dGVuc2lvbi53cml0ZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGV4dGVuc2lvbi50eXBlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDQgLy8gb25lIGJ5dGUgXCJ0YWdcIiBleHRlbnNpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gZXh0ZW5zaW9uLnR5cGVcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0bGV0IHdyaXRlUmVzdWx0ID0gZXh0ZW5zaW9uLndyaXRlLmNhbGwodGhpcywgdmFsdWUpXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAod3JpdGVSZXN1bHQgPT09IHZhbHVlKSB7IC8vIGF2b2lkIGluZmluaXRlIHJlY3Vyc2lvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwYWNrQXJyYXkodmFsdWUpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0d3JpdGVPYmplY3QodmFsdWUpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhY2sod3JpdGVSZXN1bHQpXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0bGV0IGN1cnJlbnRUYXJnZXQgPSB0YXJnZXRcblx0XHRcdFx0XHRcdFx0XHRsZXQgY3VycmVudFRhcmdldFZpZXcgPSB0YXJnZXRWaWV3XG5cdFx0XHRcdFx0XHRcdFx0bGV0IGN1cnJlbnRQb3NpdGlvbiA9IHBvc2l0aW9uXG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0ID0gbnVsbFxuXHRcdFx0XHRcdFx0XHRcdGxldCByZXN1bHRcblx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVzdWx0ID0gZXh0ZW5zaW9uLnBhY2suY2FsbCh0aGlzLCB2YWx1ZSwgKHNpemUpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gcmVzdG9yZSB0YXJnZXQgYW5kIHVzZSBpdFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXQgPSBjdXJyZW50VGFyZ2V0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRUYXJnZXQgPSBudWxsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IHNpemVcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKHBvc2l0aW9uID4gc2FmZUVuZClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYWtlUm9vbShwb3NpdGlvbilcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXQsIHRhcmdldFZpZXcsIHBvc2l0aW9uOiBwb3NpdGlvbiAtIHNpemVcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSwgcGFjaylcblx0XHRcdFx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gcmVzdG9yZSBjdXJyZW50IHRhcmdldCBpbmZvcm1hdGlvbiAodW5sZXNzIGFscmVhZHkgcmVzdG9yZWQpXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoY3VycmVudFRhcmdldCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXQgPSBjdXJyZW50VGFyZ2V0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldFZpZXcgPSBjdXJyZW50VGFyZ2V0Vmlld1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwb3NpdGlvbiA9IGN1cnJlbnRQb3NpdGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRzYWZlRW5kID0gdGFyZ2V0Lmxlbmd0aCAtIDEwXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmIChyZXN1bHQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChyZXN1bHQubGVuZ3RoICsgcG9zaXRpb24gPiBzYWZlRW5kKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRtYWtlUm9vbShyZXN1bHQubGVuZ3RoICsgcG9zaXRpb24pXG5cdFx0XHRcdFx0XHRcdFx0XHRwb3NpdGlvbiA9IHdyaXRlRXh0ZW5zaW9uRGF0YShyZXN1bHQsIHRhcmdldCwgcG9zaXRpb24sIGV4dGVuc2lvbi50eXBlKVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gY2hlY2sgaXNBcnJheSBhZnRlciBleHRlbnNpb25zLCBiZWNhdXNlIGV4dGVuc2lvbnMgY2FuIGV4dGVuZCBBcnJheVxuXHRcdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRcdHBhY2tBcnJheSh2YWx1ZSlcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIHVzZSB0aGlzIGFzIGFuIGFsdGVybmF0ZSBtZWNoYW5pc20gZm9yIGV4cHJlc3NpbmcgaG93IHRvIHNlcmlhbGl6ZVxuXHRcdFx0XHRcdFx0XHRpZiAodmFsdWUudG9KU09OKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QganNvbiA9IHZhbHVlLnRvSlNPTigpXG5cdFx0XHRcdFx0XHRcdFx0Ly8gaWYgZm9yIHNvbWUgcmVhc29uIHZhbHVlLnRvSlNPTiByZXR1cm5zIGl0c2VsZiBpdCdsbCBsb29wIGZvcmV2ZXJcblx0XHRcdFx0XHRcdFx0XHRpZiAoanNvbiAhPT0gdmFsdWUpXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcGFjayhqc29uKVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlcmUgaXMgYSB3cml0ZUZ1bmN0aW9uLCB1c2UgaXQsIG90aGVyd2lzZSBqdXN0IGVuY29kZSBhcyB1bmRlZmluZWRcblx0XHRcdFx0XHRcdFx0aWYgKHR5cGUgPT09ICdmdW5jdGlvbicpXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHBhY2sodGhpcy53cml0ZUZ1bmN0aW9uICYmIHRoaXMud3JpdGVGdW5jdGlvbih2YWx1ZSkpO1xuXG5cdFx0XHRcdFx0XHRcdC8vIG5vIGV4dGVuc2lvbiBmb3VuZCwgd3JpdGUgYXMgcGxhaW4gb2JqZWN0XG5cdFx0XHRcdFx0XHRcdHdyaXRlT2JqZWN0KHZhbHVlKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnYm9vbGVhbicpIHtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gdmFsdWUgPyAweGMzIDogMHhjMlxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnYmlnaW50Jykge1xuXHRcdFx0XHRpZiAodmFsdWUgPCAoQmlnSW50KDEpPDxCaWdJbnQoNjMpKSAmJiB2YWx1ZSA+PSAtKEJpZ0ludCgxKTw8QmlnSW50KDYzKSkpIHtcblx0XHRcdFx0XHQvLyB1c2UgYSBzaWduZWQgaW50IGFzIGxvbmcgYXMgaXQgZml0c1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDNcblx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldEJpZ0ludDY0KHBvc2l0aW9uLCB2YWx1ZSlcblx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA8IChCaWdJbnQoMSk8PEJpZ0ludCg2NCkpICYmIHZhbHVlID4gMCkge1xuXHRcdFx0XHRcdC8vIGlmIHdlIGNhbiBmaXQgYW4gdW5zaWduZWQgaW50LCB1c2UgdGhhdFxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Y2Zcblx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldEJpZ1VpbnQ2NChwb3NpdGlvbiwgdmFsdWUpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gb3ZlcmZsb3dcblx0XHRcdFx0XHRpZiAodGhpcy5sYXJnZUJpZ0ludFRvRmxvYXQpIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Y2Jcblx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0RmxvYXQ2NChwb3NpdGlvbiwgTnVtYmVyKHZhbHVlKSlcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMubGFyZ2VCaWdJbnRUb1N0cmluZykge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHBhY2sodmFsdWUudG9TdHJpbmcoKSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLnVzZUJpZ0ludEV4dGVuc2lvbiAmJiB2YWx1ZSA8IEJpZ0ludCgyKSoqQmlnSW50KDEwMjMpICYmIHZhbHVlID4gLShCaWdJbnQoMikqKkJpZ0ludCgxMDIzKSkpIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Yzdcblx0XHRcdFx0XHRcdHBvc2l0aW9uKys7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDQyIC8vIFwiQlwiIGZvciBCaWdJbnRcblx0XHRcdFx0XHRcdGxldCBieXRlcyA9IFtdO1xuXHRcdFx0XHRcdFx0bGV0IGFsaWduZWRTaWduO1xuXHRcdFx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdFx0XHRsZXQgYnl0ZSA9IHZhbHVlICYgQmlnSW50KDB4ZmYpO1xuXHRcdFx0XHRcdFx0XHRhbGlnbmVkU2lnbiA9IChieXRlICYgQmlnSW50KDB4ODApKSA9PT0gKHZhbHVlIDwgQmlnSW50KDApID8gQmlnSW50KDB4ODApIDogQmlnSW50KDApKTtcblx0XHRcdFx0XHRcdFx0Ynl0ZXMucHVzaChieXRlKTtcblx0XHRcdFx0XHRcdFx0dmFsdWUgPj49IEJpZ0ludCg4KTtcblx0XHRcdFx0XHRcdH0gd2hpbGUgKCEoKHZhbHVlID09PSBCaWdJbnQoMCkgfHwgdmFsdWUgPT09IEJpZ0ludCgtMSkpICYmIGFsaWduZWRTaWduKSk7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24tMl0gPSBieXRlcy5sZW5ndGg7XG5cdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gYnl0ZXMubGVuZ3RoOyBpID4gMDspIHtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gTnVtYmVyKGJ5dGVzWy0taV0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKHZhbHVlICsgJyB3YXMgdG9vIGxhcmdlIHRvIGZpdCBpbiBNZXNzYWdlUGFjayA2NC1iaXQgaW50ZWdlciBmb3JtYXQsIHVzZScgK1xuXHRcdFx0XHRcdFx0XHQnIHVzZUJpZ0ludEV4dGVuc2lvbiwgb3Igc2V0IGxhcmdlQmlnSW50VG9GbG9hdCB0byBjb252ZXJ0IHRvIGZsb2F0LTY0LCBvciBzZXQnICtcblx0XHRcdFx0XHRcdFx0JyBsYXJnZUJpZ0ludFRvU3RyaW5nIHRvIGNvbnZlcnQgdG8gc3RyaW5nJylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cG9zaXRpb24gKz0gOFxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRpZiAodGhpcy5lbmNvZGVVbmRlZmluZWRBc05pbClcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGMwXG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDQgLy8gYSBudW1iZXIgb2YgaW1wbGVtZW50YXRpb25zIHVzZSBmaXhleHQxIHdpdGggdHlwZSAwLCBkYXRhIDAgdG8gZGVub3RlIHVuZGVmaW5lZCwgc28gd2UgZm9sbG93IHN1aXRlXG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMFxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDBcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGU6ICcgKyB0eXBlKVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbnN0IHdyaXRlUGxhaW5PYmplY3QgPSAodGhpcy52YXJpYWJsZU1hcFNpemUgfHwgdGhpcy5jb2VyY2libGVLZXlBc051bWJlciB8fCB0aGlzLnNraXBWYWx1ZXMpID8gKG9iamVjdCkgPT4ge1xuXHRcdFx0Ly8gdGhpcyBtZXRob2QgaXMgc2xpZ2h0bHkgc2xvd2VyLCBidXQgZ2VuZXJhdGVzIFwicHJlZmVycmVkIHNlcmlhbGl6YXRpb25cIiAob3B0aW1hbGx5IHNtYWxsIGZvciBzbWFsbGVyIG9iamVjdHMpXG5cdFx0XHRsZXQga2V5cztcblx0XHRcdGlmICh0aGlzLnNraXBWYWx1ZXMpIHtcblx0XHRcdFx0a2V5cyA9IFtdO1xuXHRcdFx0XHRmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG5cdFx0XHRcdFx0aWYgKCh0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5ICE9PSAnZnVuY3Rpb24nIHx8IG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSAmJlxuXHRcdFx0XHRcdFx0IXRoaXMuc2tpcFZhbHVlcy5pbmNsdWRlcyhvYmplY3Rba2V5XSkpXG5cdFx0XHRcdFx0XHRrZXlzLnB1c2goa2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdClcblx0XHRcdH1cblx0XHRcdGxldCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTApIHtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg4MCB8IGxlbmd0aFxuXHRcdFx0fSBlbHNlIGlmIChsZW5ndGggPCAweDEwMDAwKSB7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZGVcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoID4+IDhcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoICYgMHhmZlxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkZlxuXHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiwgbGVuZ3RoKVxuXHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHR9XG5cdFx0XHRsZXQga2V5XG5cdFx0XHRpZiAodGhpcy5jb2VyY2libGVLZXlBc051bWJlcikge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0a2V5ID0ga2V5c1tpXVxuXHRcdFx0XHRcdGxldCBudW0gPSBOdW1iZXIoa2V5KVxuXHRcdFx0XHRcdHBhY2soaXNOYU4obnVtKSA/IGtleSA6IG51bSlcblx0XHRcdFx0XHRwYWNrKG9iamVjdFtrZXldKVxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRwYWNrKGtleSA9IGtleXNbaV0pXG5cdFx0XHRcdFx0cGFjayhvYmplY3Rba2V5XSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gOlxuXHRcdChvYmplY3QpID0+IHtcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZGUgLy8gYWx3YXlzIHVzaW5nIG1hcCAxNiwgc28gd2UgY2FuIHByZWFsbG9jYXRlIGFuZCBzZXQgdGhlIGxlbmd0aCBhZnRlcndhcmRzXG5cdFx0XHRsZXQgb2JqZWN0T2Zmc2V0ID0gcG9zaXRpb24gLSBzdGFydFxuXHRcdFx0cG9zaXRpb24gKz0gMlxuXHRcdFx0bGV0IHNpemUgPSAwXG5cdFx0XHRmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG5cdFx0XHRcdGlmICh0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5ICE9PSAnZnVuY3Rpb24nIHx8IG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0cGFjayhrZXkpXG5cdFx0XHRcdFx0cGFjayhvYmplY3Rba2V5XSlcblx0XHRcdFx0XHRzaXplKytcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHNpemUgPiAweGZmZmYpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdPYmplY3QgaXMgdG9vIGxhcmdlIHRvIHNlcmlhbGl6ZSB3aXRoIGZhc3QgMTYtYml0IG1hcCBzaXplLCcgK1xuXHRcdFx0XHQnIHVzZSB0aGUgXCJ2YXJpYWJsZU1hcFNpemVcIiBvcHRpb24gdG8gc2VyaWFsaXplIHRoaXMgb2JqZWN0Jyk7XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXRbb2JqZWN0T2Zmc2V0KysgKyBzdGFydF0gPSBzaXplID4+IDhcblx0XHRcdHRhcmdldFtvYmplY3RPZmZzZXQgKyBzdGFydF0gPSBzaXplICYgMHhmZlxuXHRcdH1cblxuXHRcdGNvbnN0IHdyaXRlUmVjb3JkID0gdGhpcy51c2VSZWNvcmRzID09PSBmYWxzZSA/IHdyaXRlUGxhaW5PYmplY3QgOlxuXHRcdChvcHRpb25zLnByb2dyZXNzaXZlUmVjb3JkcyAmJiAhdXNlVHdvQnl0ZVJlY29yZHMpID8gIC8vIHRoaXMgaXMgYWJvdXQgMiUgZmFzdGVyIGZvciBoaWdobHkgc3RhYmxlIHN0cnVjdHVyZXMsIHNpbmNlIGl0IG9ubHkgcmVxdWlyZXMgb25lIGZvci1pbiBsb29wIChidXQgbXVjaCBtb3JlIGV4cGVuc2l2ZSB3aGVuIG5ldyBzdHJ1Y3R1cmUgbmVlZHMgdG8gYmUgd3JpdHRlbilcblx0XHQob2JqZWN0KSA9PiB7XG5cdFx0XHRsZXQgbmV4dFRyYW5zaXRpb24sIHRyYW5zaXRpb24gPSBzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zIHx8IChzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKSlcblx0XHRcdGxldCBvYmplY3RPZmZzZXQgPSBwb3NpdGlvbisrIC0gc3RhcnRcblx0XHRcdGxldCB3cm90ZUtleXNcblx0XHRcdGZvciAobGV0IGtleSBpbiBvYmplY3QpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBvYmplY3QuaGFzT3duUHJvcGVydHkgIT09ICdmdW5jdGlvbicgfHwgb2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XVxuXHRcdFx0XHRcdGlmIChuZXh0VHJhbnNpdGlvbilcblx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvblxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gcmVjb3JkIGRvZXNuJ3QgZXhpc3QsIGNyZWF0ZSBmdWxsIG5ldyByZWNvcmQgYW5kIGluc2VydCBpdFxuXHRcdFx0XHRcdFx0bGV0IGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpXG5cdFx0XHRcdFx0XHRsZXQgbGFzdFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uXG5cdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gc3RydWN0dXJlcy50cmFuc2l0aW9uc1xuXHRcdFx0XHRcdFx0bGV0IG5ld1RyYW5zaXRpb25zID0gMFxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRsZXQga2V5ID0ga2V5c1tpXVxuXHRcdFx0XHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XVxuXHRcdFx0XHRcdFx0XHRpZiAoIW5leHRUcmFuc2l0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uW2tleV0gPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cdFx0XHRcdFx0XHRcdFx0bmV3VHJhbnNpdGlvbnMrK1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvblxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKG9iamVjdE9mZnNldCArIHN0YXJ0ICsgMSA9PSBwb3NpdGlvbikge1xuXHRcdFx0XHRcdFx0XHQvLyBmaXJzdCBrZXksIHNvIHdlIGRvbid0IG5lZWQgdG8gaW5zZXJ0LCB3ZSBjYW4ganVzdCB3cml0ZSByZWNvcmQgZGlyZWN0bHlcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24tLVxuXHRcdFx0XHRcdFx0XHRuZXdSZWNvcmQodHJhbnNpdGlvbiwga2V5cywgbmV3VHJhbnNpdGlvbnMpXG5cdFx0XHRcdFx0XHR9IGVsc2UgLy8gb3RoZXJ3aXNlIHdlIG5lZWQgdG8gaW5zZXJ0IHRoZSByZWNvcmQsIG1vdmluZyBleGlzdGluZyBkYXRhIGFmdGVyIHRoZSByZWNvcmRcblx0XHRcdFx0XHRcdFx0aW5zZXJ0TmV3UmVjb3JkKHRyYW5zaXRpb24sIGtleXMsIG9iamVjdE9mZnNldCwgbmV3VHJhbnNpdGlvbnMpXG5cdFx0XHRcdFx0XHR3cm90ZUtleXMgPSB0cnVlXG5cdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gbGFzdFRyYW5zaXRpb25ba2V5XVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwYWNrKG9iamVjdFtrZXldKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIXdyb3RlS2V5cykge1xuXHRcdFx0XHRsZXQgcmVjb3JkSWQgPSB0cmFuc2l0aW9uW1JFQ09SRF9TWU1CT0xdXG5cdFx0XHRcdGlmIChyZWNvcmRJZClcblx0XHRcdFx0XHR0YXJnZXRbb2JqZWN0T2Zmc2V0ICsgc3RhcnRdID0gcmVjb3JkSWRcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGluc2VydE5ld1JlY29yZCh0cmFuc2l0aW9uLCBPYmplY3Qua2V5cyhvYmplY3QpLCBvYmplY3RPZmZzZXQsIDApXG5cdFx0XHR9XG5cdFx0fSA6XG5cdFx0KG9iamVjdCkgPT4ge1xuXHRcdFx0bGV0IG5leHRUcmFuc2l0aW9uLCB0cmFuc2l0aW9uID0gc3RydWN0dXJlcy50cmFuc2l0aW9ucyB8fCAoc3RydWN0dXJlcy50cmFuc2l0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCkpXG5cdFx0XHRsZXQgbmV3VHJhbnNpdGlvbnMgPSAwXG5cdFx0XHRmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSBpZiAodHlwZW9mIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSAhPT0gJ2Z1bmN0aW9uJyB8fCBvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XVxuXHRcdFx0XHRpZiAoIW5leHRUcmFuc2l0aW9uKSB7XG5cdFx0XHRcdFx0bmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uW2tleV0gPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cdFx0XHRcdFx0bmV3VHJhbnNpdGlvbnMrK1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvblxuXHRcdFx0fVxuXHRcdFx0bGV0IHJlY29yZElkID0gdHJhbnNpdGlvbltSRUNPUkRfU1lNQk9MXVxuXHRcdFx0aWYgKHJlY29yZElkKSB7XG5cdFx0XHRcdGlmIChyZWNvcmRJZCA+PSAweDYwICYmIHVzZVR3b0J5dGVSZWNvcmRzKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gKChyZWNvcmRJZCAtPSAweDYwKSAmIDB4MWYpICsgMHg2MFxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHJlY29yZElkID4+IDVcblx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gcmVjb3JkSWRcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5ld1JlY29yZCh0cmFuc2l0aW9uLCB0cmFuc2l0aW9uLl9fa2V5c19fIHx8IE9iamVjdC5rZXlzKG9iamVjdCksIG5ld1RyYW5zaXRpb25zKVxuXHRcdFx0fVxuXHRcdFx0Ly8gbm93IHdyaXRlIHRoZSB2YWx1ZXNcblx0XHRcdGZvciAobGV0IGtleSBpbiBvYmplY3QpXG5cdFx0XHRcdGlmICh0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5ICE9PSAnZnVuY3Rpb24nIHx8IG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0cGFjayhvYmplY3Rba2V5XSlcblx0XHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGNyZWF0ZSByZWZlcmVuY2UgdG8gdXNlUmVjb3JkcyBpZiB1c2VSZWNvcmRzIGlzIGEgZnVuY3Rpb25cblx0XHRjb25zdCBjaGVja1VzZVJlY29yZHMgPSB0eXBlb2YgdGhpcy51c2VSZWNvcmRzID09ICdmdW5jdGlvbicgJiYgdGhpcy51c2VSZWNvcmRzO1xuXG5cdFx0Y29uc3Qgd3JpdGVPYmplY3QgPSBjaGVja1VzZVJlY29yZHMgPyAob2JqZWN0KSA9PiB7XG5cdFx0XHRjaGVja1VzZVJlY29yZHMob2JqZWN0KSA/IHdyaXRlUmVjb3JkKG9iamVjdCkgOiB3cml0ZVBsYWluT2JqZWN0KG9iamVjdClcblx0XHR9IDogd3JpdGVSZWNvcmRcblxuXHRcdGNvbnN0IG1ha2VSb29tID0gKGVuZCkgPT4ge1xuXHRcdFx0bGV0IG5ld1NpemVcblx0XHRcdGlmIChlbmQgPiAweDEwMDAwMDApIHtcblx0XHRcdFx0Ly8gc3BlY2lhbCBoYW5kbGluZyBmb3IgcmVhbGx5IGxhcmdlIGJ1ZmZlcnNcblx0XHRcdFx0aWYgKChlbmQgLSBzdGFydCkgPiBNQVhfQlVGRkVSX1NJWkUpXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdQYWNrZWQgYnVmZmVyIHdvdWxkIGJlIGxhcmdlciB0aGFuIG1heGltdW0gYnVmZmVyIHNpemUnKVxuXHRcdFx0XHRuZXdTaXplID0gTWF0aC5taW4oTUFYX0JVRkZFUl9TSVpFLFxuXHRcdFx0XHRcdE1hdGgucm91bmQoTWF0aC5tYXgoKGVuZCAtIHN0YXJ0KSAqIChlbmQgPiAweDQwMDAwMDAgPyAxLjI1IDogMiksIDB4NDAwMDAwKSAvIDB4MTAwMCkgKiAweDEwMDApXG5cdFx0XHR9IGVsc2UgLy8gZmFzdGVyIGhhbmRsaW5nIGZvciBzbWFsbGVyIGJ1ZmZlcnNcblx0XHRcdFx0bmV3U2l6ZSA9ICgoTWF0aC5tYXgoKGVuZCAtIHN0YXJ0KSA8PCAyLCB0YXJnZXQubGVuZ3RoIC0gMSkgPj4gMTIpICsgMSkgPDwgMTJcblx0XHRcdGxldCBuZXdCdWZmZXIgPSBuZXcgQnl0ZUFycmF5QWxsb2NhdGUobmV3U2l6ZSlcblx0XHRcdHRhcmdldFZpZXcgPSBuZXdCdWZmZXIuZGF0YVZpZXcgfHwgKG5ld0J1ZmZlci5kYXRhVmlldyA9IG5ldyBEYXRhVmlldyhuZXdCdWZmZXIuYnVmZmVyLCAwLCBuZXdTaXplKSlcblx0XHRcdGVuZCA9IE1hdGgubWluKGVuZCwgdGFyZ2V0Lmxlbmd0aClcblx0XHRcdGlmICh0YXJnZXQuY29weSlcblx0XHRcdFx0dGFyZ2V0LmNvcHkobmV3QnVmZmVyLCAwLCBzdGFydCwgZW5kKVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRuZXdCdWZmZXIuc2V0KHRhcmdldC5zbGljZShzdGFydCwgZW5kKSlcblx0XHRcdHBvc2l0aW9uIC09IHN0YXJ0XG5cdFx0XHRzdGFydCA9IDBcblx0XHRcdHNhZmVFbmQgPSBuZXdCdWZmZXIubGVuZ3RoIC0gMTBcblx0XHRcdHJldHVybiB0YXJnZXQgPSBuZXdCdWZmZXJcblx0XHR9XG5cdFx0Y29uc3QgbmV3UmVjb3JkID0gKHRyYW5zaXRpb24sIGtleXMsIG5ld1RyYW5zaXRpb25zKSA9PiB7XG5cdFx0XHRsZXQgcmVjb3JkSWQgPSBzdHJ1Y3R1cmVzLm5leHRJZFxuXHRcdFx0aWYgKCFyZWNvcmRJZClcblx0XHRcdFx0cmVjb3JkSWQgPSAweDQwXG5cdFx0XHRpZiAocmVjb3JkSWQgPCBzaGFyZWRMaW1pdElkICYmIHRoaXMuc2hvdWxkU2hhcmVTdHJ1Y3R1cmUgJiYgIXRoaXMuc2hvdWxkU2hhcmVTdHJ1Y3R1cmUoa2V5cykpIHtcblx0XHRcdFx0cmVjb3JkSWQgPSBzdHJ1Y3R1cmVzLm5leHRPd25JZFxuXHRcdFx0XHRpZiAoIShyZWNvcmRJZCA8IG1heFN0cnVjdHVyZUlkKSlcblx0XHRcdFx0XHRyZWNvcmRJZCA9IHNoYXJlZExpbWl0SWRcblx0XHRcdFx0c3RydWN0dXJlcy5uZXh0T3duSWQgPSByZWNvcmRJZCArIDFcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChyZWNvcmRJZCA+PSBtYXhTdHJ1Y3R1cmVJZCkvLyBjeWNsZSBiYWNrIGFyb3VuZFxuXHRcdFx0XHRcdHJlY29yZElkID0gc2hhcmVkTGltaXRJZFxuXHRcdFx0XHRzdHJ1Y3R1cmVzLm5leHRJZCA9IHJlY29yZElkICsgMVxuXHRcdFx0fVxuXHRcdFx0bGV0IGhpZ2hCeXRlID0ga2V5cy5oaWdoQnl0ZSA9IHJlY29yZElkID49IDB4NjAgJiYgdXNlVHdvQnl0ZVJlY29yZHMgPyAocmVjb3JkSWQgLSAweDYwKSA+PiA1IDogLTFcblx0XHRcdHRyYW5zaXRpb25bUkVDT1JEX1NZTUJPTF0gPSByZWNvcmRJZFxuXHRcdFx0dHJhbnNpdGlvbi5fX2tleXNfXyA9IGtleXNcblx0XHRcdHN0cnVjdHVyZXNbcmVjb3JkSWQgLSAweDQwXSA9IGtleXNcblxuXHRcdFx0aWYgKHJlY29yZElkIDwgc2hhcmVkTGltaXRJZCkge1xuXHRcdFx0XHRrZXlzLmlzU2hhcmVkID0gdHJ1ZVxuXHRcdFx0XHRzdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aCA9IHJlY29yZElkIC0gMHgzZlxuXHRcdFx0XHRoYXNTaGFyZWRVcGRhdGUgPSB0cnVlXG5cdFx0XHRcdGlmIChoaWdoQnl0ZSA+PSAwKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gKHJlY29yZElkICYgMHgxZikgKyAweDYwXG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gaGlnaEJ5dGVcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSByZWNvcmRJZFxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoaGlnaEJ5dGUgPj0gMCkge1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDUgLy8gZml4ZXh0IDJcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDcyIC8vIFwiclwiIHJlY29yZCBkZWZpbnRpb24gZXh0ZW5zaW9uIHR5cGVcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAocmVjb3JkSWQgJiAweDFmKSArIDB4NjBcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBoaWdoQnl0ZVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDQgLy8gZml4ZXh0IDFcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDcyIC8vIFwiclwiIHJlY29yZCBkZWZpbnRpb24gZXh0ZW5zaW9uIHR5cGVcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSByZWNvcmRJZFxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG5ld1RyYW5zaXRpb25zKVxuXHRcdFx0XHRcdHRyYW5zaXRpb25zQ291bnQgKz0gc2VyaWFsaXphdGlvbnNTaW5jZVRyYW5zaXRpb25SZWJ1aWxkICogbmV3VHJhbnNpdGlvbnNcblx0XHRcdFx0Ly8gcmVjb3JkIHRoZSByZW1vdmFsIG9mIHRoZSBpZCwgd2UgY2FuIG1haW50YWluIG91ciBzaGFyZWQgc3RydWN0dXJlXG5cdFx0XHRcdGlmIChyZWNvcmRJZHNUb1JlbW92ZS5sZW5ndGggPj0gbWF4T3duU3RydWN0dXJlcylcblx0XHRcdFx0XHRyZWNvcmRJZHNUb1JlbW92ZS5zaGlmdCgpW1JFQ09SRF9TWU1CT0xdID0gMCAvLyB3ZSBhcmUgY3ljbGluZyBiYWNrIHRocm91Z2gsIGFuZCBoYXZlIHRvIHJlbW92ZSBvbGQgb25lc1xuXHRcdFx0XHRyZWNvcmRJZHNUb1JlbW92ZS5wdXNoKHRyYW5zaXRpb24pXG5cdFx0XHRcdHBhY2soa2V5cylcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29uc3QgaW5zZXJ0TmV3UmVjb3JkID0gKHRyYW5zaXRpb24sIGtleXMsIGluc2VydGlvbk9mZnNldCwgbmV3VHJhbnNpdGlvbnMpID0+IHtcblx0XHRcdGxldCBtYWluVGFyZ2V0ID0gdGFyZ2V0XG5cdFx0XHRsZXQgbWFpblBvc2l0aW9uID0gcG9zaXRpb25cblx0XHRcdGxldCBtYWluU2FmZUVuZCA9IHNhZmVFbmRcblx0XHRcdGxldCBtYWluU3RhcnQgPSBzdGFydFxuXHRcdFx0dGFyZ2V0ID0ga2V5c1RhcmdldFxuXHRcdFx0cG9zaXRpb24gPSAwXG5cdFx0XHRzdGFydCA9IDBcblx0XHRcdGlmICghdGFyZ2V0KVxuXHRcdFx0XHRrZXlzVGFyZ2V0ID0gdGFyZ2V0ID0gbmV3IEJ5dGVBcnJheUFsbG9jYXRlKDgxOTIpXG5cdFx0XHRzYWZlRW5kID0gdGFyZ2V0Lmxlbmd0aCAtIDEwXG5cdFx0XHRuZXdSZWNvcmQodHJhbnNpdGlvbiwga2V5cywgbmV3VHJhbnNpdGlvbnMpXG5cdFx0XHRrZXlzVGFyZ2V0ID0gdGFyZ2V0XG5cdFx0XHRsZXQga2V5c1Bvc2l0aW9uID0gcG9zaXRpb25cblx0XHRcdHRhcmdldCA9IG1haW5UYXJnZXRcblx0XHRcdHBvc2l0aW9uID0gbWFpblBvc2l0aW9uXG5cdFx0XHRzYWZlRW5kID0gbWFpblNhZmVFbmRcblx0XHRcdHN0YXJ0ID0gbWFpblN0YXJ0XG5cdFx0XHRpZiAoa2V5c1Bvc2l0aW9uID4gMSkge1xuXHRcdFx0XHRsZXQgbmV3RW5kID0gcG9zaXRpb24gKyBrZXlzUG9zaXRpb24gLSAxXG5cdFx0XHRcdGlmIChuZXdFbmQgPiBzYWZlRW5kKVxuXHRcdFx0XHRcdG1ha2VSb29tKG5ld0VuZClcblx0XHRcdFx0bGV0IGluc2VydGlvblBvc2l0aW9uID0gaW5zZXJ0aW9uT2Zmc2V0ICsgc3RhcnRcblx0XHRcdFx0dGFyZ2V0LmNvcHlXaXRoaW4oaW5zZXJ0aW9uUG9zaXRpb24gKyBrZXlzUG9zaXRpb24sIGluc2VydGlvblBvc2l0aW9uICsgMSwgcG9zaXRpb24pXG5cdFx0XHRcdHRhcmdldC5zZXQoa2V5c1RhcmdldC5zbGljZSgwLCBrZXlzUG9zaXRpb24pLCBpbnNlcnRpb25Qb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gPSBuZXdFbmRcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRhcmdldFtpbnNlcnRpb25PZmZzZXQgKyBzdGFydF0gPSBrZXlzVGFyZ2V0WzBdXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbnN0IHdyaXRlU3RydWN0ID0gKG9iamVjdCkgPT4ge1xuXHRcdFx0bGV0IG5ld1Bvc2l0aW9uID0gd3JpdGVTdHJ1Y3RTbG90cyhvYmplY3QsIHRhcmdldCwgc3RhcnQsIHBvc2l0aW9uLCBzdHJ1Y3R1cmVzLCBtYWtlUm9vbSwgKHZhbHVlLCBuZXdQb3NpdGlvbiwgbm90aWZ5U2hhcmVkVXBkYXRlKSA9PiB7XG5cdFx0XHRcdGlmIChub3RpZnlTaGFyZWRVcGRhdGUpXG5cdFx0XHRcdFx0cmV0dXJuIGhhc1NoYXJlZFVwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdHBvc2l0aW9uID0gbmV3UG9zaXRpb247XG5cdFx0XHRcdGxldCBzdGFydFRhcmdldCA9IHRhcmdldDtcblx0XHRcdFx0cGFjayh2YWx1ZSk7XG5cdFx0XHRcdHJlc2V0U3RydWN0dXJlcygpO1xuXHRcdFx0XHRpZiAoc3RhcnRUYXJnZXQgIT09IHRhcmdldCkge1xuXHRcdFx0XHRcdHJldHVybiB7IHBvc2l0aW9uLCB0YXJnZXRWaWV3LCB0YXJnZXQgfTsgLy8gaW5kaWNhdGUgdGhlIGJ1ZmZlciB3YXMgcmUtYWxsb2NhdGVkXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHBvc2l0aW9uO1xuXHRcdFx0fSwgdGhpcyk7XG5cdFx0XHRpZiAobmV3UG9zaXRpb24gPT09IDApIC8vIGJhaWwgYW5kIGdvIHRvIGEgbXNncGFjayBvYmplY3Rcblx0XHRcdFx0cmV0dXJuIHdyaXRlT2JqZWN0KG9iamVjdCk7XG5cdFx0XHRwb3NpdGlvbiA9IG5ld1Bvc2l0aW9uO1xuXHRcdH1cblx0fVxuXHR1c2VCdWZmZXIoYnVmZmVyKSB7XG5cdFx0Ly8gdGhpcyBtZWFucyB3ZSBhcmUgZmluaXNoZWQgdXNpbmcgb3VyIG93biBidWZmZXIgYW5kIHdlIGNhbiB3cml0ZSBvdmVyIGl0IHNhZmVseVxuXHRcdHRhcmdldCA9IGJ1ZmZlclxuXHRcdHRhcmdldC5kYXRhVmlldyB8fCAodGFyZ2V0LmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHRhcmdldC5idWZmZXIsIHRhcmdldC5ieXRlT2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aCkpXG5cdFx0cG9zaXRpb24gPSAwXG5cdH1cblx0c2V0IHBvc2l0aW9uICh2YWx1ZSkge1xuXHRcdHBvc2l0aW9uID0gdmFsdWU7XG5cdH1cblx0Z2V0IHBvc2l0aW9uKCkge1xuXHRcdHJldHVybiBwb3NpdGlvbjtcblx0fVxuXHRzZXQgYnVmZmVyIChidWZmZXIpIHtcblx0XHR0YXJnZXQgPSBidWZmZXI7XG5cdH1cblx0Z2V0IGJ1ZmZlciAoKSB7XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fVxuXHRjbGVhclNoYXJlZERhdGEoKSB7XG5cdFx0aWYgKHRoaXMuc3RydWN0dXJlcylcblx0XHRcdHRoaXMuc3RydWN0dXJlcyA9IFtdXG5cdFx0aWYgKHRoaXMudHlwZWRTdHJ1Y3RzKVxuXHRcdFx0dGhpcy50eXBlZFN0cnVjdHMgPSBbXVxuXHR9XG59XG5cbmV4dGVuc2lvbkNsYXNzZXMgPSBbIERhdGUsIFNldCwgRXJyb3IsIFJlZ0V4cCwgQXJyYXlCdWZmZXIsIE9iamVjdC5nZXRQcm90b3R5cGVPZihVaW50OEFycmF5LnByb3RvdHlwZSkuY29uc3RydWN0b3IgLypUeXBlZEFycmF5Ki8sIEMxVHlwZSBdXG5leHRlbnNpb25zID0gW3tcblx0cGFjayhkYXRlLCBhbGxvY2F0ZUZvcldyaXRlLCBwYWNrKSB7XG5cdFx0bGV0IHNlY29uZHMgPSBkYXRlLmdldFRpbWUoKSAvIDEwMDBcblx0XHRpZiAoKHRoaXMudXNlVGltZXN0YW1wMzIgfHwgZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSA9PT0gMCkgJiYgc2Vjb25kcyA+PSAwICYmIHNlY29uZHMgPCAweDEwMDAwMDAwMCkge1xuXHRcdFx0Ly8gVGltZXN0YW1wIDMyXG5cdFx0XHRsZXQgeyB0YXJnZXQsIHRhcmdldFZpZXcsIHBvc2l0aW9ufSA9IGFsbG9jYXRlRm9yV3JpdGUoNilcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDZcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZmZcblx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBzZWNvbmRzKVxuXHRcdH0gZWxzZSBpZiAoc2Vjb25kcyA+IDAgJiYgc2Vjb25kcyA8IDB4MTAwMDAwMDAwKSB7XG5cdFx0XHQvLyBUaW1lc3RhbXAgNjRcblx0XHRcdGxldCB7IHRhcmdldCwgdGFyZ2V0VmlldywgcG9zaXRpb259ID0gYWxsb2NhdGVGb3JXcml0ZSgxMClcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDdcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZmZcblx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBkYXRlLmdldE1pbGxpc2Vjb25kcygpICogNDAwMDAwMCArICgoc2Vjb25kcyAvIDEwMDAgLyAweDEwMDAwMDAwMCkgPj4gMCkpXG5cdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiArIDQsIHNlY29uZHMpXG5cdFx0fSBlbHNlIGlmIChpc05hTihzZWNvbmRzKSkge1xuXHRcdFx0aWYgKHRoaXMub25JbnZhbGlkRGF0ZSkge1xuXHRcdFx0XHRhbGxvY2F0ZUZvcldyaXRlKDApXG5cdFx0XHRcdHJldHVybiBwYWNrKHRoaXMub25JbnZhbGlkRGF0ZSgpKVxuXHRcdFx0fVxuXHRcdFx0Ly8gSW50ZW50aW9uYWxseSBpbnZhbGlkIHRpbWVzdGFtcFxuXHRcdFx0bGV0IHsgdGFyZ2V0LCB0YXJnZXRWaWV3LCBwb3NpdGlvbn0gPSBhbGxvY2F0ZUZvcldyaXRlKDMpXG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ0XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGZmXG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGZmXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRpbWVzdGFtcCA5NlxuXHRcdFx0bGV0IHsgdGFyZ2V0LCB0YXJnZXRWaWV3LCBwb3NpdGlvbn0gPSBhbGxvY2F0ZUZvcldyaXRlKDE1KVxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjN1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMTJcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZmZcblx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBkYXRlLmdldE1pbGxpc2Vjb25kcygpICogMTAwMDAwMClcblx0XHRcdHRhcmdldFZpZXcuc2V0QmlnSW50NjQocG9zaXRpb24gKyA0LCBCaWdJbnQoTWF0aC5mbG9vcihzZWNvbmRzKSkpXG5cdFx0fVxuXHR9XG59LCB7XG5cdHBhY2soc2V0LCBhbGxvY2F0ZUZvcldyaXRlLCBwYWNrKSB7XG5cdFx0aWYgKHRoaXMuc2V0QXNFbXB0eU9iamVjdCkge1xuXHRcdFx0YWxsb2NhdGVGb3JXcml0ZSgwKTtcblx0XHRcdHJldHVybiBwYWNrKHt9KVxuXHRcdH1cblx0XHRsZXQgYXJyYXkgPSBBcnJheS5mcm9tKHNldClcblx0XHRsZXQgeyB0YXJnZXQsIHBvc2l0aW9ufSA9IGFsbG9jYXRlRm9yV3JpdGUodGhpcy5tb3JlVHlwZXMgPyAzIDogMClcblx0XHRpZiAodGhpcy5tb3JlVHlwZXMpIHtcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDRcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4NzMgLy8gJ3MnIGZvciBTZXRcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDBcblx0XHR9XG5cdFx0cGFjayhhcnJheSlcblx0fVxufSwge1xuXHRwYWNrKGVycm9yLCBhbGxvY2F0ZUZvcldyaXRlLCBwYWNrKSB7XG5cdFx0bGV0IHsgdGFyZ2V0LCBwb3NpdGlvbn0gPSBhbGxvY2F0ZUZvcldyaXRlKHRoaXMubW9yZVR5cGVzID8gMyA6IDApXG5cdFx0aWYgKHRoaXMubW9yZVR5cGVzKSB7XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ0XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDY1IC8vICdlJyBmb3IgZXJyb3Jcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDBcblx0XHR9XG5cdFx0cGFjayhbIGVycm9yLm5hbWUsIGVycm9yLm1lc3NhZ2UsIGVycm9yLmNhdXNlIF0pXG5cdH1cbn0sIHtcblx0cGFjayhyZWdleCwgYWxsb2NhdGVGb3JXcml0ZSwgcGFjaykge1xuXHRcdGxldCB7IHRhcmdldCwgcG9zaXRpb259ID0gYWxsb2NhdGVGb3JXcml0ZSh0aGlzLm1vcmVUeXBlcyA/IDMgOiAwKVxuXHRcdGlmICh0aGlzLm1vcmVUeXBlcykge1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNFxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg3OCAvLyAneCcgZm9yIHJlZ2VYcFxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMFxuXHRcdH1cblx0XHRwYWNrKFsgcmVnZXguc291cmNlLCByZWdleC5mbGFncyBdKVxuXHR9XG59LCB7XG5cdHBhY2soYXJyYXlCdWZmZXIsIGFsbG9jYXRlRm9yV3JpdGUpIHtcblx0XHRpZiAodGhpcy5tb3JlVHlwZXMpXG5cdFx0XHR3cml0ZUV4dEJ1ZmZlcihhcnJheUJ1ZmZlciwgMHgxMCwgYWxsb2NhdGVGb3JXcml0ZSlcblx0XHRlbHNlXG5cdFx0XHR3cml0ZUJ1ZmZlcihoYXNOb2RlQnVmZmVyID8gQnVmZmVyLmZyb20oYXJyYXlCdWZmZXIpIDogbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpLCBhbGxvY2F0ZUZvcldyaXRlKVxuXHR9XG59LCB7XG5cdHBhY2sodHlwZWRBcnJheSwgYWxsb2NhdGVGb3JXcml0ZSkge1xuXHRcdGxldCBjb25zdHJ1Y3RvciA9IHR5cGVkQXJyYXkuY29uc3RydWN0b3Jcblx0XHRpZiAoY29uc3RydWN0b3IgIT09IEJ5dGVBcnJheSAmJiB0aGlzLm1vcmVUeXBlcylcblx0XHRcdHdyaXRlRXh0QnVmZmVyKHR5cGVkQXJyYXksIHR5cGVkQXJyYXlzLmluZGV4T2YoY29uc3RydWN0b3IubmFtZSksIGFsbG9jYXRlRm9yV3JpdGUpXG5cdFx0ZWxzZVxuXHRcdFx0d3JpdGVCdWZmZXIodHlwZWRBcnJheSwgYWxsb2NhdGVGb3JXcml0ZSlcblx0fVxufSwge1xuXHRwYWNrKGMxLCBhbGxvY2F0ZUZvcldyaXRlKSB7IC8vIHNwZWNpZmljIDB4QzEgb2JqZWN0XG5cdFx0bGV0IHsgdGFyZ2V0LCBwb3NpdGlvbn0gPSBhbGxvY2F0ZUZvcldyaXRlKDEpXG5cdFx0dGFyZ2V0W3Bvc2l0aW9uXSA9IDB4YzFcblx0fVxufV1cblxuZnVuY3Rpb24gd3JpdGVFeHRCdWZmZXIodHlwZWRBcnJheSwgdHlwZSwgYWxsb2NhdGVGb3JXcml0ZSwgZW5jb2RlKSB7XG5cdGxldCBsZW5ndGggPSB0eXBlZEFycmF5LmJ5dGVMZW5ndGhcblx0aWYgKGxlbmd0aCArIDEgPCAweDEwMCkge1xuXHRcdHZhciB7IHRhcmdldCwgcG9zaXRpb24gfSA9IGFsbG9jYXRlRm9yV3JpdGUoNCArIGxlbmd0aClcblx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGM3XG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoICsgMVxuXHR9IGVsc2UgaWYgKGxlbmd0aCArIDEgPCAweDEwMDAwKSB7XG5cdFx0dmFyIHsgdGFyZ2V0LCBwb3NpdGlvbiB9ID0gYWxsb2NhdGVGb3JXcml0ZSg1ICsgbGVuZ3RoKVxuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Yzhcblx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAobGVuZ3RoICsgMSkgPj4gOFxuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IChsZW5ndGggKyAxKSAmIDB4ZmZcblx0fSBlbHNlIHtcblx0XHR2YXIgeyB0YXJnZXQsIHBvc2l0aW9uLCB0YXJnZXRWaWV3IH0gPSBhbGxvY2F0ZUZvcldyaXRlKDcgKyBsZW5ndGgpXG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjOVxuXHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBsZW5ndGggKyAxKSAvLyBwbHVzIG9uZSBmb3IgdGhlIHR5cGUgYnl0ZVxuXHRcdHBvc2l0aW9uICs9IDRcblx0fVxuXHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDc0IC8vIFwidFwiIGZvciB0eXBlZCBhcnJheVxuXHR0YXJnZXRbcG9zaXRpb24rK10gPSB0eXBlXG5cdGlmICghdHlwZWRBcnJheS5idWZmZXIpIHR5cGVkQXJyYXkgPSBuZXcgVWludDhBcnJheSh0eXBlZEFycmF5KVxuXHR0YXJnZXQuc2V0KG5ldyBVaW50OEFycmF5KHR5cGVkQXJyYXkuYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkuYnl0ZUxlbmd0aCksIHBvc2l0aW9uKVxufVxuZnVuY3Rpb24gd3JpdGVCdWZmZXIoYnVmZmVyLCBhbGxvY2F0ZUZvcldyaXRlKSB7XG5cdGxldCBsZW5ndGggPSBidWZmZXIuYnl0ZUxlbmd0aFxuXHR2YXIgdGFyZ2V0LCBwb3NpdGlvblxuXHRpZiAobGVuZ3RoIDwgMHgxMDApIHtcblx0XHR2YXIgeyB0YXJnZXQsIHBvc2l0aW9uIH0gPSBhbGxvY2F0ZUZvcldyaXRlKGxlbmd0aCArIDIpXG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjNFxuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aFxuXHR9IGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHR2YXIgeyB0YXJnZXQsIHBvc2l0aW9uIH0gPSBhbGxvY2F0ZUZvcldyaXRlKGxlbmd0aCArIDMpXG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjNVxuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCA+PiA4XG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoICYgMHhmZlxuXHR9IGVsc2Uge1xuXHRcdHZhciB7IHRhcmdldCwgcG9zaXRpb24sIHRhcmdldFZpZXcgfSA9IGFsbG9jYXRlRm9yV3JpdGUobGVuZ3RoICsgNSlcblx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGM2XG5cdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIGxlbmd0aClcblx0XHRwb3NpdGlvbiArPSA0XG5cdH1cblx0dGFyZ2V0LnNldChidWZmZXIsIHBvc2l0aW9uKVxufVxuXG5mdW5jdGlvbiB3cml0ZUV4dGVuc2lvbkRhdGEocmVzdWx0LCB0YXJnZXQsIHBvc2l0aW9uLCB0eXBlKSB7XG5cdGxldCBsZW5ndGggPSByZXN1bHQubGVuZ3RoXG5cdHN3aXRjaCAobGVuZ3RoKSB7XG5cdFx0Y2FzZSAxOlxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNFxuXHRcdFx0YnJlYWtcblx0XHRjYXNlIDI6XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ1XG5cdFx0XHRicmVha1xuXHRcdGNhc2UgNDpcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDZcblx0XHRcdGJyZWFrXG5cdFx0Y2FzZSA4OlxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkN1xuXHRcdFx0YnJlYWtcblx0XHRjYXNlIDE2OlxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkOFxuXHRcdFx0YnJlYWtcblx0XHRkZWZhdWx0OlxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwKSB7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Yzdcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoXG5cdFx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjOFxuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggPj4gOFxuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggJiAweGZmXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGM5XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCA+PiAyNFxuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAobGVuZ3RoID4+IDE2KSAmIDB4ZmZcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gKGxlbmd0aCA+PiA4KSAmIDB4ZmZcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoICYgMHhmZlxuXHRcdFx0fVxuXHR9XG5cdHRhcmdldFtwb3NpdGlvbisrXSA9IHR5cGVcblx0dGFyZ2V0LnNldChyZXN1bHQsIHBvc2l0aW9uKVxuXHRwb3NpdGlvbiArPSBsZW5ndGhcblx0cmV0dXJuIHBvc2l0aW9uXG59XG5cbmZ1bmN0aW9uIGluc2VydElkcyhzZXJpYWxpemVkLCBpZHNUb0luc2VydCkge1xuXHQvLyBpbnNlcnQgdGhlIGlkcyB0aGF0IG5lZWQgdG8gYmUgcmVmZXJlbmNlZCBmb3Igc3RydWN0dXJlZCBjbG9uZXNcblx0bGV0IG5leHRJZFxuXHRsZXQgZGlzdGFuY2VUb01vdmUgPSBpZHNUb0luc2VydC5sZW5ndGggKiA2XG5cdGxldCBsYXN0RW5kID0gc2VyaWFsaXplZC5sZW5ndGggLSBkaXN0YW5jZVRvTW92ZVxuXHR3aGlsZSAobmV4dElkID0gaWRzVG9JbnNlcnQucG9wKCkpIHtcblx0XHRsZXQgb2Zmc2V0ID0gbmV4dElkLm9mZnNldFxuXHRcdGxldCBpZCA9IG5leHRJZC5pZFxuXHRcdHNlcmlhbGl6ZWQuY29weVdpdGhpbihvZmZzZXQgKyBkaXN0YW5jZVRvTW92ZSwgb2Zmc2V0LCBsYXN0RW5kKVxuXHRcdGRpc3RhbmNlVG9Nb3ZlIC09IDZcblx0XHRsZXQgcG9zaXRpb24gPSBvZmZzZXQgKyBkaXN0YW5jZVRvTW92ZVxuXHRcdHNlcmlhbGl6ZWRbcG9zaXRpb24rK10gPSAweGQ2XG5cdFx0c2VyaWFsaXplZFtwb3NpdGlvbisrXSA9IDB4NjkgLy8gJ2knXG5cdFx0c2VyaWFsaXplZFtwb3NpdGlvbisrXSA9IGlkID4+IDI0XG5cdFx0c2VyaWFsaXplZFtwb3NpdGlvbisrXSA9IChpZCA+PiAxNikgJiAweGZmXG5cdFx0c2VyaWFsaXplZFtwb3NpdGlvbisrXSA9IChpZCA+PiA4KSAmIDB4ZmZcblx0XHRzZXJpYWxpemVkW3Bvc2l0aW9uKytdID0gaWQgJiAweGZmXG5cdFx0bGFzdEVuZCA9IG9mZnNldFxuXHR9XG5cdHJldHVybiBzZXJpYWxpemVkXG59XG5cbmZ1bmN0aW9uIHdyaXRlQnVuZGxlcyhzdGFydCwgcGFjaywgaW5jcmVtZW50UG9zaXRpb24pIHtcblx0aWYgKGJ1bmRsZWRTdHJpbmdzLmxlbmd0aCA+IDApIHtcblx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihidW5kbGVkU3RyaW5ncy5wb3NpdGlvbiArIHN0YXJ0LCBwb3NpdGlvbiArIGluY3JlbWVudFBvc2l0aW9uIC0gYnVuZGxlZFN0cmluZ3MucG9zaXRpb24gLSBzdGFydClcblx0XHRidW5kbGVkU3RyaW5ncy5zdHJpbmdzUG9zaXRpb24gPSBwb3NpdGlvbiAtIHN0YXJ0O1xuXHRcdGxldCB3cml0ZVN0cmluZ3MgPSBidW5kbGVkU3RyaW5nc1xuXHRcdGJ1bmRsZWRTdHJpbmdzID0gbnVsbFxuXHRcdHBhY2sod3JpdGVTdHJpbmdzWzBdKVxuXHRcdHBhY2sod3JpdGVTdHJpbmdzWzFdKVxuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRFeHRlbnNpb24oZXh0ZW5zaW9uKSB7XG5cdGlmIChleHRlbnNpb24uQ2xhc3MpIHtcblx0XHRpZiAoIWV4dGVuc2lvbi5wYWNrICYmICFleHRlbnNpb24ud3JpdGUpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0V4dGVuc2lvbiBoYXMgbm8gcGFjayBvciB3cml0ZSBmdW5jdGlvbicpXG5cdFx0aWYgKGV4dGVuc2lvbi5wYWNrICYmICFleHRlbnNpb24udHlwZSlcblx0XHRcdHRocm93IG5ldyBFcnJvcignRXh0ZW5zaW9uIGhhcyBubyB0eXBlIChudW1lcmljIGNvZGUgdG8gaWRlbnRpZnkgdGhlIGV4dGVuc2lvbiknKVxuXHRcdGV4dGVuc2lvbkNsYXNzZXMudW5zaGlmdChleHRlbnNpb24uQ2xhc3MpXG5cdFx0ZXh0ZW5zaW9ucy51bnNoaWZ0KGV4dGVuc2lvbilcblx0fVxuXHR1bnBhY2tBZGRFeHRlbnNpb24oZXh0ZW5zaW9uKVxufVxuZnVuY3Rpb24gcHJlcGFyZVN0cnVjdHVyZXMoc3RydWN0dXJlcywgcGFja3IpIHtcblx0c3RydWN0dXJlcy5pc0NvbXBhdGlibGUgPSAoZXhpc3RpbmdTdHJ1Y3R1cmVzKSA9PiB7XG5cdFx0bGV0IGNvbXBhdGlibGUgPSAhZXhpc3RpbmdTdHJ1Y3R1cmVzIHx8ICgocGFja3IubGFzdE5hbWVkU3RydWN0dXJlc0xlbmd0aCB8fCAwKSA9PT0gZXhpc3RpbmdTdHJ1Y3R1cmVzLmxlbmd0aClcblx0XHRpZiAoIWNvbXBhdGlibGUpIC8vIHdlIHdhbnQgdG8gbWVyZ2UgdGhlc2UgZXhpc3Rpbmcgc3RydWN0dXJlcyBpbW1lZGlhdGVseSBzaW5jZSB3ZSBhbHJlYWR5IGhhdmUgaXQgYW5kIHdlIGFyZSBpbiB0aGUgcmlnaHQgdHJhbnNhY3Rpb25cblx0XHRcdHBhY2tyLl9tZXJnZVN0cnVjdHVyZXMoZXhpc3RpbmdTdHJ1Y3R1cmVzKTtcblx0XHRyZXR1cm4gY29tcGF0aWJsZTtcblx0fVxuXHRyZXR1cm4gc3RydWN0dXJlc1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNldFdyaXRlU3RydWN0U2xvdHMod3JpdGVTbG90cywgbWFrZVN0cnVjdHVyZXMpIHtcblx0d3JpdGVTdHJ1Y3RTbG90cyA9IHdyaXRlU2xvdHM7XG5cdHByZXBhcmVTdHJ1Y3R1cmVzID0gbWFrZVN0cnVjdHVyZXM7XG59XG5cbmxldCBkZWZhdWx0UGFja3IgPSBuZXcgUGFja3IoeyB1c2VSZWNvcmRzOiBmYWxzZSB9KVxuZXhwb3J0IGNvbnN0IHBhY2sgPSBkZWZhdWx0UGFja3IucGFja1xuZXhwb3J0IGNvbnN0IGVuY29kZSA9IGRlZmF1bHRQYWNrci5wYWNrXG5leHBvcnQgY29uc3QgRW5jb2RlciA9IFBhY2tyXG5leHBvcnQgeyBGTE9BVDMyX09QVElPTlMgfSBmcm9tICcuL3VucGFjay5qcydcbmltcG9ydCB7IEZMT0FUMzJfT1BUSU9OUyB9IGZyb20gJy4vdW5wYWNrLmpzJ1xuZXhwb3J0IGNvbnN0IHsgTkVWRVIsIEFMV0FZUywgREVDSU1BTF9ST1VORCwgREVDSU1BTF9GSVQgfSA9IEZMT0FUMzJfT1BUSU9OU1xuZXhwb3J0IGNvbnN0IFJFVVNFX0JVRkZFUl9NT0RFID0gNTEyXG5leHBvcnQgY29uc3QgUkVTRVRfQlVGRkVSX01PREUgPSAxMDI0XG5leHBvcnQgY29uc3QgUkVTRVJWRV9TVEFSVF9TUEFDRSA9IDIwNDhcbiIsInZhciBkZWNvZGVyXG50cnkge1xuXHRkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKClcbn0gY2F0Y2goZXJyb3IpIHt9XG52YXIgc3JjXG52YXIgc3JjRW5kXG52YXIgcG9zaXRpb24gPSAwXG52YXIgYWxyZWFkeVNldFxuY29uc3QgRU1QVFlfQVJSQVkgPSBbXVxudmFyIHN0cmluZ3MgPSBFTVBUWV9BUlJBWVxudmFyIHN0cmluZ1Bvc2l0aW9uID0gMFxudmFyIGN1cnJlbnRVbnBhY2tyID0ge31cbnZhciBjdXJyZW50U3RydWN0dXJlc1xudmFyIHNyY1N0cmluZ1xudmFyIHNyY1N0cmluZ1N0YXJ0ID0gMFxudmFyIHNyY1N0cmluZ0VuZCA9IDBcbnZhciBidW5kbGVkU3RyaW5nc1xudmFyIHJlZmVyZW5jZU1hcFxudmFyIGN1cnJlbnRFeHRlbnNpb25zID0gW11cbnZhciBkYXRhVmlld1xudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuXHR1c2VSZWNvcmRzOiBmYWxzZSxcblx0bWFwc0FzT2JqZWN0czogdHJ1ZVxufVxuZXhwb3J0IGNsYXNzIEMxVHlwZSB7fVxuZXhwb3J0IGNvbnN0IEMxID0gbmV3IEMxVHlwZSgpXG5DMS5uYW1lID0gJ01lc3NhZ2VQYWNrIDB4QzEnXG52YXIgc2VxdWVudGlhbE1vZGUgPSBmYWxzZVxudmFyIGlubGluZU9iamVjdFJlYWRUaHJlc2hvbGQgPSAyXG52YXIgcmVhZFN0cnVjdCwgb25Mb2FkZWRTdHJ1Y3R1cmVzLCBvblNhdmVTdGF0ZVxudmFyIEJsb2NrZWRGdW5jdGlvbiAvLyB3ZSB1c2Ugc2VhcmNoIGFuZCByZXBsYWNlIHRvIGNoYW5nZSB0aGUgbmV4dCBjYWxsIHRvIEJsb2NrZWRGdW5jdGlvbiB0byBhdm9pZCBDU1AgaXNzdWVzIGZvclxuLy8gbm8tZXZhbCBidWlsZFxudHJ5IHtcblx0bmV3IEZ1bmN0aW9uKCcnKVxufSBjYXRjaChlcnJvcikge1xuXHQvLyBpZiBldmFsIHZhcmlhbnRzIGFyZSBub3Qgc3VwcG9ydGVkLCBkbyBub3QgY3JlYXRlIGlubGluZSBvYmplY3QgcmVhZGVycyBldmVyXG5cdGlubGluZU9iamVjdFJlYWRUaHJlc2hvbGQgPSBJbmZpbml0eVxufVxuXG5leHBvcnQgY2xhc3MgVW5wYWNrciB7XG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHRpZiAob3B0aW9ucykge1xuXHRcdFx0aWYgKG9wdGlvbnMudXNlUmVjb3JkcyA9PT0gZmFsc2UgJiYgb3B0aW9ucy5tYXBzQXNPYmplY3RzID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdG9wdGlvbnMubWFwc0FzT2JqZWN0cyA9IHRydWVcblx0XHRcdGlmIChvcHRpb25zLnNlcXVlbnRpYWwgJiYgb3B0aW9ucy50cnVzdGVkICE9PSBmYWxzZSkge1xuXHRcdFx0XHRvcHRpb25zLnRydXN0ZWQgPSB0cnVlO1xuXHRcdFx0XHRpZiAoIW9wdGlvbnMuc3RydWN0dXJlcyAmJiBvcHRpb25zLnVzZVJlY29yZHMgIT0gZmFsc2UpIHtcblx0XHRcdFx0XHRvcHRpb25zLnN0cnVjdHVyZXMgPSBbXVxuXHRcdFx0XHRcdGlmICghb3B0aW9ucy5tYXhTaGFyZWRTdHJ1Y3R1cmVzKVxuXHRcdFx0XHRcdFx0b3B0aW9ucy5tYXhTaGFyZWRTdHJ1Y3R1cmVzID0gMFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAob3B0aW9ucy5zdHJ1Y3R1cmVzKVxuXHRcdFx0XHRvcHRpb25zLnN0cnVjdHVyZXMuc2hhcmVkTGVuZ3RoID0gb3B0aW9ucy5zdHJ1Y3R1cmVzLmxlbmd0aFxuXHRcdFx0ZWxzZSBpZiAob3B0aW9ucy5nZXRTdHJ1Y3R1cmVzKSB7XG5cdFx0XHRcdChvcHRpb25zLnN0cnVjdHVyZXMgPSBbXSkudW5pbml0aWFsaXplZCA9IHRydWUgLy8gdGhpcyBpcyB3aGF0IHdlIHVzZSB0byBkZW5vdGUgYW4gdW5pbml0aWFsaXplZCBzdHJ1Y3R1cmVzXG5cdFx0XHRcdG9wdGlvbnMuc3RydWN0dXJlcy5zaGFyZWRMZW5ndGggPSAwXG5cdFx0XHR9XG5cdFx0XHRpZiAob3B0aW9ucy5pbnQ2NEFzTnVtYmVyKSB7XG5cdFx0XHRcdG9wdGlvbnMuaW50NjRBc1R5cGUgPSAnbnVtYmVyJ1xuXHRcdFx0fVxuXHRcdH1cblx0XHRPYmplY3QuYXNzaWduKHRoaXMsIG9wdGlvbnMpXG5cdH1cblx0dW5wYWNrKHNvdXJjZSwgb3B0aW9ucykge1xuXHRcdGlmIChzcmMpIHtcblx0XHRcdC8vIHJlLWVudHJhbnQgZXhlY3V0aW9uLCBzYXZlIHRoZSBzdGF0ZSBhbmQgcmVzdG9yZSBpdCBhZnRlciB3ZSBkbyB0aGlzIHVucGFja1xuXHRcdFx0cmV0dXJuIHNhdmVTdGF0ZSgoKSA9PiB7XG5cdFx0XHRcdGNsZWFyU291cmNlKClcblx0XHRcdFx0cmV0dXJuIHRoaXMgPyB0aGlzLnVucGFjayhzb3VyY2UsIG9wdGlvbnMpIDogVW5wYWNrci5wcm90b3R5cGUudW5wYWNrLmNhbGwoZGVmYXVsdE9wdGlvbnMsIHNvdXJjZSwgb3B0aW9ucylcblx0XHRcdH0pXG5cdFx0fVxuXHRcdGlmICghc291cmNlLmJ1ZmZlciAmJiBzb3VyY2UuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKVxuXHRcdFx0c291cmNlID0gdHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgPyBCdWZmZXIuZnJvbShzb3VyY2UpIDogbmV3IFVpbnQ4QXJyYXkoc291cmNlKTtcblx0XHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRzcmNFbmQgPSBvcHRpb25zLmVuZCB8fCBzb3VyY2UubGVuZ3RoXG5cdFx0XHRwb3NpdGlvbiA9IG9wdGlvbnMuc3RhcnQgfHwgMFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRwb3NpdGlvbiA9IDBcblx0XHRcdHNyY0VuZCA9IG9wdGlvbnMgPiAtMSA/IG9wdGlvbnMgOiBzb3VyY2UubGVuZ3RoXG5cdFx0fVxuXHRcdHN0cmluZ1Bvc2l0aW9uID0gMFxuXHRcdHNyY1N0cmluZ0VuZCA9IDBcblx0XHRzcmNTdHJpbmcgPSBudWxsXG5cdFx0c3RyaW5ncyA9IEVNUFRZX0FSUkFZXG5cdFx0YnVuZGxlZFN0cmluZ3MgPSBudWxsXG5cdFx0c3JjID0gc291cmNlXG5cdFx0Ly8gdGhpcyBwcm92aWRlcyBjYWNoZWQgYWNjZXNzIHRvIHRoZSBkYXRhIHZpZXcgZm9yIGEgYnVmZmVyIGlmIGl0IGlzIGdldHRpbmcgcmV1c2VkLCB3aGljaCBpcyBhIHJlY29tbWVuZFxuXHRcdC8vIHRlY2huaXF1ZSBmb3IgZ2V0dGluZyBkYXRhIGZyb20gYSBkYXRhYmFzZSB3aGVyZSBpdCBjYW4gYmUgY29waWVkIGludG8gYW4gZXhpc3RpbmcgYnVmZmVyIGluc3RlYWQgb2YgY3JlYXRpbmdcblx0XHQvLyBuZXcgb25lc1xuXHRcdHRyeSB7XG5cdFx0XHRkYXRhVmlldyA9IHNvdXJjZS5kYXRhVmlldyB8fCAoc291cmNlLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHNvdXJjZS5idWZmZXIsIHNvdXJjZS5ieXRlT2Zmc2V0LCBzb3VyY2UuYnl0ZUxlbmd0aCkpXG5cdFx0fSBjYXRjaChlcnJvcikge1xuXHRcdFx0Ly8gaWYgaXQgZG9lc24ndCBoYXZlIGEgYnVmZmVyLCBtYXliZSBpdCBpcyB0aGUgd3JvbmcgdHlwZSBvZiBvYmplY3Rcblx0XHRcdHNyYyA9IG51bGxcblx0XHRcdGlmIChzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuXHRcdFx0XHR0aHJvdyBlcnJvclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTb3VyY2UgbXVzdCBiZSBhIFVpbnQ4QXJyYXkgb3IgQnVmZmVyIGJ1dCB3YXMgYSAnICsgKChzb3VyY2UgJiYgdHlwZW9mIHNvdXJjZSA9PSAnb2JqZWN0JykgPyBzb3VyY2UuY29uc3RydWN0b3IubmFtZSA6IHR5cGVvZiBzb3VyY2UpKVxuXHRcdH1cblx0XHRpZiAodGhpcyBpbnN0YW5jZW9mIFVucGFja3IpIHtcblx0XHRcdGN1cnJlbnRVbnBhY2tyID0gdGhpc1xuXHRcdFx0aWYgKHRoaXMuc3RydWN0dXJlcykge1xuXHRcdFx0XHRjdXJyZW50U3RydWN0dXJlcyA9IHRoaXMuc3RydWN0dXJlc1xuXHRcdFx0XHRyZXR1cm4gY2hlY2tlZFJlYWQob3B0aW9ucylcblx0XHRcdH0gZWxzZSBpZiAoIWN1cnJlbnRTdHJ1Y3R1cmVzIHx8IGN1cnJlbnRTdHJ1Y3R1cmVzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Y3VycmVudFN0cnVjdHVyZXMgPSBbXVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJyZW50VW5wYWNrciA9IGRlZmF1bHRPcHRpb25zXG5cdFx0XHRpZiAoIWN1cnJlbnRTdHJ1Y3R1cmVzIHx8IGN1cnJlbnRTdHJ1Y3R1cmVzLmxlbmd0aCA+IDApXG5cdFx0XHRcdGN1cnJlbnRTdHJ1Y3R1cmVzID0gW11cblx0XHR9XG5cdFx0cmV0dXJuIGNoZWNrZWRSZWFkKG9wdGlvbnMpXG5cdH1cblx0dW5wYWNrTXVsdGlwbGUoc291cmNlLCBmb3JFYWNoKSB7XG5cdFx0bGV0IHZhbHVlcywgbGFzdFBvc2l0aW9uID0gMFxuXHRcdHRyeSB7XG5cdFx0XHRzZXF1ZW50aWFsTW9kZSA9IHRydWVcblx0XHRcdGxldCBzaXplID0gc291cmNlLmxlbmd0aFxuXHRcdFx0bGV0IHZhbHVlID0gdGhpcyA/IHRoaXMudW5wYWNrKHNvdXJjZSwgc2l6ZSkgOiBkZWZhdWx0VW5wYWNrci51bnBhY2soc291cmNlLCBzaXplKVxuXHRcdFx0aWYgKGZvckVhY2gpIHtcblx0XHRcdFx0aWYgKGZvckVhY2godmFsdWUsIGxhc3RQb3NpdGlvbiwgcG9zaXRpb24pID09PSBmYWxzZSkgcmV0dXJuO1xuXHRcdFx0XHR3aGlsZShwb3NpdGlvbiA8IHNpemUpIHtcblx0XHRcdFx0XHRsYXN0UG9zaXRpb24gPSBwb3NpdGlvblxuXHRcdFx0XHRcdGlmIChmb3JFYWNoKGNoZWNrZWRSZWFkKCksIGxhc3RQb3NpdGlvbiwgcG9zaXRpb24pID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dmFsdWVzID0gWyB2YWx1ZSBdXG5cdFx0XHRcdHdoaWxlKHBvc2l0aW9uIDwgc2l6ZSkge1xuXHRcdFx0XHRcdGxhc3RQb3NpdGlvbiA9IHBvc2l0aW9uXG5cdFx0XHRcdFx0dmFsdWVzLnB1c2goY2hlY2tlZFJlYWQoKSlcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzXG5cdFx0XHR9XG5cdFx0fSBjYXRjaChlcnJvcikge1xuXHRcdFx0ZXJyb3IubGFzdFBvc2l0aW9uID0gbGFzdFBvc2l0aW9uXG5cdFx0XHRlcnJvci52YWx1ZXMgPSB2YWx1ZXNcblx0XHRcdHRocm93IGVycm9yXG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHNlcXVlbnRpYWxNb2RlID0gZmFsc2Vcblx0XHRcdGNsZWFyU291cmNlKClcblx0XHR9XG5cdH1cblx0X21lcmdlU3RydWN0dXJlcyhsb2FkZWRTdHJ1Y3R1cmVzLCBleGlzdGluZ1N0cnVjdHVyZXMpIHtcblx0XHRpZiAob25Mb2FkZWRTdHJ1Y3R1cmVzKVxuXHRcdFx0bG9hZGVkU3RydWN0dXJlcyA9IG9uTG9hZGVkU3RydWN0dXJlcy5jYWxsKHRoaXMsIGxvYWRlZFN0cnVjdHVyZXMpO1xuXHRcdGxvYWRlZFN0cnVjdHVyZXMgPSBsb2FkZWRTdHJ1Y3R1cmVzIHx8IFtdXG5cdFx0aWYgKE9iamVjdC5pc0Zyb3plbihsb2FkZWRTdHJ1Y3R1cmVzKSlcblx0XHRcdGxvYWRlZFN0cnVjdHVyZXMgPSBsb2FkZWRTdHJ1Y3R1cmVzLm1hcChzdHJ1Y3R1cmUgPT4gc3RydWN0dXJlLnNsaWNlKDApKVxuXHRcdGZvciAobGV0IGkgPSAwLCBsID0gbG9hZGVkU3RydWN0dXJlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGxldCBzdHJ1Y3R1cmUgPSBsb2FkZWRTdHJ1Y3R1cmVzW2ldXG5cdFx0XHRpZiAoc3RydWN0dXJlKSB7XG5cdFx0XHRcdHN0cnVjdHVyZS5pc1NoYXJlZCA9IHRydWVcblx0XHRcdFx0aWYgKGkgPj0gMzIpXG5cdFx0XHRcdFx0c3RydWN0dXJlLmhpZ2hCeXRlID0gKGkgLSAzMikgPj4gNVxuXHRcdFx0fVxuXHRcdH1cblx0XHRsb2FkZWRTdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aCA9IGxvYWRlZFN0cnVjdHVyZXMubGVuZ3RoXG5cdFx0Zm9yIChsZXQgaWQgaW4gZXhpc3RpbmdTdHJ1Y3R1cmVzIHx8IFtdKSB7XG5cdFx0XHRpZiAoaWQgPj0gMCkge1xuXHRcdFx0XHRsZXQgc3RydWN0dXJlID0gbG9hZGVkU3RydWN0dXJlc1tpZF1cblx0XHRcdFx0bGV0IGV4aXN0aW5nID0gZXhpc3RpbmdTdHJ1Y3R1cmVzW2lkXVxuXHRcdFx0XHRpZiAoZXhpc3RpbmcpIHtcblx0XHRcdFx0XHRpZiAoc3RydWN0dXJlKVxuXHRcdFx0XHRcdFx0KGxvYWRlZFN0cnVjdHVyZXMucmVzdG9yZVN0cnVjdHVyZXMgfHwgKGxvYWRlZFN0cnVjdHVyZXMucmVzdG9yZVN0cnVjdHVyZXMgPSBbXSkpW2lkXSA9IHN0cnVjdHVyZVxuXHRcdFx0XHRcdGxvYWRlZFN0cnVjdHVyZXNbaWRdID0gZXhpc3Rpbmdcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5zdHJ1Y3R1cmVzID0gbG9hZGVkU3RydWN0dXJlc1xuXHR9XG5cdGRlY29kZShzb3VyY2UsIG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gdGhpcy51bnBhY2soc291cmNlLCBvcHRpb25zKVxuXHR9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UG9zaXRpb24oKSB7XG5cdHJldHVybiBwb3NpdGlvblxufVxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrZWRSZWFkKG9wdGlvbnMpIHtcblx0dHJ5IHtcblx0XHRpZiAoIWN1cnJlbnRVbnBhY2tyLnRydXN0ZWQgJiYgIXNlcXVlbnRpYWxNb2RlKSB7XG5cdFx0XHRsZXQgc2hhcmVkTGVuZ3RoID0gY3VycmVudFN0cnVjdHVyZXMuc2hhcmVkTGVuZ3RoIHx8IDBcblx0XHRcdGlmIChzaGFyZWRMZW5ndGggPCBjdXJyZW50U3RydWN0dXJlcy5sZW5ndGgpXG5cdFx0XHRcdGN1cnJlbnRTdHJ1Y3R1cmVzLmxlbmd0aCA9IHNoYXJlZExlbmd0aFxuXHRcdH1cblx0XHRsZXQgcmVzdWx0XG5cdFx0aWYgKGN1cnJlbnRVbnBhY2tyLnJhbmRvbUFjY2Vzc1N0cnVjdHVyZSAmJiBzcmNbcG9zaXRpb25dIDwgMHg0MCAmJiBzcmNbcG9zaXRpb25dID49IDB4MjAgJiYgcmVhZFN0cnVjdCkge1xuXHRcdFx0cmVzdWx0ID0gcmVhZFN0cnVjdChzcmMsIHBvc2l0aW9uLCBzcmNFbmQsIGN1cnJlbnRVbnBhY2tyKVxuXHRcdFx0c3JjID0gbnVsbCAvLyBkaXNwb3NlIG9mIHRoaXMgc28gdGhhdCByZWN1cnNpdmUgdW5wYWNrIGNhbGxzIGRvbid0IHNhdmUgc3RhdGVcblx0XHRcdGlmICghKG9wdGlvbnMgJiYgb3B0aW9ucy5sYXp5KSAmJiByZXN1bHQpXG5cdFx0XHRcdHJlc3VsdCA9IHJlc3VsdC50b0pTT04oKVxuXHRcdFx0cG9zaXRpb24gPSBzcmNFbmRcblx0XHR9IGVsc2Vcblx0XHRcdHJlc3VsdCA9IHJlYWQoKVxuXHRcdGlmIChidW5kbGVkU3RyaW5ncykgeyAvLyBidW5kbGVkIHN0cmluZ3MgdG8gc2tpcCBwYXN0XG5cdFx0XHRwb3NpdGlvbiA9IGJ1bmRsZWRTdHJpbmdzLnBvc3RCdW5kbGVQb3NpdGlvblxuXHRcdFx0YnVuZGxlZFN0cmluZ3MgPSBudWxsXG5cdFx0fVxuXHRcdGlmIChzZXF1ZW50aWFsTW9kZSlcblx0XHRcdC8vIHdlIG9ubHkgbmVlZCB0byByZXN0b3JlIHRoZSBzdHJ1Y3R1cmVzIGlmIHRoZXJlIHdhcyBhbiBlcnJvciwgYnV0IGlmIHdlIGNvbXBsZXRlZCBhIHJlYWQsXG5cdFx0XHQvLyB3ZSBjYW4gY2xlYXIgdGhpcyBvdXQgYW5kIGtlZXAgdGhlIHN0cnVjdHVyZXMgd2UgcmVhZFxuXHRcdFx0Y3VycmVudFN0cnVjdHVyZXMucmVzdG9yZVN0cnVjdHVyZXMgPSBudWxsXG5cblx0XHRpZiAocG9zaXRpb24gPT0gc3JjRW5kKSB7XG5cdFx0XHQvLyBmaW5pc2hlZCByZWFkaW5nIHRoaXMgc291cmNlLCBjbGVhbnVwIHJlZmVyZW5jZXNcblx0XHRcdGlmIChjdXJyZW50U3RydWN0dXJlcyAmJiBjdXJyZW50U3RydWN0dXJlcy5yZXN0b3JlU3RydWN0dXJlcylcblx0XHRcdFx0cmVzdG9yZVN0cnVjdHVyZXMoKVxuXHRcdFx0Y3VycmVudFN0cnVjdHVyZXMgPSBudWxsXG5cdFx0XHRzcmMgPSBudWxsXG5cdFx0XHRpZiAocmVmZXJlbmNlTWFwKVxuXHRcdFx0XHRyZWZlcmVuY2VNYXAgPSBudWxsXG5cdFx0fSBlbHNlIGlmIChwb3NpdGlvbiA+IHNyY0VuZCkge1xuXHRcdFx0Ly8gb3ZlciByZWFkXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIE1lc3NhZ2VQYWNrIGRhdGEnKVxuXHRcdH0gZWxzZSBpZiAoIXNlcXVlbnRpYWxNb2RlKSB7XG5cdFx0XHRsZXQganNvblZpZXc7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRqc29uVmlldyA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCwgKF8sIHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIgPyBgJHt2YWx1ZX1uYCA6IHZhbHVlKS5zbGljZSgwLCAxMDApXG5cdFx0XHR9IGNhdGNoKGVycm9yKSB7XG5cdFx0XHRcdGpzb25WaWV3ID0gJyhKU09OIHZpZXcgbm90IGF2YWlsYWJsZSAnICsgZXJyb3IgKyAnKSdcblx0XHRcdH1cblx0XHRcdHRocm93IG5ldyBFcnJvcignRGF0YSByZWFkLCBidXQgZW5kIG9mIGJ1ZmZlciBub3QgcmVhY2hlZCAnICsganNvblZpZXcpXG5cdFx0fVxuXHRcdC8vIGVsc2UgbW9yZSB0byByZWFkLCBidXQgd2UgYXJlIHJlYWRpbmcgc2VxdWVudGlhbGx5LCBzbyBkb24ndCBjbGVhciBzb3VyY2UgeWV0XG5cdFx0cmV0dXJuIHJlc3VsdFxuXHR9IGNhdGNoKGVycm9yKSB7XG5cdFx0aWYgKGN1cnJlbnRTdHJ1Y3R1cmVzICYmIGN1cnJlbnRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzKVxuXHRcdFx0cmVzdG9yZVN0cnVjdHVyZXMoKVxuXHRcdGNsZWFyU291cmNlKClcblx0XHRpZiAoZXJyb3IgaW5zdGFuY2VvZiBSYW5nZUVycm9yIHx8IGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aCgnVW5leHBlY3RlZCBlbmQgb2YgYnVmZmVyJykgfHwgcG9zaXRpb24gPiBzcmNFbmQpIHtcblx0XHRcdGVycm9yLmluY29tcGxldGUgPSB0cnVlXG5cdFx0fVxuXHRcdHRocm93IGVycm9yXG5cdH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZVN0cnVjdHVyZXMoKSB7XG5cdGZvciAobGV0IGlkIGluIGN1cnJlbnRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzKSB7XG5cdFx0Y3VycmVudFN0cnVjdHVyZXNbaWRdID0gY3VycmVudFN0cnVjdHVyZXMucmVzdG9yZVN0cnVjdHVyZXNbaWRdXG5cdH1cblx0Y3VycmVudFN0cnVjdHVyZXMucmVzdG9yZVN0cnVjdHVyZXMgPSBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkKCkge1xuXHRsZXQgdG9rZW4gPSBzcmNbcG9zaXRpb24rK11cblx0aWYgKHRva2VuIDwgMHhhMCkge1xuXHRcdGlmICh0b2tlbiA8IDB4ODApIHtcblx0XHRcdGlmICh0b2tlbiA8IDB4NDApXG5cdFx0XHRcdHJldHVybiB0b2tlblxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGxldCBzdHJ1Y3R1cmUgPSBjdXJyZW50U3RydWN0dXJlc1t0b2tlbiAmIDB4M2ZdIHx8XG5cdFx0XHRcdFx0Y3VycmVudFVucGFja3IuZ2V0U3RydWN0dXJlcyAmJiBsb2FkU3RydWN0dXJlcygpW3Rva2VuICYgMHgzZl1cblx0XHRcdFx0aWYgKHN0cnVjdHVyZSkge1xuXHRcdFx0XHRcdGlmICghc3RydWN0dXJlLnJlYWQpIHtcblx0XHRcdFx0XHRcdHN0cnVjdHVyZS5yZWFkID0gY3JlYXRlU3RydWN0dXJlUmVhZGVyKHN0cnVjdHVyZSwgdG9rZW4gJiAweDNmKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gc3RydWN0dXJlLnJlYWQoKVxuXHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRyZXR1cm4gdG9rZW5cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHRva2VuIDwgMHg5MCkge1xuXHRcdFx0Ly8gbWFwXG5cdFx0XHR0b2tlbiAtPSAweDgwXG5cdFx0XHRpZiAoY3VycmVudFVucGFja3IubWFwc0FzT2JqZWN0cykge1xuXHRcdFx0XHRsZXQgb2JqZWN0ID0ge31cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbjsgaSsrKSB7XG5cdFx0XHRcdFx0bGV0IGtleSA9IHJlYWRLZXkoKVxuXHRcdFx0XHRcdGlmIChrZXkgPT09ICdfX3Byb3RvX18nKVxuXHRcdFx0XHRcdFx0a2V5ID0gJ19fcHJvdG9fJ1xuXHRcdFx0XHRcdG9iamVjdFtrZXldID0gcmVhZCgpXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9iamVjdFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGV0IG1hcCA9IG5ldyBNYXAoKVxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuOyBpKyspIHtcblx0XHRcdFx0XHRtYXAuc2V0KHJlYWQoKSwgcmVhZCgpKVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXBcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dG9rZW4gLT0gMHg5MFxuXHRcdFx0bGV0IGFycmF5ID0gbmV3IEFycmF5KHRva2VuKVxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbjsgaSsrKSB7XG5cdFx0XHRcdGFycmF5W2ldID0gcmVhZCgpXG5cdFx0XHR9XG5cdFx0XHRpZiAoY3VycmVudFVucGFja3IuZnJlZXplRGF0YSlcblx0XHRcdFx0cmV0dXJuIE9iamVjdC5mcmVlemUoYXJyYXkpXG5cdFx0XHRyZXR1cm4gYXJyYXlcblx0XHR9XG5cdH0gZWxzZSBpZiAodG9rZW4gPCAweGMwKSB7XG5cdFx0Ly8gZml4c3RyXG5cdFx0bGV0IGxlbmd0aCA9IHRva2VuIC0gMHhhMFxuXHRcdGlmIChzcmNTdHJpbmdFbmQgPj0gcG9zaXRpb24pIHtcblx0XHRcdHJldHVybiBzcmNTdHJpbmcuc2xpY2UocG9zaXRpb24gLSBzcmNTdHJpbmdTdGFydCwgKHBvc2l0aW9uICs9IGxlbmd0aCkgLSBzcmNTdHJpbmdTdGFydClcblx0XHR9XG5cdFx0aWYgKHNyY1N0cmluZ0VuZCA9PSAwICYmIHNyY0VuZCA8IDE0MCkge1xuXHRcdFx0Ly8gZm9yIHNtYWxsIGJsb2NrcywgYXZvaWRpbmcgdGhlIG92ZXJoZWFkIG9mIHRoZSBleHRyYWN0IGNhbGwgaXMgaGVscGZ1bFxuXHRcdFx0bGV0IHN0cmluZyA9IGxlbmd0aCA8IDE2ID8gc2hvcnRTdHJpbmdJbkpTKGxlbmd0aCkgOiBsb25nU3RyaW5nSW5KUyhsZW5ndGgpXG5cdFx0XHRpZiAoc3RyaW5nICE9IG51bGwpXG5cdFx0XHRcdHJldHVybiBzdHJpbmdcblx0XHR9XG5cdFx0cmV0dXJuIHJlYWRGaXhlZFN0cmluZyhsZW5ndGgpXG5cdH0gZWxzZSB7XG5cdFx0bGV0IHZhbHVlXG5cdFx0c3dpdGNoICh0b2tlbikge1xuXHRcdFx0Y2FzZSAweGMwOiByZXR1cm4gbnVsbFxuXHRcdFx0Y2FzZSAweGMxOlxuXHRcdFx0XHRpZiAoYnVuZGxlZFN0cmluZ3MpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHJlYWQoKSAvLyBmb2xsb3dlZCBieSB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgaW4gY2hhcmFjdGVycyAobm90IGJ5dGVzISlcblx0XHRcdFx0XHRpZiAodmFsdWUgPiAwKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGJ1bmRsZWRTdHJpbmdzWzFdLnNsaWNlKGJ1bmRsZWRTdHJpbmdzLnBvc2l0aW9uMSwgYnVuZGxlZFN0cmluZ3MucG9zaXRpb24xICs9IHZhbHVlKVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHJldHVybiBidW5kbGVkU3RyaW5nc1swXS5zbGljZShidW5kbGVkU3RyaW5ncy5wb3NpdGlvbjAsIGJ1bmRsZWRTdHJpbmdzLnBvc2l0aW9uMCAtPSB2YWx1ZSlcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gQzE7IC8vIFwibmV2ZXItdXNlZFwiLCByZXR1cm4gc3BlY2lhbCBvYmplY3QgdG8gZGVub3RlIHRoYXRcblx0XHRcdGNhc2UgMHhjMjogcmV0dXJuIGZhbHNlXG5cdFx0XHRjYXNlIDB4YzM6IHJldHVybiB0cnVlXG5cdFx0XHRjYXNlIDB4YzQ6XG5cdFx0XHRcdC8vIGJpbiA4XG5cdFx0XHRcdHZhbHVlID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgYnVmZmVyJylcblx0XHRcdFx0cmV0dXJuIHJlYWRCaW4odmFsdWUpXG5cdFx0XHRjYXNlIDB4YzU6XG5cdFx0XHRcdC8vIGJpbiAxNlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldFVpbnQxNihwb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gKz0gMlxuXHRcdFx0XHRyZXR1cm4gcmVhZEJpbih2YWx1ZSlcblx0XHRcdGNhc2UgMHhjNjpcblx0XHRcdFx0Ly8gYmluIDMyXG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdHJldHVybiByZWFkQmluKHZhbHVlKVxuXHRcdFx0Y2FzZSAweGM3OlxuXHRcdFx0XHQvLyBleHQgOFxuXHRcdFx0XHRyZXR1cm4gcmVhZEV4dChzcmNbcG9zaXRpb24rK10pXG5cdFx0XHRjYXNlIDB4Yzg6XG5cdFx0XHRcdC8vIGV4dCAxNlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldFVpbnQxNihwb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gKz0gMlxuXHRcdFx0XHRyZXR1cm4gcmVhZEV4dCh2YWx1ZSlcblx0XHRcdGNhc2UgMHhjOTpcblx0XHRcdFx0Ly8gZXh0IDMyXG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdHJldHVybiByZWFkRXh0KHZhbHVlKVxuXHRcdFx0Y2FzZSAweGNhOlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldEZsb2F0MzIocG9zaXRpb24pXG5cdFx0XHRcdGlmIChjdXJyZW50VW5wYWNrci51c2VGbG9hdDMyID4gMikge1xuXHRcdFx0XHRcdC8vIHRoaXMgZG9lcyByb3VuZGluZyBvZiBudW1iZXJzIHRoYXQgd2VyZSBlbmNvZGVkIGluIDMyLWJpdCBmbG9hdCB0byBuZWFyZXN0IHNpZ25pZmljYW50IGRlY2ltYWwgZGlnaXQgdGhhdCBjb3VsZCBiZSBwcmVzZXJ2ZWRcblx0XHRcdFx0XHRsZXQgbXVsdGlwbGllciA9IG11bHQxMFsoKHNyY1twb3NpdGlvbl0gJiAweDdmKSA8PCAxKSB8IChzcmNbcG9zaXRpb24gKyAxXSA+PiA3KV1cblx0XHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdFx0cmV0dXJuICgobXVsdGlwbGllciAqIHZhbHVlICsgKHZhbHVlID4gMCA/IDAuNSA6IC0wLjUpKSA+PiAwKSAvIG11bHRpcGxpZXJcblx0XHRcdFx0fVxuXHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdFx0Y2FzZSAweGNiOlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldEZsb2F0NjQocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDhcblx0XHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0XHQvLyB1aW50IGhhbmRsZXJzXG5cdFx0XHRjYXNlIDB4Y2M6XG5cdFx0XHRcdHJldHVybiBzcmNbcG9zaXRpb24rK11cblx0XHRcdGNhc2UgMHhjZDpcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDJcblx0XHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0XHRjYXNlIDB4Y2U6XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdFx0Y2FzZSAweGNmOlxuXHRcdFx0XHRpZiAoY3VycmVudFVucGFja3IuaW50NjRBc1R5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24pICogMHgxMDAwMDAwMDBcblx0XHRcdFx0XHR2YWx1ZSArPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24gKyA0KVxuXHRcdFx0XHR9IGVsc2UgaWYgKGN1cnJlbnRVbnBhY2tyLmludDY0QXNUeXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0QmlnVWludDY0KHBvc2l0aW9uKS50b1N0cmluZygpXG5cdFx0XHRcdH0gZWxzZSBpZiAoY3VycmVudFVucGFja3IuaW50NjRBc1R5cGUgPT09ICdhdXRvJykge1xuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0QmlnVWludDY0KHBvc2l0aW9uKVxuXHRcdFx0XHRcdGlmICh2YWx1ZTw9QmlnSW50KDIpPDxCaWdJbnQoNTIpKSB2YWx1ZT1OdW1iZXIodmFsdWUpXG5cdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0QmlnVWludDY0KHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSA4XG5cdFx0XHRcdHJldHVybiB2YWx1ZVxuXG5cdFx0XHQvLyBpbnQgaGFuZGxlcnNcblx0XHRcdGNhc2UgMHhkMDpcblx0XHRcdFx0cmV0dXJuIGRhdGFWaWV3LmdldEludDgocG9zaXRpb24rKylcblx0XHRcdGNhc2UgMHhkMTpcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRJbnQxNihwb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gKz0gMlxuXHRcdFx0XHRyZXR1cm4gdmFsdWVcblx0XHRcdGNhc2UgMHhkMjpcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRJbnQzMihwb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gKz0gNFxuXHRcdFx0XHRyZXR1cm4gdmFsdWVcblx0XHRcdGNhc2UgMHhkMzpcblx0XHRcdFx0aWYgKGN1cnJlbnRVbnBhY2tyLmludDY0QXNUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0SW50MzIocG9zaXRpb24pICogMHgxMDAwMDAwMDBcblx0XHRcdFx0XHR2YWx1ZSArPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24gKyA0KVxuXHRcdFx0XHR9IGVsc2UgaWYgKGN1cnJlbnRVbnBhY2tyLmludDY0QXNUeXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0QmlnSW50NjQocG9zaXRpb24pLnRvU3RyaW5nKClcblx0XHRcdFx0fSBlbHNlIGlmIChjdXJyZW50VW5wYWNrci5pbnQ2NEFzVHlwZSA9PT0gJ2F1dG8nKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRCaWdJbnQ2NChwb3NpdGlvbilcblx0XHRcdFx0XHRpZiAodmFsdWU+PUJpZ0ludCgtMik8PEJpZ0ludCg1MikmJnZhbHVlPD1CaWdJbnQoMik8PEJpZ0ludCg1MikpIHZhbHVlPU51bWJlcih2YWx1ZSlcblx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRCaWdJbnQ2NChwb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gKz0gOFxuXHRcdFx0XHRyZXR1cm4gdmFsdWVcblxuXHRcdFx0Y2FzZSAweGQ0OlxuXHRcdFx0XHQvLyBmaXhleHQgMVxuXHRcdFx0XHR2YWx1ZSA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0XHRpZiAodmFsdWUgPT0gMHg3Mikge1xuXHRcdFx0XHRcdHJldHVybiByZWNvcmREZWZpbml0aW9uKHNyY1twb3NpdGlvbisrXSAmIDB4M2YpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGV0IGV4dGVuc2lvbiA9IGN1cnJlbnRFeHRlbnNpb25zW3ZhbHVlXVxuXHRcdFx0XHRcdGlmIChleHRlbnNpb24pIHtcblx0XHRcdFx0XHRcdGlmIChleHRlbnNpb24ucmVhZCkge1xuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbisrIC8vIHNraXAgZmlsbGVyIGJ5dGVcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGV4dGVuc2lvbi5yZWFkKHJlYWQoKSlcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoZXh0ZW5zaW9uLm5vQnVmZmVyKSB7XG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uKysgLy8gc2tpcCBmaWxsZXIgYnl0ZVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZXh0ZW5zaW9uKClcblx0XHRcdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZXh0ZW5zaW9uKHNyYy5zdWJhcnJheShwb3NpdGlvbiwgKytwb3NpdGlvbikpXG5cdFx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZXh0ZW5zaW9uICcgKyB2YWx1ZSlcblx0XHRcdFx0fVxuXHRcdFx0Y2FzZSAweGQ1OlxuXHRcdFx0XHQvLyBmaXhleHQgMlxuXHRcdFx0XHR2YWx1ZSA9IHNyY1twb3NpdGlvbl1cblx0XHRcdFx0aWYgKHZhbHVlID09IDB4NzIpIHtcblx0XHRcdFx0XHRwb3NpdGlvbisrXG5cdFx0XHRcdFx0cmV0dXJuIHJlY29yZERlZmluaXRpb24oc3JjW3Bvc2l0aW9uKytdICYgMHgzZiwgc3JjW3Bvc2l0aW9uKytdKVxuXHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRyZXR1cm4gcmVhZEV4dCgyKVxuXHRcdFx0Y2FzZSAweGQ2OlxuXHRcdFx0XHQvLyBmaXhleHQgNFxuXHRcdFx0XHRyZXR1cm4gcmVhZEV4dCg0KVxuXHRcdFx0Y2FzZSAweGQ3OlxuXHRcdFx0XHQvLyBmaXhleHQgOFxuXHRcdFx0XHRyZXR1cm4gcmVhZEV4dCg4KVxuXHRcdFx0Y2FzZSAweGQ4OlxuXHRcdFx0XHQvLyBmaXhleHQgMTZcblx0XHRcdFx0cmV0dXJuIHJlYWRFeHQoMTYpXG5cdFx0XHRjYXNlIDB4ZDk6XG5cdFx0XHQvLyBzdHIgOFxuXHRcdFx0XHR2YWx1ZSA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0XHRpZiAoc3JjU3RyaW5nRW5kID49IHBvc2l0aW9uKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHNyY1N0cmluZy5zbGljZShwb3NpdGlvbiAtIHNyY1N0cmluZ1N0YXJ0LCAocG9zaXRpb24gKz0gdmFsdWUpIC0gc3JjU3RyaW5nU3RhcnQpXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlYWRTdHJpbmc4KHZhbHVlKVxuXHRcdFx0Y2FzZSAweGRhOlxuXHRcdFx0Ly8gc3RyIDE2XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSAyXG5cdFx0XHRcdGlmIChzcmNTdHJpbmdFbmQgPj0gcG9zaXRpb24pIHtcblx0XHRcdFx0XHRyZXR1cm4gc3JjU3RyaW5nLnNsaWNlKHBvc2l0aW9uIC0gc3JjU3RyaW5nU3RhcnQsIChwb3NpdGlvbiArPSB2YWx1ZSkgLSBzcmNTdHJpbmdTdGFydClcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmVhZFN0cmluZzE2KHZhbHVlKVxuXHRcdFx0Y2FzZSAweGRiOlxuXHRcdFx0Ly8gc3RyIDMyXG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdGlmIChzcmNTdHJpbmdFbmQgPj0gcG9zaXRpb24pIHtcblx0XHRcdFx0XHRyZXR1cm4gc3JjU3RyaW5nLnNsaWNlKHBvc2l0aW9uIC0gc3JjU3RyaW5nU3RhcnQsIChwb3NpdGlvbiArPSB2YWx1ZSkgLSBzcmNTdHJpbmdTdGFydClcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmVhZFN0cmluZzMyKHZhbHVlKVxuXHRcdFx0Y2FzZSAweGRjOlxuXHRcdFx0Ly8gYXJyYXkgMTZcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDJcblx0XHRcdFx0cmV0dXJuIHJlYWRBcnJheSh2YWx1ZSlcblx0XHRcdGNhc2UgMHhkZDpcblx0XHRcdC8vIGFycmF5IDMyXG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdHJldHVybiByZWFkQXJyYXkodmFsdWUpXG5cdFx0XHRjYXNlIDB4ZGU6XG5cdFx0XHQvLyBtYXAgMTZcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDJcblx0XHRcdFx0cmV0dXJuIHJlYWRNYXAodmFsdWUpXG5cdFx0XHRjYXNlIDB4ZGY6XG5cdFx0XHQvLyBtYXAgMzJcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDRcblx0XHRcdFx0cmV0dXJuIHJlYWRNYXAodmFsdWUpXG5cdFx0XHRkZWZhdWx0OiAvLyBuZWdhdGl2ZSBpbnRcblx0XHRcdFx0aWYgKHRva2VuID49IDB4ZTApXG5cdFx0XHRcdFx0cmV0dXJuIHRva2VuIC0gMHgxMDBcblx0XHRcdFx0aWYgKHRva2VuID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRsZXQgZXJyb3IgPSBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIE1lc3NhZ2VQYWNrIGRhdGEnKVxuXHRcdFx0XHRcdGVycm9yLmluY29tcGxldGUgPSB0cnVlXG5cdFx0XHRcdFx0dGhyb3cgZXJyb3Jcblx0XHRcdFx0fVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gTWVzc2FnZVBhY2sgdG9rZW4gJyArIHRva2VuKVxuXG5cdFx0fVxuXHR9XG59XG5jb25zdCB2YWxpZE5hbWUgPSAvXlthLXpBLVpfJF1bYS16QS1aXFxkXyRdKiQvXG5mdW5jdGlvbiBjcmVhdGVTdHJ1Y3R1cmVSZWFkZXIoc3RydWN0dXJlLCBmaXJzdElkKSB7XG5cdGZ1bmN0aW9uIHJlYWRPYmplY3QoKSB7XG5cdFx0Ly8gVGhpcyBpbml0aWFsIGZ1bmN0aW9uIGlzIHF1aWNrIHRvIGluc3RhbnRpYXRlLCBidXQgcnVucyBzbG93ZXIuIEFmdGVyIHNldmVyYWwgaXRlcmF0aW9ucyBwYXkgdGhlIGNvc3QgdG8gYnVpbGQgdGhlIGZhc3RlciBmdW5jdGlvblxuXHRcdGlmIChyZWFkT2JqZWN0LmNvdW50KysgPiBpbmxpbmVPYmplY3RSZWFkVGhyZXNob2xkKSB7XG5cdFx0XHRsZXQgcmVhZE9iamVjdCA9IHN0cnVjdHVyZS5yZWFkID0gKG5ldyBGdW5jdGlvbigncicsICdyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gJyArIChjdXJyZW50VW5wYWNrci5mcmVlemVEYXRhID8gJ09iamVjdC5mcmVlemUnIDogJycpICtcblx0XHRcdFx0Jyh7JyArIHN0cnVjdHVyZS5tYXAoa2V5ID0+IGtleSA9PT0gJ19fcHJvdG9fXycgPyAnX19wcm90b186cigpJyA6IHZhbGlkTmFtZS50ZXN0KGtleSkgPyBrZXkgKyAnOnIoKScgOiAoJ1snICsgSlNPTi5zdHJpbmdpZnkoa2V5KSArICddOnIoKScpKS5qb2luKCcsJykgKyAnfSl9JykpKHJlYWQpXG5cdFx0XHRpZiAoc3RydWN0dXJlLmhpZ2hCeXRlID09PSAwKVxuXHRcdFx0XHRzdHJ1Y3R1cmUucmVhZCA9IGNyZWF0ZVNlY29uZEJ5dGVSZWFkZXIoZmlyc3RJZCwgc3RydWN0dXJlLnJlYWQpXG5cdFx0XHRyZXR1cm4gcmVhZE9iamVjdCgpIC8vIHNlY29uZCBieXRlIGlzIGFscmVhZHkgcmVhZCwgaWYgdGhlcmUgaXMgb25lIHNvIGltbWVkaWF0ZWx5IHJlYWQgb2JqZWN0XG5cdFx0fVxuXHRcdGxldCBvYmplY3QgPSB7fVxuXHRcdGZvciAobGV0IGkgPSAwLCBsID0gc3RydWN0dXJlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0bGV0IGtleSA9IHN0cnVjdHVyZVtpXVxuXHRcdFx0aWYgKGtleSA9PT0gJ19fcHJvdG9fXycpXG5cdFx0XHRcdGtleSA9ICdfX3Byb3RvXydcblx0XHRcdG9iamVjdFtrZXldID0gcmVhZCgpXG5cdFx0fVxuXHRcdGlmIChjdXJyZW50VW5wYWNrci5mcmVlemVEYXRhKVxuXHRcdFx0cmV0dXJuIE9iamVjdC5mcmVlemUob2JqZWN0KTtcblx0XHRyZXR1cm4gb2JqZWN0XG5cdH1cblx0cmVhZE9iamVjdC5jb3VudCA9IDBcblx0aWYgKHN0cnVjdHVyZS5oaWdoQnl0ZSA9PT0gMCkge1xuXHRcdHJldHVybiBjcmVhdGVTZWNvbmRCeXRlUmVhZGVyKGZpcnN0SWQsIHJlYWRPYmplY3QpXG5cdH1cblx0cmV0dXJuIHJlYWRPYmplY3Rcbn1cblxuY29uc3QgY3JlYXRlU2Vjb25kQnl0ZVJlYWRlciA9IChmaXJzdElkLCByZWFkMCkgPT4ge1xuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0bGV0IGhpZ2hCeXRlID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0aWYgKGhpZ2hCeXRlID09PSAwKVxuXHRcdFx0cmV0dXJuIHJlYWQwKClcblx0XHRsZXQgaWQgPSBmaXJzdElkIDwgMzIgPyAtKGZpcnN0SWQgKyAoaGlnaEJ5dGUgPDwgNSkpIDogZmlyc3RJZCArIChoaWdoQnl0ZSA8PCA1KVxuXHRcdGxldCBzdHJ1Y3R1cmUgPSBjdXJyZW50U3RydWN0dXJlc1tpZF0gfHwgbG9hZFN0cnVjdHVyZXMoKVtpZF1cblx0XHRpZiAoIXN0cnVjdHVyZSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdSZWNvcmQgaWQgaXMgbm90IGRlZmluZWQgZm9yICcgKyBpZClcblx0XHR9XG5cdFx0aWYgKCFzdHJ1Y3R1cmUucmVhZClcblx0XHRcdHN0cnVjdHVyZS5yZWFkID0gY3JlYXRlU3RydWN0dXJlUmVhZGVyKHN0cnVjdHVyZSwgZmlyc3RJZClcblx0XHRyZXR1cm4gc3RydWN0dXJlLnJlYWQoKVxuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkU3RydWN0dXJlcygpIHtcblx0bGV0IGxvYWRlZFN0cnVjdHVyZXMgPSBzYXZlU3RhdGUoKCkgPT4ge1xuXHRcdC8vIHNhdmUgdGhlIHN0YXRlIGluIGNhc2UgZ2V0U3RydWN0dXJlcyBtb2RpZmllcyBvdXIgYnVmZmVyXG5cdFx0c3JjID0gbnVsbFxuXHRcdHJldHVybiBjdXJyZW50VW5wYWNrci5nZXRTdHJ1Y3R1cmVzKClcblx0fSlcblx0cmV0dXJuIGN1cnJlbnRTdHJ1Y3R1cmVzID0gY3VycmVudFVucGFja3IuX21lcmdlU3RydWN0dXJlcyhsb2FkZWRTdHJ1Y3R1cmVzLCBjdXJyZW50U3RydWN0dXJlcylcbn1cblxudmFyIHJlYWRGaXhlZFN0cmluZyA9IHJlYWRTdHJpbmdKU1xudmFyIHJlYWRTdHJpbmc4ID0gcmVhZFN0cmluZ0pTXG52YXIgcmVhZFN0cmluZzE2ID0gcmVhZFN0cmluZ0pTXG52YXIgcmVhZFN0cmluZzMyID0gcmVhZFN0cmluZ0pTXG5leHBvcnQgbGV0IGlzTmF0aXZlQWNjZWxlcmF0aW9uRW5hYmxlZCA9IGZhbHNlXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRFeHRyYWN0b3IoZXh0cmFjdFN0cmluZ3MpIHtcblx0aXNOYXRpdmVBY2NlbGVyYXRpb25FbmFibGVkID0gdHJ1ZVxuXHRyZWFkRml4ZWRTdHJpbmcgPSByZWFkU3RyaW5nKDEpXG5cdHJlYWRTdHJpbmc4ID0gcmVhZFN0cmluZygyKVxuXHRyZWFkU3RyaW5nMTYgPSByZWFkU3RyaW5nKDMpXG5cdHJlYWRTdHJpbmczMiA9IHJlYWRTdHJpbmcoNSlcblx0ZnVuY3Rpb24gcmVhZFN0cmluZyhoZWFkZXJMZW5ndGgpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gcmVhZFN0cmluZyhsZW5ndGgpIHtcblx0XHRcdGxldCBzdHJpbmcgPSBzdHJpbmdzW3N0cmluZ1Bvc2l0aW9uKytdXG5cdFx0XHRpZiAoc3RyaW5nID09IG51bGwpIHtcblx0XHRcdFx0aWYgKGJ1bmRsZWRTdHJpbmdzKVxuXHRcdFx0XHRcdHJldHVybiByZWFkU3RyaW5nSlMobGVuZ3RoKVxuXHRcdFx0XHRsZXQgYnl0ZU9mZnNldCA9IHNyYy5ieXRlT2Zmc2V0XG5cdFx0XHRcdGxldCBleHRyYWN0aW9uID0gZXh0cmFjdFN0cmluZ3MocG9zaXRpb24gLSBoZWFkZXJMZW5ndGggKyBieXRlT2Zmc2V0LCBzcmNFbmQgKyBieXRlT2Zmc2V0LCBzcmMuYnVmZmVyKVxuXHRcdFx0XHRpZiAodHlwZW9mIGV4dHJhY3Rpb24gPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRzdHJpbmcgPSBleHRyYWN0aW9uXG5cdFx0XHRcdFx0c3RyaW5ncyA9IEVNUFRZX0FSUkFZXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RyaW5ncyA9IGV4dHJhY3Rpb25cblx0XHRcdFx0XHRzdHJpbmdQb3NpdGlvbiA9IDFcblx0XHRcdFx0XHRzcmNTdHJpbmdFbmQgPSAxIC8vIGV2ZW4gaWYgYSB1dGYtOCBzdHJpbmcgd2FzIGRlY29kZWQsIG11c3QgaW5kaWNhdGUgd2UgYXJlIGluIHRoZSBtaWRzdCBvZiBleHRyYWN0ZWQgc3RyaW5ncyBhbmQgY2FuJ3Qgc2tpcCBzdHJpbmdzXG5cdFx0XHRcdFx0c3RyaW5nID0gc3RyaW5nc1swXVxuXHRcdFx0XHRcdGlmIChzdHJpbmcgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgYnVmZmVyJylcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bGV0IHNyY1N0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGhcblx0XHRcdGlmIChzcmNTdHJpbmdMZW5ndGggPD0gbGVuZ3RoKSB7XG5cdFx0XHRcdHBvc2l0aW9uICs9IGxlbmd0aFxuXHRcdFx0XHRyZXR1cm4gc3RyaW5nXG5cdFx0XHR9XG5cdFx0XHRzcmNTdHJpbmcgPSBzdHJpbmdcblx0XHRcdHNyY1N0cmluZ1N0YXJ0ID0gcG9zaXRpb25cblx0XHRcdHNyY1N0cmluZ0VuZCA9IHBvc2l0aW9uICsgc3JjU3RyaW5nTGVuZ3RoXG5cdFx0XHRwb3NpdGlvbiArPSBsZW5ndGhcblx0XHRcdHJldHVybiBzdHJpbmcuc2xpY2UoMCwgbGVuZ3RoKSAvLyB3ZSBrbm93IHdlIGp1c3Qgd2FudCB0aGUgYmVnaW5uaW5nXG5cdFx0fVxuXHR9XG59XG5mdW5jdGlvbiByZWFkU3RyaW5nSlMobGVuZ3RoKSB7XG5cdGxldCByZXN1bHRcblx0aWYgKGxlbmd0aCA8IDE2KSB7XG5cdFx0aWYgKHJlc3VsdCA9IHNob3J0U3RyaW5nSW5KUyhsZW5ndGgpKVxuXHRcdFx0cmV0dXJuIHJlc3VsdFxuXHR9XG5cdGlmIChsZW5ndGggPiA2NCAmJiBkZWNvZGVyKVxuXHRcdHJldHVybiBkZWNvZGVyLmRlY29kZShzcmMuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICs9IGxlbmd0aCkpXG5cdGNvbnN0IGVuZCA9IHBvc2l0aW9uICsgbGVuZ3RoXG5cdGNvbnN0IHVuaXRzID0gW11cblx0cmVzdWx0ID0gJydcblx0d2hpbGUgKHBvc2l0aW9uIDwgZW5kKSB7XG5cdFx0Y29uc3QgYnl0ZTEgPSBzcmNbcG9zaXRpb24rK11cblx0XHRpZiAoKGJ5dGUxICYgMHg4MCkgPT09IDApIHtcblx0XHRcdC8vIDEgYnl0ZVxuXHRcdFx0dW5pdHMucHVzaChieXRlMSlcblx0XHR9IGVsc2UgaWYgKChieXRlMSAmIDB4ZTApID09PSAweGMwKSB7XG5cdFx0XHQvLyAyIGJ5dGVzXG5cdFx0XHRjb25zdCBieXRlMiA9IHNyY1twb3NpdGlvbisrXSAmIDB4M2Zcblx0XHRcdHVuaXRzLnB1c2goKChieXRlMSAmIDB4MWYpIDw8IDYpIHwgYnl0ZTIpXG5cdFx0fSBlbHNlIGlmICgoYnl0ZTEgJiAweGYwKSA9PT0gMHhlMCkge1xuXHRcdFx0Ly8gMyBieXRlc1xuXHRcdFx0Y29uc3QgYnl0ZTIgPSBzcmNbcG9zaXRpb24rK10gJiAweDNmXG5cdFx0XHRjb25zdCBieXRlMyA9IHNyY1twb3NpdGlvbisrXSAmIDB4M2Zcblx0XHRcdHVuaXRzLnB1c2goKChieXRlMSAmIDB4MWYpIDw8IDEyKSB8IChieXRlMiA8PCA2KSB8IGJ5dGUzKVxuXHRcdH0gZWxzZSBpZiAoKGJ5dGUxICYgMHhmOCkgPT09IDB4ZjApIHtcblx0XHRcdC8vIDQgYnl0ZXNcblx0XHRcdGNvbnN0IGJ5dGUyID0gc3JjW3Bvc2l0aW9uKytdICYgMHgzZlxuXHRcdFx0Y29uc3QgYnl0ZTMgPSBzcmNbcG9zaXRpb24rK10gJiAweDNmXG5cdFx0XHRjb25zdCBieXRlNCA9IHNyY1twb3NpdGlvbisrXSAmIDB4M2Zcblx0XHRcdGxldCB1bml0ID0gKChieXRlMSAmIDB4MDcpIDw8IDB4MTIpIHwgKGJ5dGUyIDw8IDB4MGMpIHwgKGJ5dGUzIDw8IDB4MDYpIHwgYnl0ZTRcblx0XHRcdGlmICh1bml0ID4gMHhmZmZmKSB7XG5cdFx0XHRcdHVuaXQgLT0gMHgxMDAwMFxuXHRcdFx0XHR1bml0cy5wdXNoKCgodW5pdCA+Pj4gMTApICYgMHgzZmYpIHwgMHhkODAwKVxuXHRcdFx0XHR1bml0ID0gMHhkYzAwIHwgKHVuaXQgJiAweDNmZilcblx0XHRcdH1cblx0XHRcdHVuaXRzLnB1c2godW5pdClcblx0XHR9IGVsc2Uge1xuXHRcdFx0dW5pdHMucHVzaChieXRlMSlcblx0XHR9XG5cblx0XHRpZiAodW5pdHMubGVuZ3RoID49IDB4MTAwMCkge1xuXHRcdFx0cmVzdWx0ICs9IGZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIHVuaXRzKVxuXHRcdFx0dW5pdHMubGVuZ3RoID0gMFxuXHRcdH1cblx0fVxuXG5cdGlmICh1bml0cy5sZW5ndGggPiAwKSB7XG5cdFx0cmVzdWx0ICs9IGZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIHVuaXRzKVxuXHR9XG5cblx0cmV0dXJuIHJlc3VsdFxufVxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRTdHJpbmcoc291cmNlLCBzdGFydCwgbGVuZ3RoKSB7XG5cdGxldCBleGlzdGluZ1NyYyA9IHNyYztcblx0c3JjID0gc291cmNlO1xuXHRwb3NpdGlvbiA9IHN0YXJ0O1xuXHR0cnkge1xuXHRcdHJldHVybiByZWFkU3RyaW5nSlMobGVuZ3RoKTtcblx0fSBmaW5hbGx5IHtcblx0XHRzcmMgPSBleGlzdGluZ1NyYztcblx0fVxufVxuXG5mdW5jdGlvbiByZWFkQXJyYXkobGVuZ3RoKSB7XG5cdGxldCBhcnJheSA9IG5ldyBBcnJheShsZW5ndGgpXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRhcnJheVtpXSA9IHJlYWQoKVxuXHR9XG5cdGlmIChjdXJyZW50VW5wYWNrci5mcmVlemVEYXRhKVxuXHRcdHJldHVybiBPYmplY3QuZnJlZXplKGFycmF5KVxuXHRyZXR1cm4gYXJyYXlcbn1cblxuZnVuY3Rpb24gcmVhZE1hcChsZW5ndGgpIHtcblx0aWYgKGN1cnJlbnRVbnBhY2tyLm1hcHNBc09iamVjdHMpIHtcblx0XHRsZXQgb2JqZWN0ID0ge31cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRsZXQga2V5ID0gcmVhZEtleSgpXG5cdFx0XHRpZiAoa2V5ID09PSAnX19wcm90b19fJylcblx0XHRcdFx0a2V5ID0gJ19fcHJvdG9fJztcblx0XHRcdG9iamVjdFtrZXldID0gcmVhZCgpXG5cdFx0fVxuXHRcdHJldHVybiBvYmplY3Rcblx0fSBlbHNlIHtcblx0XHRsZXQgbWFwID0gbmV3IE1hcCgpXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0bWFwLnNldChyZWFkKCksIHJlYWQoKSlcblx0XHR9XG5cdFx0cmV0dXJuIG1hcFxuXHR9XG59XG5cbnZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlXG5mdW5jdGlvbiBsb25nU3RyaW5nSW5KUyhsZW5ndGgpIHtcblx0bGV0IHN0YXJ0ID0gcG9zaXRpb25cblx0bGV0IGJ5dGVzID0gbmV3IEFycmF5KGxlbmd0aClcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdGNvbnN0IGJ5dGUgPSBzcmNbcG9zaXRpb24rK107XG5cdFx0aWYgKChieXRlICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdHBvc2l0aW9uID0gc3RhcnRcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRieXRlc1tpXSA9IGJ5dGVcblx0XHR9XG5cdFx0cmV0dXJuIGZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGJ5dGVzKVxufVxuZnVuY3Rpb24gc2hvcnRTdHJpbmdJbkpTKGxlbmd0aCkge1xuXHRpZiAobGVuZ3RoIDwgNCkge1xuXHRcdGlmIChsZW5ndGggPCAyKSB7XG5cdFx0XHRpZiAobGVuZ3RoID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gJydcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRsZXQgYSA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0XHRpZiAoKGEgJiAweDgwKSA+IDEpIHtcblx0XHRcdFx0XHRwb3NpdGlvbiAtPSAxXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhKVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZXQgYSA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0bGV0IGIgPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdGlmICgoYSAmIDB4ODApID4gMCB8fCAoYiAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRwb3NpdGlvbiAtPSAyXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0aWYgKGxlbmd0aCA8IDMpXG5cdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYilcblx0XHRcdGxldCBjID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRpZiAoKGMgJiAweDgwKSA+IDApIHtcblx0XHRcdFx0cG9zaXRpb24gLT0gM1xuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYylcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0bGV0IGEgPSBzcmNbcG9zaXRpb24rK11cblx0XHRsZXQgYiA9IHNyY1twb3NpdGlvbisrXVxuXHRcdGxldCBjID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0bGV0IGQgPSBzcmNbcG9zaXRpb24rK11cblx0XHRpZiAoKGEgJiAweDgwKSA+IDAgfHwgKGIgJiAweDgwKSA+IDAgfHwgKGMgJiAweDgwKSA+IDAgfHwgKGQgJiAweDgwKSA+IDApIHtcblx0XHRcdHBvc2l0aW9uIC09IDRcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRpZiAobGVuZ3RoIDwgNikge1xuXHRcdFx0aWYgKGxlbmd0aCA9PT0gNClcblx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkKVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGxldCBlID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRcdGlmICgoZSAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRcdHBvc2l0aW9uIC09IDVcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUpXG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChsZW5ndGggPCA4KSB7XG5cdFx0XHRsZXQgZSA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0bGV0IGYgPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdGlmICgoZSAmIDB4ODApID4gMCB8fCAoZiAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRwb3NpdGlvbiAtPSA2XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0aWYgKGxlbmd0aCA8IDcpXG5cdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZilcblx0XHRcdGxldCBnID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRpZiAoKGcgJiAweDgwKSA+IDApIHtcblx0XHRcdFx0cG9zaXRpb24gLT0gN1xuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZiwgZylcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGV0IGUgPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdGxldCBmID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRsZXQgZyA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0bGV0IGggPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdGlmICgoZSAmIDB4ODApID4gMCB8fCAoZiAmIDB4ODApID4gMCB8fCAoZyAmIDB4ODApID4gMCB8fCAoaCAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRwb3NpdGlvbiAtPSA4XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0aWYgKGxlbmd0aCA8IDEwKSB7XG5cdFx0XHRcdGlmIChsZW5ndGggPT09IDgpXG5cdFx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRsZXQgaSA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0XHRcdGlmICgoaSAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRcdFx0cG9zaXRpb24gLT0gOVxuXHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSlcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChsZW5ndGggPCAxMikge1xuXHRcdFx0XHRsZXQgaSA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0XHRsZXQgaiA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0XHRpZiAoKGkgJiAweDgwKSA+IDAgfHwgKGogJiAweDgwKSA+IDApIHtcblx0XHRcdFx0XHRwb3NpdGlvbiAtPSAxMFxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsZW5ndGggPCAxMSlcblx0XHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGopXG5cdFx0XHRcdGxldCBrID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRcdGlmICgoayAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRcdHBvc2l0aW9uIC09IDExXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGV0IGkgPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdFx0bGV0IGogPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdFx0bGV0IGsgPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdFx0bGV0IGwgPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdFx0aWYgKChpICYgMHg4MCkgPiAwIHx8IChqICYgMHg4MCkgPiAwIHx8IChrICYgMHg4MCkgPiAwIHx8IChsICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24gLT0gMTJcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobGVuZ3RoIDwgMTQpIHtcblx0XHRcdFx0XHRpZiAobGVuZ3RoID09PSAxMilcblx0XHRcdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaiwgaywgbClcblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGxldCBtID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRcdFx0XHRpZiAoKG0gJiAweDgwKSA+IDApIHtcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24gLT0gMTNcblx0XHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGssIGwsIG0pXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxldCBtID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRcdFx0bGV0IG4gPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdFx0XHRpZiAoKG0gJiAweDgwKSA+IDAgfHwgKG4gJiAweDgwKSA+IDApIHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uIC09IDE0XG5cdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGxlbmd0aCA8IDE1KVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrLCBsLCBtLCBuKVxuXHRcdFx0XHRcdGxldCBvID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRcdFx0aWYgKChvICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbiAtPSAxNVxuXHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaiwgaywgbCwgbSwgbiwgbylcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiByZWFkT25seUpTU3RyaW5nKCkge1xuXHRsZXQgdG9rZW4gPSBzcmNbcG9zaXRpb24rK11cblx0bGV0IGxlbmd0aFxuXHRpZiAodG9rZW4gPCAweGMwKSB7XG5cdFx0Ly8gZml4c3RyXG5cdFx0bGVuZ3RoID0gdG9rZW4gLSAweGEwXG5cdH0gZWxzZSB7XG5cdFx0c3dpdGNoKHRva2VuKSB7XG5cdFx0XHRjYXNlIDB4ZDk6XG5cdFx0XHQvLyBzdHIgOFxuXHRcdFx0XHRsZW5ndGggPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMHhkYTpcblx0XHRcdC8vIHN0ciAxNlxuXHRcdFx0XHRsZW5ndGggPSBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDJcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMHhkYjpcblx0XHRcdC8vIHN0ciAzMlxuXHRcdFx0XHRsZW5ndGggPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDRcblx0XHRcdFx0YnJlYWtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgc3RyaW5nJylcblx0XHR9XG5cdH1cblx0cmV0dXJuIHJlYWRTdHJpbmdKUyhsZW5ndGgpXG59XG5cblxuZnVuY3Rpb24gcmVhZEJpbihsZW5ndGgpIHtcblx0cmV0dXJuIGN1cnJlbnRVbnBhY2tyLmNvcHlCdWZmZXJzID9cblx0XHQvLyBzcGVjaWZpY2FsbHkgdXNlIHRoZSBjb3B5aW5nIHNsaWNlIChub3QgdGhlIG5vZGUgb25lKVxuXHRcdFVpbnQ4QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoc3JjLCBwb3NpdGlvbiwgcG9zaXRpb24gKz0gbGVuZ3RoKSA6XG5cdFx0c3JjLnN1YmFycmF5KHBvc2l0aW9uLCBwb3NpdGlvbiArPSBsZW5ndGgpXG59XG5mdW5jdGlvbiByZWFkRXh0KGxlbmd0aCkge1xuXHRsZXQgdHlwZSA9IHNyY1twb3NpdGlvbisrXVxuXHRpZiAoY3VycmVudEV4dGVuc2lvbnNbdHlwZV0pIHtcblx0XHRsZXQgZW5kXG5cdFx0cmV0dXJuIGN1cnJlbnRFeHRlbnNpb25zW3R5cGVdKHNyYy5zdWJhcnJheShwb3NpdGlvbiwgZW5kID0gKHBvc2l0aW9uICs9IGxlbmd0aCkpLCAocmVhZFBvc2l0aW9uKSA9PiB7XG5cdFx0XHRwb3NpdGlvbiA9IHJlYWRQb3NpdGlvbjtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHJldHVybiByZWFkKCk7XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRwb3NpdGlvbiA9IGVuZDtcblx0XHRcdH1cblx0XHR9KVxuXHR9XG5cdGVsc2Vcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZXh0ZW5zaW9uIHR5cGUgJyArIHR5cGUpXG59XG5cbnZhciBrZXlDYWNoZSA9IG5ldyBBcnJheSg0MDk2KVxuZnVuY3Rpb24gcmVhZEtleSgpIHtcblx0bGV0IGxlbmd0aCA9IHNyY1twb3NpdGlvbisrXVxuXHRpZiAobGVuZ3RoID49IDB4YTAgJiYgbGVuZ3RoIDwgMHhjMCkge1xuXHRcdC8vIGZpeHN0ciwgcG90ZW50aWFsbHkgdXNlIGtleSBjYWNoZVxuXHRcdGxlbmd0aCA9IGxlbmd0aCAtIDB4YTBcblx0XHRpZiAoc3JjU3RyaW5nRW5kID49IHBvc2l0aW9uKSAvLyBpZiBpdCBoYXMgYmVlbiBleHRyYWN0ZWQsIG11c3QgdXNlIGl0IChhbmQgZmFzdGVyIGFueXdheSlcblx0XHRcdHJldHVybiBzcmNTdHJpbmcuc2xpY2UocG9zaXRpb24gLSBzcmNTdHJpbmdTdGFydCwgKHBvc2l0aW9uICs9IGxlbmd0aCkgLSBzcmNTdHJpbmdTdGFydClcblx0XHRlbHNlIGlmICghKHNyY1N0cmluZ0VuZCA9PSAwICYmIHNyY0VuZCA8IDE4MCkpXG5cdFx0XHRyZXR1cm4gcmVhZEZpeGVkU3RyaW5nKGxlbmd0aClcblx0fSBlbHNlIHsgLy8gbm90IGNhY2hlYWJsZSwgZ28gYmFjayBhbmQgZG8gYSBzdGFuZGFyZCByZWFkXG5cdFx0cG9zaXRpb24tLVxuXHRcdHJldHVybiBhc1NhZmVTdHJpbmcocmVhZCgpKVxuXHR9XG5cdGxldCBrZXkgPSAoKGxlbmd0aCA8PCA1KSBeIChsZW5ndGggPiAxID8gZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uKSA6IGxlbmd0aCA+IDAgPyBzcmNbcG9zaXRpb25dIDogMCkpICYgMHhmZmZcblx0bGV0IGVudHJ5ID0ga2V5Q2FjaGVba2V5XVxuXHRsZXQgY2hlY2tQb3NpdGlvbiA9IHBvc2l0aW9uXG5cdGxldCBlbmQgPSBwb3NpdGlvbiArIGxlbmd0aCAtIDNcblx0bGV0IGNodW5rXG5cdGxldCBpID0gMFxuXHRpZiAoZW50cnkgJiYgZW50cnkuYnl0ZXMgPT0gbGVuZ3RoKSB7XG5cdFx0d2hpbGUgKGNoZWNrUG9zaXRpb24gPCBlbmQpIHtcblx0XHRcdGNodW5rID0gZGF0YVZpZXcuZ2V0VWludDMyKGNoZWNrUG9zaXRpb24pXG5cdFx0XHRpZiAoY2h1bmsgIT0gZW50cnlbaSsrXSkge1xuXHRcdFx0XHRjaGVja1Bvc2l0aW9uID0gMHg3MDAwMDAwMFxuXHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdFx0Y2hlY2tQb3NpdGlvbiArPSA0XG5cdFx0fVxuXHRcdGVuZCArPSAzXG5cdFx0d2hpbGUgKGNoZWNrUG9zaXRpb24gPCBlbmQpIHtcblx0XHRcdGNodW5rID0gc3JjW2NoZWNrUG9zaXRpb24rK11cblx0XHRcdGlmIChjaHVuayAhPSBlbnRyeVtpKytdKSB7XG5cdFx0XHRcdGNoZWNrUG9zaXRpb24gPSAweDcwMDAwMDAwXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChjaGVja1Bvc2l0aW9uID09PSBlbmQpIHtcblx0XHRcdHBvc2l0aW9uID0gY2hlY2tQb3NpdGlvblxuXHRcdFx0cmV0dXJuIGVudHJ5LnN0cmluZ1xuXHRcdH1cblx0XHRlbmQgLT0gM1xuXHRcdGNoZWNrUG9zaXRpb24gPSBwb3NpdGlvblxuXHR9XG5cdGVudHJ5ID0gW11cblx0a2V5Q2FjaGVba2V5XSA9IGVudHJ5XG5cdGVudHJ5LmJ5dGVzID0gbGVuZ3RoXG5cdHdoaWxlIChjaGVja1Bvc2l0aW9uIDwgZW5kKSB7XG5cdFx0Y2h1bmsgPSBkYXRhVmlldy5nZXRVaW50MzIoY2hlY2tQb3NpdGlvbilcblx0XHRlbnRyeS5wdXNoKGNodW5rKVxuXHRcdGNoZWNrUG9zaXRpb24gKz0gNFxuXHR9XG5cdGVuZCArPSAzXG5cdHdoaWxlIChjaGVja1Bvc2l0aW9uIDwgZW5kKSB7XG5cdFx0Y2h1bmsgPSBzcmNbY2hlY2tQb3NpdGlvbisrXVxuXHRcdGVudHJ5LnB1c2goY2h1bmspXG5cdH1cblx0Ly8gZm9yIHNtYWxsIGJsb2NrcywgYXZvaWRpbmcgdGhlIG92ZXJoZWFkIG9mIHRoZSBleHRyYWN0IGNhbGwgaXMgaGVscGZ1bFxuXHRsZXQgc3RyaW5nID0gbGVuZ3RoIDwgMTYgPyBzaG9ydFN0cmluZ0luSlMobGVuZ3RoKSA6IGxvbmdTdHJpbmdJbkpTKGxlbmd0aClcblx0aWYgKHN0cmluZyAhPSBudWxsKVxuXHRcdHJldHVybiBlbnRyeS5zdHJpbmcgPSBzdHJpbmdcblx0cmV0dXJuIGVudHJ5LnN0cmluZyA9IHJlYWRGaXhlZFN0cmluZyhsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzU2FmZVN0cmluZyhwcm9wZXJ0eSkge1xuXHQvLyBwcm90ZWN0IGFnYWluc3QgZXhwZW5zaXZlIChEb1MpIHN0cmluZyBjb252ZXJzaW9uc1xuXHRpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnc3RyaW5nJykgcmV0dXJuIHByb3BlcnR5O1xuXHRpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgcHJvcGVydHkgPT09ICdib29sZWFuJyB8fCB0eXBlb2YgcHJvcGVydHkgPT09ICdiaWdpbnQnKSByZXR1cm4gcHJvcGVydHkudG9TdHJpbmcoKTtcblx0aWYgKHByb3BlcnR5ID09IG51bGwpIHJldHVybiBwcm9wZXJ0eSArICcnO1xuXHRpZiAoY3VycmVudFVucGFja3IuYWxsb3dBcnJheXNJbk1hcEtleXMgJiYgQXJyYXkuaXNBcnJheShwcm9wZXJ0eSkgJiYgcHJvcGVydHkuZmxhdCgpLmV2ZXJ5KGl0ZW0gPT4gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nLCAnYmlnaW50J10uaW5jbHVkZXModHlwZW9mIGl0ZW0pKSkge1xuXHRcdHJldHVybiBwcm9wZXJ0eS5mbGF0KCkudG9TdHJpbmcoKTtcblx0fVxuXHR0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHJvcGVydHkgdHlwZSBmb3IgcmVjb3JkOiAke3R5cGVvZiBwcm9wZXJ0eX1gKTtcbn1cbi8vIHRoZSByZWdpc3RyYXRpb24gb2YgdGhlIHJlY29yZCBkZWZpbml0aW9uIGV4dGVuc2lvbiAoYXMgXCJyXCIpXG5jb25zdCByZWNvcmREZWZpbml0aW9uID0gKGlkLCBoaWdoQnl0ZSkgPT4ge1xuXHRsZXQgc3RydWN0dXJlID0gcmVhZCgpLm1hcChhc1NhZmVTdHJpbmcpIC8vIGVuc3VyZSB0aGF0IGFsbCBrZXlzIGFyZSBzdHJpbmdzIGFuZFxuXHQvLyB0aGF0IHRoZSBhcnJheSBpcyBtdXRhYmxlXG5cdGxldCBmaXJzdEJ5dGUgPSBpZFxuXHRpZiAoaGlnaEJ5dGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdGlkID0gaWQgPCAzMiA/IC0oKGhpZ2hCeXRlIDw8IDUpICsgaWQpIDogKChoaWdoQnl0ZSA8PCA1KSArIGlkKVxuXHRcdHN0cnVjdHVyZS5oaWdoQnl0ZSA9IGhpZ2hCeXRlXG5cdH1cblx0bGV0IGV4aXN0aW5nU3RydWN0dXJlID0gY3VycmVudFN0cnVjdHVyZXNbaWRdXG5cdC8vIElmIGl0IGlzIGEgc2hhcmVkIHN0cnVjdHVyZSwgd2UgbmVlZCB0byByZXN0b3JlIGFueSBjaGFuZ2VzIGFmdGVyIHJlYWRpbmcuXG5cdC8vIEFsc28gaW4gc2VxdWVudGlhbCBtb2RlLCB3ZSBtYXkgZ2V0IGluY29tcGxldGUgcmVhZHMgYW5kIHRodXMgZXJyb3JzLCBhbmQgd2UgbmVlZCB0byByZXN0b3JlXG5cdC8vIHRvIHRoZSBzdGF0ZSBwcmlvciB0byBhbiBpbmNvbXBsZXRlIHJlYWQgaW4gb3JkZXIgdG8gcHJvcGVybHkgcmVzdW1lLlxuXHRpZiAoZXhpc3RpbmdTdHJ1Y3R1cmUgJiYgKGV4aXN0aW5nU3RydWN0dXJlLmlzU2hhcmVkIHx8IHNlcXVlbnRpYWxNb2RlKSkge1xuXHRcdChjdXJyZW50U3RydWN0dXJlcy5yZXN0b3JlU3RydWN0dXJlcyB8fCAoY3VycmVudFN0cnVjdHVyZXMucmVzdG9yZVN0cnVjdHVyZXMgPSBbXSkpW2lkXSA9IGV4aXN0aW5nU3RydWN0dXJlXG5cdH1cblx0Y3VycmVudFN0cnVjdHVyZXNbaWRdID0gc3RydWN0dXJlXG5cdHN0cnVjdHVyZS5yZWFkID0gY3JlYXRlU3RydWN0dXJlUmVhZGVyKHN0cnVjdHVyZSwgZmlyc3RCeXRlKVxuXHRyZXR1cm4gc3RydWN0dXJlLnJlYWQoKVxufVxuY3VycmVudEV4dGVuc2lvbnNbMF0gPSAoKSA9PiB7fSAvLyBub3RlcGFjayBkZWZpbmVzIGV4dGVuc2lvbiAwIHRvIG1lYW4gdW5kZWZpbmVkLCBzbyB1c2UgdGhhdCBhcyB0aGUgZGVmYXVsdCBoZXJlXG5jdXJyZW50RXh0ZW5zaW9uc1swXS5ub0J1ZmZlciA9IHRydWVcblxuY3VycmVudEV4dGVuc2lvbnNbMHg0Ml0gPSAoZGF0YSkgPT4ge1xuXHQvLyBkZWNvZGUgYmlnaW50XG5cdGxldCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcblx0bGV0IHZhbHVlID0gQmlnSW50KGRhdGFbMF0gJiAweDgwID8gZGF0YVswXSAtIDB4MTAwIDogZGF0YVswXSk7XG5cdGZvciAobGV0IGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHR2YWx1ZSA8PD0gQmlnSW50KDgpO1xuXHRcdHZhbHVlICs9IEJpZ0ludChkYXRhW2ldKTtcblx0fVxuXHRyZXR1cm4gdmFsdWU7XG59XG5cbmxldCBlcnJvcnMgPSB7IEVycm9yLCBUeXBlRXJyb3IsIFJlZmVyZW5jZUVycm9yIH07XG5jdXJyZW50RXh0ZW5zaW9uc1sweDY1XSA9ICgpID0+IHtcblx0bGV0IGRhdGEgPSByZWFkKClcblx0cmV0dXJuIChlcnJvcnNbZGF0YVswXV0gfHwgRXJyb3IpKGRhdGFbMV0sIHsgY2F1c2U6IGRhdGFbMl0gfSlcbn1cblxuY3VycmVudEV4dGVuc2lvbnNbMHg2OV0gPSAoZGF0YSkgPT4ge1xuXHQvLyBpZCBleHRlbnNpb24gKGZvciBzdHJ1Y3R1cmVkIGNsb25lcylcblx0aWYgKGN1cnJlbnRVbnBhY2tyLnN0cnVjdHVyZWRDbG9uZSA9PT0gZmFsc2UpIHRocm93IG5ldyBFcnJvcignU3RydWN0dXJlZCBjbG9uZSBleHRlbnNpb24gaXMgZGlzYWJsZWQnKVxuXHRsZXQgaWQgPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24gLSA0KVxuXHRpZiAoIXJlZmVyZW5jZU1hcClcblx0XHRyZWZlcmVuY2VNYXAgPSBuZXcgTWFwKClcblx0bGV0IHRva2VuID0gc3JjW3Bvc2l0aW9uXVxuXHRsZXQgdGFyZ2V0XG5cdC8vIFRPRE86IGhhbmRsZSBNYXBzLCBTZXRzLCBhbmQgb3RoZXIgdHlwZXMgdGhhdCBjYW4gY3ljbGU7IHRoaXMgaXMgY29tcGxpY2F0ZWQsIGJlY2F1c2UgeW91IHBvdGVudGlhbGx5IG5lZWQgdG8gcmVhZFxuXHQvLyBhaGVhZCBwYXN0IHJlZmVyZW5jZXMgdG8gcmVjb3JkIHN0cnVjdHVyZSBkZWZpbml0aW9uc1xuXHRpZiAodG9rZW4gPj0gMHg5MCAmJiB0b2tlbiA8IDB4YTAgfHwgdG9rZW4gPT0gMHhkYyB8fCB0b2tlbiA9PSAweGRkKVxuXHRcdHRhcmdldCA9IFtdXG5cdGVsc2Vcblx0XHR0YXJnZXQgPSB7fVxuXG5cdGxldCByZWZFbnRyeSA9IHsgdGFyZ2V0IH0gLy8gYSBwbGFjZWhvbGRlciBvYmplY3Rcblx0cmVmZXJlbmNlTWFwLnNldChpZCwgcmVmRW50cnkpXG5cdGxldCB0YXJnZXRQcm9wZXJ0aWVzID0gcmVhZCgpIC8vIHJlYWQgdGhlIG5leHQgdmFsdWUgYXMgdGhlIHRhcmdldCBvYmplY3QgdG8gaWRcblx0aWYgKHJlZkVudHJ5LnVzZWQpIC8vIHRoZXJlIGlzIGEgY3ljbGUsIHNvIHdlIGhhdmUgdG8gYXNzaWduIHByb3BlcnRpZXMgdG8gb3JpZ2luYWwgdGFyZ2V0XG5cdFx0cmV0dXJuIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB0YXJnZXRQcm9wZXJ0aWVzKVxuXHRyZWZFbnRyeS50YXJnZXQgPSB0YXJnZXRQcm9wZXJ0aWVzIC8vIHRoZSBwbGFjZWhvbGRlciB3YXNuJ3QgdXNlZCwgcmVwbGFjZSB3aXRoIHRoZSBkZXNlcmlhbGl6ZWQgb25lXG5cdHJldHVybiB0YXJnZXRQcm9wZXJ0aWVzIC8vIG5vIGN5Y2xlLCBjYW4ganVzdCB1c2UgdGhlIHJldHVybmVkIHJlYWQgb2JqZWN0XG59XG5cbmN1cnJlbnRFeHRlbnNpb25zWzB4NzBdID0gKGRhdGEpID0+IHtcblx0Ly8gcG9pbnRlciBleHRlbnNpb24gKGZvciBzdHJ1Y3R1cmVkIGNsb25lcylcblx0aWYgKGN1cnJlbnRVbnBhY2tyLnN0cnVjdHVyZWRDbG9uZSA9PT0gZmFsc2UpIHRocm93IG5ldyBFcnJvcignU3RydWN0dXJlZCBjbG9uZSBleHRlbnNpb24gaXMgZGlzYWJsZWQnKVxuXHRsZXQgaWQgPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24gLSA0KVxuXHRsZXQgcmVmRW50cnkgPSByZWZlcmVuY2VNYXAuZ2V0KGlkKVxuXHRyZWZFbnRyeS51c2VkID0gdHJ1ZVxuXHRyZXR1cm4gcmVmRW50cnkudGFyZ2V0XG59XG5cbmN1cnJlbnRFeHRlbnNpb25zWzB4NzNdID0gKCkgPT4gbmV3IFNldChyZWFkKCkpXG5cbmV4cG9ydCBjb25zdCB0eXBlZEFycmF5cyA9IFsnSW50OCcsJ1VpbnQ4JywnVWludDhDbGFtcGVkJywnSW50MTYnLCdVaW50MTYnLCdJbnQzMicsJ1VpbnQzMicsJ0Zsb2F0MzInLCdGbG9hdDY0JywnQmlnSW50NjQnLCdCaWdVaW50NjQnXS5tYXAodHlwZSA9PiB0eXBlICsgJ0FycmF5JylcblxubGV0IGdsYmwgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcgPyBnbG9iYWxUaGlzIDogd2luZG93O1xuY3VycmVudEV4dGVuc2lvbnNbMHg3NF0gPSAoZGF0YSkgPT4ge1xuXHRsZXQgdHlwZUNvZGUgPSBkYXRhWzBdXG5cdGxldCB0eXBlZEFycmF5TmFtZSA9IHR5cGVkQXJyYXlzW3R5cGVDb2RlXVxuXHRpZiAoIXR5cGVkQXJyYXlOYW1lKSB7XG5cdFx0aWYgKHR5cGVDb2RlID09PSAxNikge1xuXHRcdFx0bGV0IGFiID0gbmV3IEFycmF5QnVmZmVyKGRhdGEubGVuZ3RoIC0gMSlcblx0XHRcdGxldCB1OCA9IG5ldyBVaW50OEFycmF5KGFiKVxuXHRcdFx0dTguc2V0KGRhdGEuc3ViYXJyYXkoMSkpXG5cdFx0XHRyZXR1cm4gYWI7XG5cdFx0fVxuXHRcdHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgdHlwZWQgYXJyYXkgZm9yIGNvZGUgJyArIHR5cGVDb2RlKVxuXHR9XG5cdC8vIHdlIGhhdmUgdG8gYWx3YXlzIHNsaWNlL2NvcHkgaGVyZSB0byBnZXQgYSBuZXcgQXJyYXlCdWZmZXIgdGhhdCBpcyB3b3JkL2J5dGUgYWxpZ25lZFxuXHRyZXR1cm4gbmV3IGdsYmxbdHlwZWRBcnJheU5hbWVdKFVpbnQ4QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YSwgMSkuYnVmZmVyKVxufVxuY3VycmVudEV4dGVuc2lvbnNbMHg3OF0gPSAoKSA9PiB7XG5cdGxldCBkYXRhID0gcmVhZCgpXG5cdHJldHVybiBuZXcgUmVnRXhwKGRhdGFbMF0sIGRhdGFbMV0pXG59XG5jb25zdCBURU1QX0JVTkRMRSA9IFtdXG5jdXJyZW50RXh0ZW5zaW9uc1sweDYyXSA9IChkYXRhKSA9PiB7XG5cdGxldCBkYXRhU2l6ZSA9IChkYXRhWzBdIDw8IDI0KSArIChkYXRhWzFdIDw8IDE2KSArIChkYXRhWzJdIDw8IDgpICsgZGF0YVszXVxuXHRsZXQgZGF0YVBvc2l0aW9uID0gcG9zaXRpb25cblx0cG9zaXRpb24gKz0gZGF0YVNpemUgLSBkYXRhLmxlbmd0aFxuXHRidW5kbGVkU3RyaW5ncyA9IFRFTVBfQlVORExFXG5cdGJ1bmRsZWRTdHJpbmdzID0gW3JlYWRPbmx5SlNTdHJpbmcoKSwgcmVhZE9ubHlKU1N0cmluZygpXVxuXHRidW5kbGVkU3RyaW5ncy5wb3NpdGlvbjAgPSAwXG5cdGJ1bmRsZWRTdHJpbmdzLnBvc2l0aW9uMSA9IDBcblx0YnVuZGxlZFN0cmluZ3MucG9zdEJ1bmRsZVBvc2l0aW9uID0gcG9zaXRpb25cblx0cG9zaXRpb24gPSBkYXRhUG9zaXRpb25cblx0cmV0dXJuIHJlYWQoKVxufVxuXG5jdXJyZW50RXh0ZW5zaW9uc1sweGZmXSA9IChkYXRhKSA9PiB7XG5cdC8vIDMyLWJpdCBkYXRlIGV4dGVuc2lvblxuXHRpZiAoZGF0YS5sZW5ndGggPT0gNClcblx0XHRyZXR1cm4gbmV3IERhdGUoKGRhdGFbMF0gKiAweDEwMDAwMDAgKyAoZGF0YVsxXSA8PCAxNikgKyAoZGF0YVsyXSA8PCA4KSArIGRhdGFbM10pICogMTAwMClcblx0ZWxzZSBpZiAoZGF0YS5sZW5ndGggPT0gOClcblx0XHRyZXR1cm4gbmV3IERhdGUoXG5cdFx0XHQoKGRhdGFbMF0gPDwgMjIpICsgKGRhdGFbMV0gPDwgMTQpICsgKGRhdGFbMl0gPDwgNikgKyAoZGF0YVszXSA+PiAyKSkgLyAxMDAwMDAwICtcblx0XHRcdCgoZGF0YVszXSAmIDB4MykgKiAweDEwMDAwMDAwMCArIGRhdGFbNF0gKiAweDEwMDAwMDAgKyAoZGF0YVs1XSA8PCAxNikgKyAoZGF0YVs2XSA8PCA4KSArIGRhdGFbN10pICogMTAwMClcblx0ZWxzZSBpZiAoZGF0YS5sZW5ndGggPT0gMTIpLy8gVE9ETzogSW1wbGVtZW50IHN1cHBvcnQgZm9yIG5lZ2F0aXZlXG5cdFx0cmV0dXJuIG5ldyBEYXRlKFxuXHRcdFx0KChkYXRhWzBdIDw8IDI0KSArIChkYXRhWzFdIDw8IDE2KSArIChkYXRhWzJdIDw8IDgpICsgZGF0YVszXSkgLyAxMDAwMDAwICtcblx0XHRcdCgoKGRhdGFbNF0gJiAweDgwKSA/IC0weDEwMDAwMDAwMDAwMDAgOiAwKSArIGRhdGFbNl0gKiAweDEwMDAwMDAwMDAwICsgZGF0YVs3XSAqIDB4MTAwMDAwMDAwICsgZGF0YVs4XSAqIDB4MTAwMDAwMCArIChkYXRhWzldIDw8IDE2KSArIChkYXRhWzEwXSA8PCA4KSArIGRhdGFbMTFdKSAqIDEwMDApXG5cdGVsc2Vcblx0XHRyZXR1cm4gbmV3IERhdGUoJ2ludmFsaWQnKVxufSAvLyBub3RlcGFjayBkZWZpbmVzIGV4dGVuc2lvbiAwIHRvIG1lYW4gdW5kZWZpbmVkLCBzbyB1c2UgdGhhdCBhcyB0aGUgZGVmYXVsdCBoZXJlXG4vLyByZWdpc3RyYXRpb24gb2YgYnVsayByZWNvcmQgZGVmaW5pdGlvbj9cbi8vIGN1cnJlbnRFeHRlbnNpb25zWzB4NTJdID0gKCkgPT5cblxuZnVuY3Rpb24gc2F2ZVN0YXRlKGNhbGxiYWNrKSB7XG5cdGlmIChvblNhdmVTdGF0ZSlcblx0XHRvblNhdmVTdGF0ZSgpO1xuXHRsZXQgc2F2ZWRTcmNFbmQgPSBzcmNFbmRcblx0bGV0IHNhdmVkUG9zaXRpb24gPSBwb3NpdGlvblxuXHRsZXQgc2F2ZWRTdHJpbmdQb3NpdGlvbiA9IHN0cmluZ1Bvc2l0aW9uXG5cdGxldCBzYXZlZFNyY1N0cmluZ1N0YXJ0ID0gc3JjU3RyaW5nU3RhcnRcblx0bGV0IHNhdmVkU3JjU3RyaW5nRW5kID0gc3JjU3RyaW5nRW5kXG5cdGxldCBzYXZlZFNyY1N0cmluZyA9IHNyY1N0cmluZ1xuXHRsZXQgc2F2ZWRTdHJpbmdzID0gc3RyaW5nc1xuXHRsZXQgc2F2ZWRSZWZlcmVuY2VNYXAgPSByZWZlcmVuY2VNYXBcblx0bGV0IHNhdmVkQnVuZGxlZFN0cmluZ3MgPSBidW5kbGVkU3RyaW5nc1xuXG5cdC8vIFRPRE86IFdlIG1heSBuZWVkIHRvIHJldmlzaXQgdGhpcyBpZiB3ZSBkbyBtb3JlIGV4dGVybmFsIGNhbGxzIHRvIHVzZXIgY29kZSAoc2luY2UgaXQgY291bGQgYmUgc2xvdylcblx0bGV0IHNhdmVkU3JjID0gbmV3IFVpbnQ4QXJyYXkoc3JjLnNsaWNlKDAsIHNyY0VuZCkpIC8vIHdlIGNvcHkgdGhlIGRhdGEgaW4gY2FzZSBpdCBjaGFuZ2VzIHdoaWxlIGV4dGVybmFsIGRhdGEgaXMgcHJvY2Vzc2VkXG5cdGxldCBzYXZlZFN0cnVjdHVyZXMgPSBjdXJyZW50U3RydWN0dXJlc1xuXHRsZXQgc2F2ZWRTdHJ1Y3R1cmVzQ29udGVudHMgPSBjdXJyZW50U3RydWN0dXJlcy5zbGljZSgwLCBjdXJyZW50U3RydWN0dXJlcy5sZW5ndGgpXG5cdGxldCBzYXZlZFBhY2tyID0gY3VycmVudFVucGFja3Jcblx0bGV0IHNhdmVkU2VxdWVudGlhbE1vZGUgPSBzZXF1ZW50aWFsTW9kZVxuXHRsZXQgdmFsdWUgPSBjYWxsYmFjaygpXG5cdHNyY0VuZCA9IHNhdmVkU3JjRW5kXG5cdHBvc2l0aW9uID0gc2F2ZWRQb3NpdGlvblxuXHRzdHJpbmdQb3NpdGlvbiA9IHNhdmVkU3RyaW5nUG9zaXRpb25cblx0c3JjU3RyaW5nU3RhcnQgPSBzYXZlZFNyY1N0cmluZ1N0YXJ0XG5cdHNyY1N0cmluZ0VuZCA9IHNhdmVkU3JjU3RyaW5nRW5kXG5cdHNyY1N0cmluZyA9IHNhdmVkU3JjU3RyaW5nXG5cdHN0cmluZ3MgPSBzYXZlZFN0cmluZ3Ncblx0cmVmZXJlbmNlTWFwID0gc2F2ZWRSZWZlcmVuY2VNYXBcblx0YnVuZGxlZFN0cmluZ3MgPSBzYXZlZEJ1bmRsZWRTdHJpbmdzXG5cdHNyYyA9IHNhdmVkU3JjXG5cdHNlcXVlbnRpYWxNb2RlID0gc2F2ZWRTZXF1ZW50aWFsTW9kZVxuXHRjdXJyZW50U3RydWN0dXJlcyA9IHNhdmVkU3RydWN0dXJlc1xuXHRjdXJyZW50U3RydWN0dXJlcy5zcGxpY2UoMCwgY3VycmVudFN0cnVjdHVyZXMubGVuZ3RoLCAuLi5zYXZlZFN0cnVjdHVyZXNDb250ZW50cylcblx0Y3VycmVudFVucGFja3IgPSBzYXZlZFBhY2tyXG5cdGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHNyYy5idWZmZXIsIHNyYy5ieXRlT2Zmc2V0LCBzcmMuYnl0ZUxlbmd0aClcblx0cmV0dXJuIHZhbHVlXG59XG5leHBvcnQgZnVuY3Rpb24gY2xlYXJTb3VyY2UoKSB7XG5cdHNyYyA9IG51bGxcblx0cmVmZXJlbmNlTWFwID0gbnVsbFxuXHRjdXJyZW50U3RydWN0dXJlcyA9IG51bGxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEV4dGVuc2lvbihleHRlbnNpb24pIHtcblx0aWYgKGV4dGVuc2lvbi51bnBhY2spXG5cdFx0Y3VycmVudEV4dGVuc2lvbnNbZXh0ZW5zaW9uLnR5cGVdID0gZXh0ZW5zaW9uLnVucGFja1xuXHRlbHNlXG5cdFx0Y3VycmVudEV4dGVuc2lvbnNbZXh0ZW5zaW9uLnR5cGVdID0gZXh0ZW5zaW9uXG59XG5cbmV4cG9ydCBjb25zdCBtdWx0MTAgPSBuZXcgQXJyYXkoMTQ3KSAvLyB0aGlzIGlzIGEgdGFibGUgbWF0Y2hpbmcgYmluYXJ5IGV4cG9uZW50cyB0byB0aGUgbXVsdGlwbGllciB0byBkZXRlcm1pbmUgc2lnbmlmaWNhbnQgZGlnaXQgcm91bmRpbmdcbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcblx0bXVsdDEwW2ldID0gKygnMWUnICsgTWF0aC5mbG9vcig0NS4xNSAtIGkgKiAwLjMwMTAzKSlcbn1cbmV4cG9ydCBjb25zdCBEZWNvZGVyID0gVW5wYWNrclxudmFyIGRlZmF1bHRVbnBhY2tyID0gbmV3IFVucGFja3IoeyB1c2VSZWNvcmRzOiBmYWxzZSB9KVxuZXhwb3J0IGNvbnN0IHVucGFjayA9IGRlZmF1bHRVbnBhY2tyLnVucGFja1xuZXhwb3J0IGNvbnN0IHVucGFja011bHRpcGxlID0gZGVmYXVsdFVucGFja3IudW5wYWNrTXVsdGlwbGVcbmV4cG9ydCBjb25zdCBkZWNvZGUgPSBkZWZhdWx0VW5wYWNrci51bnBhY2tcbmV4cG9ydCBjb25zdCBGTE9BVDMyX09QVElPTlMgPSB7XG5cdE5FVkVSOiAwLFxuXHRBTFdBWVM6IDEsXG5cdERFQ0lNQUxfUk9VTkQ6IDMsXG5cdERFQ0lNQUxfRklUOiA0XG59XG5sZXQgZjMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDEpXG5sZXQgdThBcnJheSA9IG5ldyBVaW50OEFycmF5KGYzMkFycmF5LmJ1ZmZlciwgMCwgNClcbmV4cG9ydCBmdW5jdGlvbiByb3VuZEZsb2F0MzIoZmxvYXQzMk51bWJlcikge1xuXHRmMzJBcnJheVswXSA9IGZsb2F0MzJOdW1iZXJcblx0bGV0IG11bHRpcGxpZXIgPSBtdWx0MTBbKCh1OEFycmF5WzNdICYgMHg3ZikgPDwgMSkgfCAodThBcnJheVsyXSA+PiA3KV1cblx0cmV0dXJuICgobXVsdGlwbGllciAqIGZsb2F0MzJOdW1iZXIgKyAoZmxvYXQzMk51bWJlciA+IDAgPyAwLjUgOiAtMC41KSkgPj4gMCkgLyBtdWx0aXBsaWVyXG59XG5leHBvcnQgZnVuY3Rpb24gc2V0UmVhZFN0cnVjdCh1cGRhdGVkUmVhZFN0cnVjdCwgbG9hZGVkU3RydWN0cywgc2F2ZVN0YXRlKSB7XG5cdHJlYWRTdHJ1Y3QgPSB1cGRhdGVkUmVhZFN0cnVjdDtcblx0b25Mb2FkZWRTdHJ1Y3R1cmVzID0gbG9hZGVkU3RydWN0cztcblx0b25TYXZlU3RhdGUgPSBzYXZlU3RhdGU7XG59XG4iLCJpbXBvcnQgeyBQYWNrciwgdW5wYWNrIH0gZnJvbSBcIkBjb2x5c2V1cy9tc2dwYWNrclwiO1xuaW1wb3J0IHsgZGVjb2RlLCBEZWNvZGVyLCBlbmNvZGUgfSBmcm9tIFwiQGNvbHlzZXVzL3NjaGVtYVwiO1xuaW1wb3J0IHsgTXlSb29tU3RhdGUgfSBmcm9tIFwiLi9zY2hlbWFzLnRzXCI7XG5pbXBvcnQgeyBQcm90b2NvbCwgQ3VzdG9tTWVzc2FnZVR5cGUgfSBmcm9tIFwiLi9lbnVtcy50c1wiO1xuXG5jb25zdCBmaWx0ZXJlZE1lc3NhZ2VzID0gW1wiUGluZ1wiLCBcIlBvbmdcIiwgXCJQb3NpdGlvblVwZGF0ZVwiXTtcblxuLy8gQHRzLWlnbm9yZVxuY29uc3Qgb3JpZ1dTID0gdW5zYWZlV2luZG93LldlYlNvY2tldDtcblxuY29uc3Qgc3RhdGUgPSBuZXcgTXlSb29tU3RhdGUoKTtcbmNvbnN0IGRlY29kZXIgPSBuZXcgRGVjb2RlcihzdGF0ZSk7XG53aW5kb3cuc3RhdGUgPSBzdGF0ZTtcbi8vIEB0cy1pZ25vcmVcbnVuc2FmZVdpbmRvdy5kZWNvZGVyID0gZGVjb2RlcjtcblxuZnVuY3Rpb24gcHJvY2Vzc1BhY2tldChidWZmZXI6IEFycmF5QnVmZmVyLCBzb3VyY2U/OiBzdHJpbmcpIHtcblx0Y29uc3QgaXQgPSB7IG9mZnNldDogMSB9O1xuXHRjb25zdCBjb2RlID0gYnVmZmVyWzBdO1xuXHRpZiAoY29kZSA9PT0gUHJvdG9jb2wuSk9JTl9ST09NKSB7XG5cdFx0cmV0dXJuIFtjb2RlLCBcImpvaW5pbmchXCJdO1xuXHR9IGVsc2UgaWYgKGNvZGUgPT09IFByb3RvY29sLlJPT01fREFUQSkge1xuXHRcdGNvbnN0IHR5cGUgPSBkZWNvZGUuc3RyaW5nQ2hlY2soYnVmZmVyLCBpdCkgPyBkZWNvZGUuc3RyaW5nKGJ1ZmZlciwgaXQpIDogZGVjb2RlLm51bWJlcihidWZmZXIsIGl0KTtcblx0XHRjb25zdCBtZXNzYWdlID0gYnVmZmVyLmJ5dGVMZW5ndGggPiBpdC5vZmZzZXQgPyB1bnBhY2soYnVmZmVyLCB7IHN0YXJ0OiBpdC5vZmZzZXQgfSkgOiB1bmRlZmluZWQ7XG5cdFx0aWYgKGZpbHRlcmVkTWVzc2FnZXMuaW5kZXhPZihDdXN0b21NZXNzYWdlVHlwZVt0eXBlXSkgPT09IC0xKVxuXHRcdFx0Y29uc29sZS5sb2coc291cmNlID09PSBcInJcIiA/IFwicmVjdlwiIDogXCJzZW5kXCIsIEN1c3RvbU1lc3NhZ2VUeXBlW3R5cGVdID8/IHR5cGUsIG1lc3NhZ2UgPz8gXCJlbXB0eVwiKTtcblx0XHRyZXR1cm4gW2NvZGUsIEN1c3RvbU1lc3NhZ2VUeXBlW3R5cGVdLCBtZXNzYWdlXTtcblx0fSBlbHNlIGlmIChjb2RlID09PSBQcm90b2NvbC5ST09NX1NUQVRFKSB7XG5cdFx0cmV0dXJuIGRlY29kZXIuZGVjb2RlKGJ1ZmZlciwgaXQpO1xuXHR9IGVsc2UgaWYgKGNvZGUgPT09IFByb3RvY29sLlJPT01fU1RBVEVfUEFUQ0gpIHtcblx0XHRyZXR1cm4gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLCBpdCk7XG5cdH0gZWxzZSBpZiAoY29kZSA9PT0gUHJvdG9jb2wuTEVBVkVfUk9PTSkge1xuXHRcdHJldHVybiBbY29kZSwgXCJMZWF2aW5nIHJvb20hXCJdO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBbY29kZSwgXCI/XCJdO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGVuY29kZVJvb21EYXRhKHR5cGU6IHN0cmluZyB8IG51bWJlciwgbWVzc2FnZTogdW5rbm93bikge1xuXHRjb25zdCBpdCA9IHsgb2Zmc2V0OiAxIH07XG5cdGNvbnN0IHBhY2tyID0gbmV3IFBhY2tyKCk7XG5cdHBhY2tyLmVuY29kZSh1bmRlZmluZWQpO1xuXHRwYWNrci5idWZmZXJbMF0gPSBQcm90b2NvbC5ST09NX0RBVEE7XG5cdGlmICh0eXBlb2YgdHlwZSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdGVuY29kZS5zdHJpbmcocGFja3IuYnVmZmVyLCB0eXBlLCBpdCk7XG5cdH0gZWxzZSB7XG5cdFx0ZW5jb2RlLm51bWJlcihwYWNrci5idWZmZXIsIHR5cGUsIGl0KTtcblx0fVxuXHRwYWNrci5wb3NpdGlvbiA9IDA7XG5cdHJldHVybiBtZXNzYWdlICE9PSB1bmRlZmluZWRcblx0XHQ/IHBhY2tyLnBhY2sobWVzc2FnZSwgMjA0OCArIGl0Lm9mZnNldCkgLy8gMjA0OCA9IFJFU0VSVkVfU1RBUlRfU1BBQ0Vcblx0XHQ6IHBhY2tyLmJ1ZmZlci5zdWJhcnJheSgwLCBpdC5vZmZzZXQpO1xufVxuLy8gQHRzLWlnbm9yZVxudW5zYWZlV2luZG93LnNlbmRDdXN0b20gPSAodHlwZTogc3RyaW5nIHwgbnVtYmVyLCBtZXNzYWdlOiB1bmtub3duKSA9PiB7XG5cdGNvbnN0IGJ1ZiA9IGVuY29kZVJvb21EYXRhKHR5cGUsIG1lc3NhZ2UpO1xuXHQvLyBAdHMtaWdub3JlXG5cdHVuc2FmZVdpbmRvdy5jdXJyZW50U29ja2V0Py5zZW5kKGJ1Zik7XG59O1xuXG5jbGFzcyBIb29rZWRXUyBleHRlbmRzIG9yaWdXUyB7XG5cdGNvbnN0cnVjdG9yKC4uLmFyZ3M6IGFueVtdKSB7XG5cdFx0Y29uc29sZS5sb2coYGNvbm5lY3RpbmcgdG8gJHthcmdzWzBdfWApO1xuXHRcdHN1cGVyKC4uLmFyZ3MpO1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHR1bnNhZmVXaW5kb3cuY3VycmVudFNvY2tldCA9IHRoaXM7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHRoaXMuc2VuZCA9IChwYWNrZXQ6IGFueSkgPT4ge1xuXHRcdFx0Y29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkocGFja2V0KTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbnN0IHJlc3AgPSBwcm9jZXNzUGFja2V0KGJ1ZmZlciwgXCJzXCIpO1xuXHRcdFx0fSBjYXRjaCAoZSkge31cblx0XHRcdHJldHVybiBzdXBlci5zZW5kKHBhY2tldCk7XG5cdFx0fTtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0dGhpcy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZXZ0OiB7IGRhdGE6IEFycmF5QnVmZmVyIH0pID0+IHtcblx0XHRcdGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGV2dC5kYXRhKTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHByb2Nlc3NQYWNrZXQoYnVmZmVyLCBcInJcIik7XG5cdFx0XHR9IGNhdGNoIChlKSB7fVxuXHRcdH0pO1xuXHR9XG59XG5cbi8vIEB0cy1pZ25vcmVcbnVuc2FmZVdpbmRvdy5XZWJTb2NrZXQgPSBIb29rZWRXUztcbiJdLCJuYW1lcyI6WyJQcm90b2NvbCIsIkN1c3RvbU1lc3NhZ2VUeXBlIiwiU2NoZW1hIiwidHlwZSIsIkNvbHlWZWN0b3IzIiwiQ29seVJpZ2lkIiwiV2VhcG9uIiwiUHVibGljVXNlckRhdGEiLCJTaG90IiwiUGxheWVyIiwiU3Bhd25lZEl0ZW0iLCJHcmVuYWRlIiwiQ2FwdHVyZVBvaW50IiwiRmxhZyIsIkRyb3BwZWRUYWciLCJNeVJvb21TdGF0ZSIsIlBhY2tyIiwidW5wYWNrIiwiZGVjb2RlIiwiRGVjb2RlciIsImVuY29kZSIsImZpbHRlcmVkTWVzc2FnZXMiLCJvcmlnV1MiLCJ1bnNhZmVXaW5kb3ciLCJzdGF0ZSIsImRlY29kZXIiLCJ3aW5kb3ciLCJwcm9jZXNzUGFja2V0IiwiYnVmZmVyIiwic291cmNlIiwiaXQiLCJjb2RlIiwibWVzc2FnZSIsInVuZGVmaW5lZCIsIl9DdXN0b21NZXNzYWdlVHlwZV90eXBlIiwiY29uc29sZSIsImVuY29kZVJvb21EYXRhIiwicGFja3IiLCJfdW5zYWZlV2luZG93X2N1cnJlbnRTb2NrZXQiLCJidWYiLCJIb29rZWRXUyIsIl9rZXkiLCJhcmdzIiwicGFja2V0IiwiVWludDhBcnJheSIsInJlc3AiLCJlIiwiX3RoaXMiLCJldnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0EsSUFBSSxLQUE0RCxXQUFXLE9BQU87QUFDbEYsSUFBSSxDQUN1RztBQUMzRyxDQUFDLEVBQUUsSUFBSSx3QkFBd0I7O0FBRS9CLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyw4Q0FBOEM7O0FBRW5EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsTUFBTSxvQkFBb0IsTUFBTTtBQUN4RTtBQUNBLFVBQVUsTUFBTTtBQUNoQjtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQSxrRkFBa0Ysb0JBQW9CO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxTQUFTO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUNBQW1DO0FBQzVEO0FBQ0EsMkJBQTJCLCtDQUErQztBQUMxRTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx5QkFBeUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBLGdDQUFnQyxpQkFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsYUFBYTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlCQUFpQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHlHQUF5RztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQ0FBZ0M7O0FBRWpFO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdCQUF3Qjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLDRCQUE0QixNQUFN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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxXQUFXO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sVUFBVSxPQUFPLFdBQVcsT0FBTztBQUNuQztBQUNBO0FBQ0EsWUFBWSxPQUFPLFdBQVcsT0FBTyx5QkFBeUIsT0FBTztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsVUFBVTtBQUNuRTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNELGNBQWM7Ozs7Ozs7OztBQzViZDtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLGtCQUFrQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkMsaURBQWlELEVBQUU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFlBQVk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFF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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLEtBQUs7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixpQ0FBaUMsMEJBQTBCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0wsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQ0FBZ0M7QUFDOUM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0lBQW9JLDhDQUFNO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhCQUE4QjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxTQUFTLDhCQUE4QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4QkFBOEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsU0FBUyw4QkFBOEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMkRBQW1CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw4QkFBOEI7QUFDOUIsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtQkFBbUI7QUFDM0I7QUFDQTtBQUNBLEdBQUc7QUFDSCxRQUFRLG1CQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsUUFBUSwrQkFBK0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1CQUFtQjtBQUMzQjtBQUNBO0FBQ0EsR0FBRztBQUNILFFBQVEsbUJBQW1CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxRQUFRLCtCQUErQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3REFBa0I7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNzQztBQUM3QyxDQUE2QztBQUN0QyxRQUFRLDRDQUE0QyxFQUFFLHVEQUFlO0FBQ3JFO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNybENQO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxtQkFBbUIsTUFBTSxtQkFBbUIsTUFBTTtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxtRkFBbUYsTUFBTTtBQUN6RixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFLE9BQU8sMEpBQTBKLEVBQUU7QUFDbks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRUE7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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

